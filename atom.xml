<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技術筆記</title>
  
  <subtitle>單晶片、即時作業系統與韌體相關之技術筆記</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.lusw.dev/"/>
  <updated>2020-04-23T08:04:49.000Z</updated>
  <id>http://blog.lusw.dev/</id>
  
  <author>
    <name>LuSkywalker</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C 語言使用 Union 與位元欄位來改特定 bit 區間值</title>
    <link href="http://blog.lusw.dev/c-bit-operation/"/>
    <id>http://blog.lusw.dev/c-bit-operation/</id>
    <published>2020-04-10T09:28:52.000Z</published>
    <updated>2020-04-23T08:04:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 C 語言中，如果我們要對特定的 bit(s) 做操作的話，最直覺的方式是用 bit and（<code>&amp;</code>）跟 bit or（<code>|</code>）：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> bit_sample = <span class="number">0x0123</span>; <span class="comment">/* 0000 0001 0010 0011 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 將第 2 個 bit 改成 1 */</span></span><br><span class="line">bit_samplee |= (<span class="number">0x1</span> &lt;&lt; <span class="number">2</span>); <span class="comment">/* 0000 0001 0010 0011 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 將第 5 個 bit 改成 1 */</span></span><br><span class="line">bit_samplee |= ~(<span class="number">0x1</span> &lt;&lt; <span class="number">5</span>); <span class="comment">/* 0000 0001 0010 0011 */</span></span><br></pre></td></tr></tbody></table></figure><p>從上面的例子可以看到如何使用 bit and/or 來操作特定的 bit，這種方式對於單一個 bit 並不會太麻煩，但有以下缺點：</p><ul><li>無法覆用：這種方式不能快速地建立一個方法，也比較不好理解</li><li>對於區間上就不好使了</li></ul><p>如果要解決上述缺點，有一個方式是使用 <code>union</code>，一個在嵌入式、驅動程式裡常常用到的方法。</p><hr><h2 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h2><p><code>union</code> 是 C 語言裡面可以對一個結構裡面的元素，可以有不同的資料型態去理解，如以下例子：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> sample {</span><br><span class="line">    <span class="keyword">int</span> sample_int;</span><br><span class="line">    <span class="keyword">char</span> sample_str[<span class="number">4</span>];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>需要注意的是：同一時間內只能存取一個屬性，準確來說他們是共用一個記憶體區塊，所以改第一個值第二個值會同時更改。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[[C 語言] 程式設計教學：如何使用聯合 (Union)](https://michaelchen.tech/c-programming/union/)">[1]</span></a></sup></p></blockquote><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>奇怪，不是在講 <code>union</code> 嗎，怎麼會提到 <code>struct</code> 呢？那是因為 C 裡面有一個有趣的東西叫做位元欄位<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[位元欄](https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5)">[2]</span></a></sup>，這個東西必須搭配結構使用；先看例子：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bit_row</span> {</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> row1 : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> row2 : <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> row3 : <span class="number">1</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>乍看之下好像跟一般的結構差不多，可是我們注意到在每個元素宣告的結尾多了一個 <code>: 數字</code>，這是什麼意思？</p><ol><li>首先，<code>unsigned short</code> 在 64 位元裡大小是 4位，<code>unsigned int</code> 則是 8位</li><li>加上 <code>: 數字</code>，這個東西就叫位元欄位，我們可以限制當前元素的大小</li><li>因此，元素 1 的大小就被我們縮至 1 位，依此類推</li></ol><hr><p>有了上述的<strong>工具</strong>就可以建立一個好用而且好理解的位元操作方法！</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> method_ex {</span><br><span class="line">    <span class="keyword">int</span> real_val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bits</span> {</span></span><br><span class="line">        <span class="keyword">short</span> bit0to2 : <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">short</span> bit3and4 : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">short</span> bit5to7 : <span class="number">3</span>;</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>建立好上面這個 union 後，如果要將某一個整數的第 3 到 4 位 的值改掉，可以這樣寫</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> method_ex int_ex;</span><br><span class="line">int_ex.real_val = <span class="number">0x0123</span>; <span class="comment">/* 0000 0001 0010 0011 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* change 3 and 4 bits to 01 */</span></span><br><span class="line">int_ex.bits.bit3and4 = B01; <span class="comment">/* 0000 0001 0010 1011 */</span></span><br></pre></td></tr></tbody></table></figure><p>這樣的寫法，更簡單，更易懂。</p><hr><h3 id="剩下的空間"><a href="#剩下的空間" class="headerlink" title="剩下的空間"></a>剩下的空間</h3><p>值得注意的一件事，我們沿用上面的例子；<code>method_ex</code> 有一個元素叫<em>真正的值</em>，他是一個整數（8 位），剛好另外一個元素我們使用位元欄位的技巧也控制在 8 位；但，如果我們沒有這麼做呢？</p><p>答案是：你可以這麼寫，不會有什麼問題，但不建議。</p><h4 id="更大"><a href="#更大" class="headerlink" title="更大"></a>更大</h4><p>如果 <code>bits</code> 結構今天大於 8 位，那我們就沒辦法透過更改<em>真正的值</em>來改變到高於 8 位的值，因此這麼做是<strong>沒意義</strong>的。</p><h4 id="更小"><a href="#更小" class="headerlink" title="更小"></a>更小</h4><p>如果 <code>bits</code> 結構今天小於 8 位，這麼做完全不會有任何問題，但習慣上，我們會把它補齊，像是我們在 <a href="/c-attribute">attribute</a> 篇裡提到的 padding。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> method_ex {</span><br><span class="line">    <span class="keyword">int</span> real_val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bits</span> {</span></span><br><span class="line">        <span class="keyword">short</span> bit0to2 : <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">short</span> bit3and4 : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">short</span> bit5and6 : <span class="number">2</span>;</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-info"><p>沒有定義第 7 位</p></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> method_ex {</span><br><span class="line">    <span class="keyword">int</span> real_val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bits</span> {</span></span><br><span class="line">        <span class="keyword">short</span> bit0to2 : <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">short</span> bit3and4 : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">short</span> bit5and6 : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">short</span> notused : <span class="number">1</span>;</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-info"><p>隨便取名，只要有定義就好</p></div><div id="footnotes"><hr class="clearfix"><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://michaelchen.tech/c-programming/union/" target="_blank" rel="noopener">[C 語言] 程式設計教學：如何使用聯合 (Union)</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5" target="_blank" rel="noopener">位元欄</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;在 C 語言中，如果我們要對特定的 bit(s) 做操作的話，最直覺的方式是
      
    
    </summary>
    
    
      <category term="C語言" scheme="http://blog.lusw.dev/categories/C%E8%AA%9E%E8%A8%80/"/>
    
    
      <category term="C" scheme="http://blog.lusw.dev/tags/C/"/>
    
      <category term="Clang" scheme="http://blog.lusw.dev/tags/Clang/"/>
    
      <category term="C語言" scheme="http://blog.lusw.dev/tags/C%E8%AA%9E%E8%A8%80/"/>
    
      <category term="bit" scheme="http://blog.lusw.dev/tags/bit/"/>
    
      <category term="union" scheme="http://blog.lusw.dev/tags/union/"/>
    
  </entry>
  
  <entry>
    <title>如何查看 Linux 被佔用的 port</title>
    <link href="http://blog.lusw.dev/linux-lookup-port/"/>
    <id>http://blog.lusw.dev/linux-lookup-port/</id>
    <published>2020-04-08T07:08:31.000Z</published>
    <updated>2020-04-22T06:49:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>當我們下 <code>hexo s</code> 後，預設將會開啟 <code>:4000</code>，但如果 <code>:4000</code> 被佔用就會報錯；為解決此問題，我們必須知道是哪個行程佔用，並 <code>kill</code> 它。<br>以下我們介紹 2 種 Linux 的指令。</p></blockquote><h2 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h2><p>lsof (List Open Files)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Linux 列出行程開啟的檔案，lsof 指令用法教學與範例](https://blog.gtwang.org/linux/linux-lsof-command-list-open-files-tutorial-examples/)">[1]</span></a></sup>，可以列出所有被行程打開的檔案。可以利用 <code>-i</code> 來查找所有網路連線；於是</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lsof -i</span></span><br></pre></td></tr></tbody></table></figure><p>將會列出所有使用 port 的行程。而有時候有些 port 會有別名，為了方便找查，我們加上 <code>-P</code> (列出實際的 port number)；於是</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lsof -i -P</span></span><br></pre></td></tr></tbody></table></figure><p>最後為了簡化結果，我們將原本的結果傳給 <code>grep</code></p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lsof -i -P | grep :4000</span></span><br></pre></td></tr></tbody></table></figure><div class="alert alert-info"><p><code>:4000</code> 可任意改成想要的 port number，如 <code>:1234</code></p></div><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>netstat 可以用來查看各種網路狀態，一樣可以拿來查找被佔用的 port。</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> netstat -tulpn</span></span><br></pre></td></tr></tbody></table></figure><p>其中：</p><ul><li><code>-t</code> 代表找走 <code>TCP</code> 協定的</li><li><code>-u</code> 代表找走 <code>UDP</code> 協定的</li><li><code>-l</code> 代表找 <code>LISTEN</code> 的 socket</li><li><code>-n</code> 代表顯示硬體名稱，<code>-p</code> 代表顯示 PID。<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[netstat Command Usage on Linux](https://geekflare.com/netstat/)">[2]</span></a></sup></li></ul><p>我們一樣可以用 <code>grep</code> 來協助尋找</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> netstat -tulpn | grep :4000</span></span><br></pre></td></tr></tbody></table></figure><hr><ul><li>Reference<ul><li><a href="https://www.opencli.com/linux/3-way-check-linux-listen-port" target="_blank" rel="noopener">3 種 Linux 查看 port 被程式佔用的方法</a></li></ul></li></ul><div id="footnotes"><hr class="clearfix"><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://blog.gtwang.org/linux/linux-lsof-command-list-open-files-tutorial-examples/" target="_blank" rel="noopener">Linux 列出行程開啟的檔案，lsof 指令用法教學與範例</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://geekflare.com/netstat/" target="_blank" rel="noopener">netstat Command Usage on Linux</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;當我們下 &lt;code&gt;hexo s&lt;/code&gt; 
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.lusw.dev/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.lusw.dev/tags/Linux/"/>
    
      <category term="port" scheme="http://blog.lusw.dev/tags/port/"/>
    
      <category term="lsof" scheme="http://blog.lusw.dev/tags/lsof/"/>
    
      <category term="netstat" scheme="http://blog.lusw.dev/tags/netstat/"/>
    
  </entry>
  
  <entry>
    <title>Linux 的 &quot;init&quot; 行程</title>
    <link href="http://blog.lusw.dev/linux-init-number/"/>
    <id>http://blog.lusw.dev/linux-init-number/</id>
    <published>2020-04-08T06:18:01.000Z</published>
    <updated>2020-04-22T04:29:36.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="init-行程"><a href="#init-行程" class="headerlink" title="init 行程"></a>init 行程</h2><p>init 行程（process/tas）是 Linux 內核下的第一個行程，內核會在初始化完硬體後建立該行程。</p><blockquote><p>如<a href="https://blog.lusw.dev/starting-xv6/#toc-heading-3">XV6 啟動流程</a> 中提到的 <code>userinit()</code></p></blockquote><p>正常來說 init 應該被放在 <code>/sbin/init</code> 中，如果內核找不到，會試著在 <code>/bin/sh</code> 中尋找，若都失敗則將導致<strong>啟動失敗</strong>。</p><h2 id="init-等級"><a href="#init-等級" class="headerlink" title="init 等級"></a>init 等級</h2><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>等級</th><th>用途</th></tr></thead><tbody><tr><td>0</td><td>關機</td></tr><tr><td>1</td><td>single user mode</td></tr><tr><td>6</td><td>重新啟動</td></tr></tbody></table></div><ul><li>對於 2 ~ 5，不同的發行版有不同的解釋，大部分的系統中：<ul><li>3 代表正常啟動 CLI</li><li>5 代表正常啟動 GUI </li></ul></li></ul><hr><ul><li>Reference<ul><li><a href="https://blog.csdn.net/cougar_mountain/article/details/9798191" target="_blank" rel="noopener">linux 下的init 0，1，2，3，4，5，6知识介绍</a></li><li><a href="http://felix-lin.com/linux/init%E6%BC%94%E5%8C%96%E6%AD%B7%E7%A8%8B-%E8%BD%89%E8%B2%BC-%E6%B7%BA%E6%9E%90-linux-%E5%88%9D%E5%A7%8B%E5%8C%96-init-%E7%B3%BB%E7%B5%B1%EF%BC%8C%E7%AC%AC-1-%E9%83%A8%E5%88%86-sysvinit/" target="_blank" rel="noopener">init演化歷程 – [轉貼] 淺析 Linux 初始化 init 系統，第 1 部分: sysvinit</a></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;init-行程&quot;&gt;&lt;a href=&quot;#init-行程&quot; class
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.lusw.dev/categories/Linux/"/>
    
    
      <category term="kernel" scheme="http://blog.lusw.dev/tags/kernel/"/>
    
      <category term="Linux" scheme="http://blog.lusw.dev/tags/Linux/"/>
    
      <category term="init" scheme="http://blog.lusw.dev/tags/init/"/>
    
  </entry>
  
  <entry>
    <title>在 Xcode 中為免費開發者帳戶重新建立憑證</title>
    <link href="http://blog.lusw.dev/renew-xcode-profile-free-develope-account/"/>
    <id>http://blog.lusw.dev/renew-xcode-profile-free-develope-account/</id>
    <published>2020-03-23T03:54:33.000Z</published>
    <updated>2020-04-19T14:29:53.843Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="免費帳戶憑證"><a href="#免費帳戶憑證" class="headerlink" title="免費帳戶憑證"></a>免費帳戶憑證</h2><p>免費版開發者帳戶的憑證有效期限只有 7 天，可以參考此連結。<br><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%85%8D%E8%B2%BB%E9%96%8B%E7%99%BC%E5%B8%B3%E8%99%9F%E7%9A%84-ios-app-%E5%91%BD%E4%B8%AD%E6%B3%A8%E5%AE%9A%E5%8F%AA%E8%83%BD%E6%B4%BB%E4%B8%83%E5%A4%A9-8fd2cc849bfb" target="_blank" rel="noopener">免費開發帳號的 iOS App 命中注定只能活七天 !</a></p><p>理論上來說，超過期限只要重新從 Xcode 安裝 App 就會自動重簽 (renew)，但如果在期限內想要直接延期呢？</p><h2 id="建立新的憑證"><a href="#建立新的憑證" class="headerlink" title="建立新的憑證"></a>建立新的憑證</h2><p>如果想要直接延期，唯一的方法只有重新建立一個憑證：</p><ul><li><p>從 Preference 中的 Accounts<br><img src="https://i.imgur.com/JfTJGet.png" alt="Preference > Accounts"></p></li><li><p>選擇右下角的 Manage Certificates…<br><img src="https://i.imgur.com/r5PAFur.png" alt="黃框處"></p></li><li><p>按下去，選擇左下角的 <code>+</code><br><img src="https://i.imgur.com/Q59J2Tj.png" alt="黃框處"></p></li><li><p>選擇 Apple Development<br><img src="https://i.imgur.com/bSelwuz.png" alt=""></p></li></ul><p>之後就會新增一個憑證，可以回去 Targets 看憑證的確更新了。<br><img src="https://i.imgur.com/9MsNUqd.png" alt="紅字"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;免費帳戶憑證&quot;&gt;&lt;a href=&quot;#免費帳戶憑證&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Note" scheme="http://blog.lusw.dev/categories/Note/"/>
    
    
      <category term="Xcode" scheme="http://blog.lusw.dev/tags/Xcode/"/>
    
      <category term="ios" scheme="http://blog.lusw.dev/tags/ios/"/>
    
      <category term="renew" scheme="http://blog.lusw.dev/tags/renew/"/>
    
      <category term="certificate" scheme="http://blog.lusw.dev/tags/certificate/"/>
    
  </entry>
  
  <entry>
    <title>CSS3選擇器 :not()</title>
    <link href="http://blog.lusw.dev/css-not-selecter/"/>
    <id>http://blog.lusw.dev/css-not-selecter/</id>
    <published>2020-01-29T06:03:34.000Z</published>
    <updated>2020-04-22T06:51:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>假設有多個一樣 <code>label</code> 的元素要套用一種樣式，但又有幾個需要排除在外時使用。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ex-box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"ex"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"ex"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"ex"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"ex"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.ex-box</span> {</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#555</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.ex</span> {</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f00</span>;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><style>.ex-box {    border: 1px solid #555;    text-align: center;}.ex {    color: #f00;    font-style: italic;    font-weight: bold;}</style><br><div class="ex-box"><span class="ex">1</span>    <span class="ex">2</span>    <span class="ex">3</span>    <span class="ex">4</span></div><div class="alert alert-info"><p>可以看到上面：1~4 都有<em>斜體</em>跟<strong>粗體</strong>，為了方便觀察，這裡讓文字變為紅色</p></div><hr><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"not-ex-box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"not-ex"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"not-ex"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"not-ex"</span> <span class="attr">id</span>=<span class="string">"not-ex-ignored"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"not-ex"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>接著將 3 號加上 <code>not-ex-ignored</code> 的 id。</p><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.not-ex-box</span> {</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#555</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.not-ex</span><span class="selector-pseudo">:not(</span><span class="selector-id">#not-ex-ignored</span>) {</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f00</span>;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>並將此 id 略過（使用 <code>:not</code> 選擇器）</p><style>.not-ex-box {    border: 1px solid #555;    text-align: center;}.not-ex:not(#not-ex-ignored) {    color: #f00;    font-style: italic;    font-weight: bold;}</style><div class="not-ex-box"><span class="not-ex">1</span>    <span class="not-ex">2</span>    <span class="not-ex" id="not-ex-ignored">3</span>    <span class="not-ex">4</span></div><div class="alert alert-info"><p>如此一來，就只有三號沒有套用到屬性。</p></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;用途&quot;&gt;&lt;a href=&quot;#用途&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Note" scheme="http://blog.lusw.dev/categories/Note/"/>
    
    
      <category term="selector" scheme="http://blog.lusw.dev/tags/selector/"/>
    
      <category term="note" scheme="http://blog.lusw.dev/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Perl 模組安裝</title>
    <link href="http://blog.lusw.dev/perl-install-module/"/>
    <id>http://blog.lusw.dev/perl-install-module/</id>
    <published>2019-12-27T10:40:13.000Z</published>
    <updated>2020-04-22T04:30:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="使用自動安裝的環境"><a href="#使用自動安裝的環境" class="headerlink" title="使用自動安裝的環境"></a>使用自動安裝的環境</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> perl -MCPAN -e shell</span></span><br></pre></td></tr></tbody></table></figure><ul><li>類似於 <code>apt</code>、<code>brew</code> 的好用套件，輸入指令會進入此環境中，成功的話終端機會顯示此畫面:</li></ul><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cman&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cman&gt; install Module::Name</span></span><br></pre></td></tr></tbody></table></figure><ul><li>直接下 install 指令 後面接模組名稱即可。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;使用自動安裝的環境&quot;&gt;&lt;a href=&quot;#使用自動安裝的環境&quot; c
      
    
    </summary>
    
    
      <category term="Note" scheme="http://blog.lusw.dev/categories/Note/"/>
    
    
      <category term="perl" scheme="http://blog.lusw.dev/tags/perl/"/>
    
  </entry>
  
  <entry>
    <title>在 Arduino 上使用中斷</title>
    <link href="http://blog.lusw.dev/arduino-interrupt/"/>
    <id>http://blog.lusw.dev/arduino-interrupt/</id>
    <published>2019-12-26T15:36:34.000Z</published>
    <updated>2020-04-22T06:55:23.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="新增中斷"><a href="#新增中斷" class="headerlink" title="新增中斷"></a>新增中斷</h2><figure class="highlight arduino"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">attachInterrupt</span>(digitalPinToInterrupt(pin), ISR, mode);</span><br><span class="line"><span class="built_in">attachInterrupt</span>(interrupt, ISR, mode);</span><br><span class="line"><span class="built_in">attachInterrupt</span>(pin, ISR, mode);</span><br></pre></td></tr></tbody></table></figure><ul><li>有三種可選：<ul><li>第一個參數代表幾號中斷或是幾號 pin，通常用第一種寫法最保險</li><li>第二個參數放 ISR，當中斷發生時要做的事</li><li>第三個參數為發生中斷的模式，下面有詳細介紹</li></ul></li></ul><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul><li>LOW：當 pin 處於低電位的時候觸發中斷</li><li>RISING：當 pin 從低電位轉為高電位時觸發中斷</li><li>FALLING：當 pin 從高電位轉為高電位時觸發中斷</li><li>CHANGE：當 pin 的電位發生改變時觸發中斷</li><li>HIGH：當 pin 處於高電位時觸發中斷（只適用 arduino due）</li></ul><h2 id="移除中斷"><a href="#移除中斷" class="headerlink" title="移除中斷"></a>移除中斷</h2><figure class="highlight arduino"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">detachInterrupt</span>(digitalPinToInterrupt(pin));</span><br><span class="line"><span class="built_in">detachInterrupt</span>(interrupt);</span><br><span class="line"><span class="built_in">detachInterrupt</span>(pin);</span><br></pre></td></tr></tbody></table></figure><ul><li>一樣有三個寫法，與新增中斷的第一個參數相同。</li></ul><h2 id="關閉-開啟中斷"><a href="#關閉-開啟中斷" class="headerlink" title="關閉/開啟中斷"></a>關閉/開啟中斷</h2><figure class="highlight arduino"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">noInterrupts</span>();</span><br><span class="line"><span class="built_in">interrupts</span>();</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-warning"><p><code>noInterrupts</code> 不會將 <code>reset</code> 中斷關閉。</p></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;新增中斷&quot;&gt;&lt;a href=&quot;#新增中斷&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Note" scheme="http://blog.lusw.dev/categories/Note/"/>
    
    
      <category term="Arduino" scheme="http://blog.lusw.dev/tags/Arduino/"/>
    
      <category term="interrupt" scheme="http://blog.lusw.dev/tags/interrupt/"/>
    
  </entry>
  
  <entry>
    <title>使用 ANSI 跳脫碼印出有色文字</title>
    <link href="http://blog.lusw.dev/ascii-color/"/>
    <id>http://blog.lusw.dev/ascii-color/</id>
    <published>2019-12-26T14:50:57.000Z</published>
    <updated>2020-04-22T04:32:43.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="ANSI-跳脫碼"><a href="#ANSI-跳脫碼" class="headerlink" title="ANSI 跳脫碼"></a>ANSI 跳脫碼</h2><p>ANSI 跳脫碼，即 ASCII Escape Code，標準 CSI 格式為</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">CSI n1 [;n2 [;...]] m</span><br></pre></td></tr></tbody></table></figure><ul><li><code>n1</code> 通常填入 <code>\x1b</code>，在 ASCII 表中 <code>0x1b</code> 代表著 escape。</li><li><code>n1</code>、<code>n2</code> 為 <strong>SGR (Select Graphic Rendition)</strong>，可參考表格對應相對的值。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[[Linux C] ANSI逃脫碼與printf顏色教學](http://naeilproj.blogspot.com/2015/08/linux-c-c-printf.html)">[1]</span></a></sup></li></ul><h2 id="顏色輸出"><a href="#顏色輸出" class="headerlink" title="顏色輸出"></a>顏色輸出</h2><h3 id="範例：粗紅體"><a href="#範例：粗紅體" class="headerlink" title="範例：粗紅體"></a>範例：粗紅體</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">\x1b[;<span class="number">31</span>;<span class="number">1</span>m</span><br></pre></td></tr></tbody></table></figure><ul><li>SGR 30~37 代表著顏色，可參照此表格<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[ANSI跳脫序列](https://zh.wikipedia.org/wiki/ANSI%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97)">[2]</span></a></sup><br><img src="https://i.imgur.com/8HEFwxZ.png" alt=""></li><li>後面的 1 代表粗體，不寫則為一般字型；通常一般的終端機會將粗體顯示成較亮的顏色，而非粗體。</li><li>有些終端機提供用高位的數字指定較亮的顏色，90-97 及 100-107，如下圖<br><img src="https://i.imgur.com/mEP8AjU.png" alt=""></li></ul><h3 id="xterm-256color"><a href="#xterm-256color" class="headerlink" title="xterm-256color"></a>xterm-256color</h3><ul><li>使用 8 位元的 SGR，進而提供 256 色的輸出。<br><img src="https://i.imgur.com/hjjHfve.png" alt=""></li></ul><div id="footnotes"><hr class="clearfix"><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="http://naeilproj.blogspot.com/2015/08/linux-c-c-printf.html" target="_blank" rel="noopener">[Linux C] ANSI逃脫碼與printf顏色教學</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/ANSI%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97" target="_blank" rel="noopener">ANSI跳脫序列</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;ANSI-跳脫碼&quot;&gt;&lt;a href=&quot;#ANSI-跳脫碼&quot; cla
      
    
    </summary>
    
    
      <category term="C語言" scheme="http://blog.lusw.dev/categories/C%E8%AA%9E%E8%A8%80/"/>
    
    
      <category term="C" scheme="http://blog.lusw.dev/tags/C/"/>
    
      <category term="Clang" scheme="http://blog.lusw.dev/tags/Clang/"/>
    
      <category term="C語言" scheme="http://blog.lusw.dev/tags/C%E8%AA%9E%E8%A8%80/"/>
    
      <category term="ASCII" scheme="http://blog.lusw.dev/tags/ASCII/"/>
    
      <category term="ANSI" scheme="http://blog.lusw.dev/tags/ANSI/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread GUI 繪圖引擎 - 硬體</title>
    <link href="http://blog.lusw.dev/rtgui-dc-hw/"/>
    <id>http://blog.lusw.dev/rtgui-dc-hw/</id>
    <published>2019-03-13T03:27:41.000Z</published>
    <updated>2020-04-23T05:01:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Rtgui 中的 dc（drawable canvas） 也就是繪圖引擎，可以說是 rtgui 中最重要的一個部分，其中分成 3 個部分：給硬體的 dc_hw、給 buffer 的 dc_buffer 以及給 client 的。</p><p>接下來將會追蹤 dc_hw 中的程式碼，分析 rtgui 是如何在螢幕上面描繪點線面。</p><hr><h2 id="結構"><a href="#結構" class="headerlink" title="結構"></a>結構</h2><h3 id="dc"><a href="#dc" class="headerlink" title="dc"></a>dc</h3><div class="alert alert-success"><p><strong>File:</strong> dc.h</p></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The abstract device context</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Normally, a DC is a drawable canvas, user can draw point/line/cycle etc</span></span><br><span class="line"><span class="comment"> * on the DC.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are several kinds of DC:</span></span><br><span class="line"><span class="comment"> * - Hardware DC;</span></span><br><span class="line"><span class="comment"> * - Client DC;</span></span><br><span class="line"><span class="comment"> * - Buffer DC;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* type of device context */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dc engine */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_engine</span> *<span class="title">engine</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="dc-engine"><a href="#dc-engine" class="headerlink" title="dc_engine"></a>dc_engine</h3><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_engine</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* interface */</span></span><br><span class="line">    <span class="keyword">void</span> (*draw_point)(struct rtgui_dc *dc, <span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">    <span class="keyword">void</span> (*draw_color_point)(struct rtgui_dc *dc, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">rtgui_color_t</span> color);</span><br><span class="line">    <span class="keyword">void</span> (*draw_vline)(struct rtgui_dc *dc, <span class="keyword">int</span> x, <span class="keyword">int</span> y1, <span class="keyword">int</span> y2);</span><br><span class="line">    <span class="keyword">void</span> (*draw_hline)(struct rtgui_dc *dc, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y);</span><br><span class="line">    <span class="keyword">void</span> (*fill_rect)(struct rtgui_dc *dc, <span class="keyword">rtgui_rect_t</span> *rect);</span><br><span class="line">    <span class="keyword">void</span> (*blit_line)(struct rtgui_dc *dc, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y, <span class="keyword">rt_uint8_t</span> *line_data);</span><br><span class="line">    <span class="keyword">void</span> (*blit)(struct rtgui_dc *dc, struct rtgui_point *dc_point, struct rtgui_dc *dest, <span class="keyword">rtgui_rect_t</span> *rect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*fini)(struct rtgui_dc *dc);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="dc-hw"><a href="#dc-hw" class="headerlink" title="dc_hw"></a>dc_hw</h3><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The hardware device context</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The hardware DC is a context based on hardware device, for examle the</span></span><br><span class="line"><span class="comment"> * LCD device. The operations on the hardware DC are reflected to the real</span></span><br><span class="line"><span class="comment"> * hardware.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc</span> <span class="title">parent</span>;</span></span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *owner;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_graphic_driver</span> *<span class="title">hw_driver</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="hw-engine"><a href="#hw-engine" class="headerlink" title="hw_engine"></a>hw_engine</h3><div class="alert alert-success"><p><strong>File:</strong> dc_hw.c</p></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_engine</span> <span class="title">dc_hw_engine</span> =</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    rtgui_dc_hw_draw_point,</span><br><span class="line">    rtgui_dc_hw_draw_color_point,</span><br><span class="line">    rtgui_dc_hw_draw_vline,</span><br><span class="line">    rtgui_dc_hw_draw_hline,</span><br><span class="line">    rtgui_dc_hw_fill_rect,</span><br><span class="line">    rtgui_dc_hw_blit_line,</span><br><span class="line">    rtgui_dc_hw_blit,</span><br><span class="line"></span><br><span class="line">    rtgui_dc_hw_fini,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="啟動-dc"><a href="#啟動-dc" class="headerlink" title="啟動 dc"></a>啟動 dc</h2><p>我們可以從 rtgui 官方提供的範例發現，在使用 dc 前，需要先利用 <code>rtgui_dc_begin_drawing</code> 來啟動引擎，並在結束時呼叫 <code>rtgui_dc_end_drawing</code>；而啟動時，會判斷要使用哪種 dc，並啟動，如 1866 至 1871 行</p><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1866</span><br><span class="line">1867</span><br><span class="line">1868</span><br><span class="line">1869</span><br><span class="line">1870</span><br><span class="line">1871</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* create client or hardware DC */</span></span><br><span class="line">    <span class="keyword">if</span> ((rtgui_region_is_flat(&amp;owner-&gt;clip) == RT_EOK) &amp;&amp;</span><br><span class="line">            rtgui_rect_is_equal(&amp;(owner-&gt;extent), &amp;(owner-&gt;clip.extents)) == RT_EOK)</span><br><span class="line">        dc = rtgui_dc_hw_create(owner);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dc = rtgui_dc_client_create(owner);</span><br></pre></td></tr></tbody></table></figure><p>如果判斷為 hw，則進入 <code>rtgui_dc_hw_create</code> </p><hr><h2 id="建立-dc"><a href="#建立-dc" class="headerlink" title="建立 dc"></a>建立 dc</h2><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*owner</code></th></tr></thead><tbody><tr><td>建立 dc</td><td>dc 指標</td><td>dc 擁有者</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct rtgui_dc *<span class="title">rtgui_dc_hw_create</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *owner)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* adjudge owner */</span></span><br><span class="line">    <span class="keyword">if</span> (owner == RT_NULL || owner-&gt;toplevel == RT_NULL) <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create DC */</span></span><br><span class="line">    dc = (struct rtgui_dc_hw *) rtgui_malloc(<span class="keyword">sizeof</span>(struct rtgui_dc_hw));</span><br><span class="line">    <span class="keyword">if</span> (dc)</span><br><span class="line">    {</span><br><span class="line">        dc-&gt;parent.type = RTGUI_DC_HW;</span><br><span class="line">        dc-&gt;parent.engine = &amp;dc_hw_engine;</span><br><span class="line">        dc-&gt;owner = owner;</span><br><span class="line">        dc-&gt;hw_driver = rtgui_graphic_driver_get_default();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &amp;(dc-&gt;parent);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="運作-dc-畫圖"><a href="#運作-dc-畫圖" class="headerlink" title="運作 dc (畫圖)"></a>運作 dc (畫圖)</h2><h3 id="點"><a href="#點" class="headerlink" title="點"></a>點</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>畫點</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*self</code></th><th><code>x</code></th><th><code>y</code></th></tr></thead><tbody><tr><td>dc 本體</td><td>座標 x</td><td>座標 y</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * draw a logic point on device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_draw_point</span><span class="params">(struct rtgui_dc *self, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(self != RT_NULL);</span><br><span class="line">    dc = (struct rtgui_dc_hw *) self;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    x = x + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    y = y + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* draw this point */</span></span><br><span class="line">    dc-&gt;hw_driver-&gt;ops-&gt;set_pixel(&amp;(dc-&gt;owner-&gt;gc.foreground), x, y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>首先傳進去的座標一律為邏輯位置，也就是以此 dc 所屬物件（有可能是視窗、元件等）的 $(x_1,y_1)$ 為原點之座標；由於 $(x_1,y_1)$ 為該物件（通常為矩形）的左下角，所以傳入的座標不會有負號。</p><p>接著將邏輯座標轉為實際座標（也就是螢幕上的真正位置），所以把 $(x,y)$ 轉成 $(x+x_1,y+y_1)$；由於 dc 是跟隨物件的，所以新座標不可超過 $(x_2,y_2)$，也就是右上角。</p><p>最後利用驅動中設定好的 <code>set_pixel</code> 函數來上色，這裡使用預設顏色。</p><hr><h3 id="彩色點"><a href="#彩色點" class="headerlink" title="彩色點"></a>彩色點</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>畫彩色點</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*self</code></th><th><code>x</code></th><th><code>y</code></th><th><code>color</code></th></tr></thead><tbody><tr><td>dc 本體</td><td>座標 x</td><td>座標 y</td><td>所選的顏色</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_draw_color_point</span><span class="params">(struct rtgui_dc *self, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">rtgui_color_t</span> color)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(self != RT_NULL);</span><br><span class="line">    dc = (struct rtgui_dc_hw *) self;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    x = x + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    y = y + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* draw this point */</span></span><br><span class="line">    dc-&gt;hw_driver-&gt;ops-&gt;set_pixel(&amp;color, x, y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>跟上面最大的不同是可以選顏色 (131)。</p><hr><h3 id="水平線"><a href="#水平線" class="headerlink" title="水平線"></a>水平線</h3><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * draw a logic vertical line on device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_draw_vline</span><span class="params">(struct rtgui_dc *self, <span class="keyword">int</span> x, <span class="keyword">int</span> y1, <span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(self != RT_NULL);</span><br><span class="line">    dc = (struct rtgui_dc_hw *) self;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    x = x + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    y1 = y1 + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    y2 = y2 + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y1 &gt; y2)</span><br><span class="line">        _int_swap(y1, y2);</span><br><span class="line">    <span class="keyword">if</span> (y1 &gt; dc-&gt;owner-&gt;extent.y2 || y2 &lt; dc-&gt;owner-&gt;extent.y1)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y1 &lt; dc-&gt;owner-&gt;extent.y1)</span><br><span class="line">        y1 = dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y2 &gt; dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        y2 = dc-&gt;owner-&gt;extent.y2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* draw vline */</span></span><br><span class="line">    dc-&gt;hw_driver-&gt;ops-&gt;draw_vline(&amp;(dc-&gt;owner-&gt;gc.foreground), x, y1, y2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="鉛直線"><a href="#鉛直線" class="headerlink" title="鉛直線"></a>鉛直線</h3><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * draw a logic horizontal line on device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_draw_hline</span><span class="params">(struct rtgui_dc *self, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(self != RT_NULL);</span><br><span class="line">    dc = (struct rtgui_dc_hw *) self;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    y = y + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* convert logic to device */</span></span><br><span class="line">    x1 = x1 + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    x2 = x2 + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; x2)</span><br><span class="line">        _int_swap(x1, x2);</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; dc-&gt;owner-&gt;extent.x2 || x2 &lt; dc-&gt;owner-&gt;extent.x1)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x1 &lt; dc-&gt;owner-&gt;extent.x1)</span><br><span class="line">        x1 = dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x2 &gt; dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        x2 = dc-&gt;owner-&gt;extent.x2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* draw hline */</span></span><br><span class="line">    dc-&gt;hw_driver-&gt;ops-&gt;draw_hline(&amp;(dc-&gt;owner-&gt;gc.foreground), x1, x2, y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_fill_rect</span><span class="params">(struct rtgui_dc *self, struct rtgui_rect *rect)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rtgui_color_t</span> color;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> y1, y2, x1, x2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(self != RT_NULL);</span><br><span class="line">    RT_ASSERT(rect);</span><br><span class="line">    dc = (struct rtgui_dc_hw *) self;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get background color */</span></span><br><span class="line">    color = dc-&gt;owner-&gt;gc.background;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* convert logic to device */</span></span><br><span class="line">    x1 = rect-&gt;x1 + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x1 &lt; dc-&gt;owner-&gt;extent.x1)</span><br><span class="line">        x1 = dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    x2 = rect-&gt;x2 + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x2 &lt; dc-&gt;owner-&gt;extent.x1)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x2 &gt; dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        x2 = dc-&gt;owner-&gt;extent.x2;</span><br><span class="line"></span><br><span class="line">    y1 = rect-&gt;y1 + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y1 &gt; dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (y1 &lt; dc-&gt;owner-&gt;extent.y1)</span><br><span class="line">        y1 = dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    y2 = rect-&gt;y2 + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y2 &lt; dc-&gt;owner-&gt;extent.y1)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (y2 &gt; dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        y2 = dc-&gt;owner-&gt;extent.y2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fill rect */</span></span><br><span class="line">    <span class="keyword">for</span> (; y1 &lt; y2; y1++)</span><br><span class="line">    {</span><br><span class="line">        dc-&gt;hw_driver-&gt;ops-&gt;draw_hline(&amp;color, x1, x2, y1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="blit"><a href="#blit" class="headerlink" title="blit(?)"></a>blit(?)</h3><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_blit_line</span><span class="params">(struct rtgui_dc *self, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y, <span class="keyword">rt_uint8_t</span> *line_data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(self != RT_NULL);</span><br><span class="line">    dc = (struct rtgui_dc_hw *) self;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* convert logic to device */</span></span><br><span class="line">    <span class="keyword">if</span> (y &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    y = y + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y &gt; dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    x1 = x1 + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    x2 = x2 + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; x2)</span><br><span class="line">        _int_swap(x1, x2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; dc-&gt;owner-&gt;extent.x2 || x2 &lt; dc-&gt;owner-&gt;extent.x1)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x1 &lt; dc-&gt;owner-&gt;extent.x1)</span><br><span class="line">        x1 = dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x2 &gt; dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        x2 = dc-&gt;owner-&gt;extent.x2;</span><br><span class="line"></span><br><span class="line">    dc-&gt;hw_driver-&gt;ops-&gt;draw_raw_hline(line_data, x1, x2, y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_blit</span><span class="params">(struct rtgui_dc *dc,</span></span></span><br><span class="line"><span class="function"><span class="params">                             struct rtgui_point *dc_point,</span></span></span><br><span class="line"><span class="function"><span class="params">                             struct rtgui_dc *dest,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">rtgui_rect_t</span> *rect)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* not blit in hardware dc */</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;Rtgui 中的 dc（drawable canvas） 也就是繪圖引擎，可
      
    
    </summary>
    
    
      <category term="RT-Thread GUI" scheme="http://blog.lusw.dev/categories/RT-Thread-GUI/"/>
    
    
      <category term="kernel" scheme="http://blog.lusw.dev/tags/kernel/"/>
    
      <category term="RT-Thread" scheme="http://blog.lusw.dev/tags/RT-Thread/"/>
    
      <category term="GUI" scheme="http://blog.lusw.dev/tags/GUI/"/>
    
      <category term="dc" scheme="http://blog.lusw.dev/tags/dc/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread GUI Server</title>
    <link href="http://blog.lusw.dev/rtgui-server/"/>
    <id>http://blog.lusw.dev/rtgui-server/</id>
    <published>2019-02-23T07:08:11.000Z</published>
    <updated>2020-04-23T05:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="基本事件結構"><a href="#基本事件結構" class="headerlink" title="基本事件結構"></a>基本事件結構</h2><p>server 掌管整個 GUI system 的所有事件 (event)，而根據不同的事件定義不同的結構；在每個不同的結構中都有基本的欄位 <code>_RTGUI_EVENT_WIN_ELEMENTS</code>：</p><div class="alert alert-success"><p><strong>File:</strong> event.c </p></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RTGUI Window Event</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _RTGUI_EVENT_WIN_ELEMENTS \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event</span> <span class="title">parent</span>;</span> \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_win</span> *<span class="title">wid</span>;</span></span><br></pre></td></tr></tbody></table></figure><p><code>rtgui_event</code> 即為事件的基本結構：</p><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* the event type */</span></span><br><span class="line">    <span class="keyword">enum</span> _rtgui_event_type type;</span><br><span class="line">    <span class="comment">/* user field of event */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span> user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the event sender */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_app</span> *<span class="title">sender</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* mailbox to acknowledge request */</span></span><br><span class="line">    <span class="keyword">rt_mailbox_t</span> ack;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event</span> <span class="title">rtgui_event_t</span>;</span></span><br></pre></td></tr></tbody></table></figure><hr><h3 id="基本結構設定"><a href="#基本結構設定" class="headerlink" title="基本結構設定"></a>基本結構設定</h3><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTGUI_EVENT_INIT(e, t)  do      \</span></span><br><span class="line">{                                       \</span><br><span class="line">    (e)-&gt;type = (t);                    \</span><br><span class="line">    (e)-&gt;user = <span class="number">0</span>;                      \</span><br><span class="line">    (e)-&gt;sender = rtgui_app_self();     \</span><br><span class="line">    (e)-&gt;ack = RT_NULL;                 \</span><br><span class="line">} <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="啟動-server"><a href="#啟動-server" class="headerlink" title="啟動 server"></a>啟動 server</h2><div class="alert alert-success"><p><strong>File:</strong> server.c</p></div><p>首先，定義一個 app 名叫 server :</p><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_app</span> *<span class="title">rtgui_server_app</span> = <span class="title">RT_NULL</span>;</span></span><br></pre></td></tr></tbody></table></figure><p>接著透過 <code>rtgui_server_entry</code> 啟動 app，也就是 server:</p><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*parameter</code></th></tr></thead><tbody><tr><td>啟動 server</td><td>void</td><td>未使用</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rtgui server thread's entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_server_entry</span><span class="params">(<span class="keyword">void</span> *parameter)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32_NATIVE</span></span><br><span class="line">    <span class="comment">/* set the server thread to highest */</span></span><br><span class="line">    HANDLE hCurrentThread = GetCurrentThread();</span><br><span class="line">    SetThreadPriority(hCurrentThread, THREAD_PRIORITY_HIGHEST);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create rtgui server application */</span></span><br><span class="line">    rtgui_server_app = rtgui_app_create(<span class="string">"rtgui"</span>);</span><br><span class="line">    <span class="keyword">if</span> (rtgui_server_app == RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        rt_kprintf(<span class="string">"Create GUI server failed.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    rtgui_object_set_event_handler(RTGUI_OBJECT(rtgui_server_app),</span><br><span class="line">                                   rtgui_server_event_handler);</span><br><span class="line">    <span class="comment">/* init mouse and show */</span></span><br><span class="line">    rtgui_mouse_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTGUI_USING_MOUSE_CURSOR</span></span><br><span class="line">    rtgui_mouse_show_cursor();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    rtgui_app_run(rtgui_server_app);</span><br><span class="line"></span><br><span class="line">    rtgui_app_destroy(rtgui_server_app);</span><br><span class="line">    rtgui_server_app = RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最後會進入 <code>rtgui_app_run</code> 並正式開始執行 server，也就是進入所屬的 event handler</p><hr><h2 id="Event-Handler"><a href="#Event-Handler" class="headerlink" title="Event Handler"></a>Event Handler</h2><p>Event handler 也就是 server 的進入點</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;基本事件結構&quot;&gt;&lt;a href=&quot;#基本事件結構&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="RT-Thread GUI" scheme="http://blog.lusw.dev/categories/RT-Thread-GUI/"/>
    
    
      <category term="kernel" scheme="http://blog.lusw.dev/tags/kernel/"/>
    
      <category term="RT-Thread" scheme="http://blog.lusw.dev/tags/RT-Thread/"/>
    
      <category term="GUI" scheme="http://blog.lusw.dev/tags/GUI/"/>
    
      <category term="server" scheme="http://blog.lusw.dev/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread GUI Window</title>
    <link href="http://blog.lusw.dev/rtgui-window/"/>
    <id>http://blog.lusw.dev/rtgui-window/</id>
    <published>2019-01-29T12:53:02.000Z</published>
    <updated>2020-04-23T05:02:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="alert alert-success"><p><strong>File:</strong> window.h</p></div><h2 id="結構"><a href="#結構" class="headerlink" title="結構"></a>結構</h2><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_win</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* inherit from container */</span></span><br><span class="line">    <span class="keyword">rtgui_container_t</span> parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* update count */</span></span><br><span class="line">    <span class="keyword">rt_base_t</span> update;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* drawing count */</span></span><br><span class="line">    <span class="keyword">rt_base_t</span> drawing;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span> <span class="title">drawing_rect</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parent window. RT_NULL if the window is a top level window */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_win</span> *<span class="title">parent_window</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_region</span> <span class="title">outer_clip</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span> <span class="title">outer_extent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the widget that will grab the focus in current window */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> *<span class="title">focused_widget</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* which app I belong */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_app</span> *<span class="title">app</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* window style */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span> style;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* window state flag */</span></span><br><span class="line">    <span class="keyword">enum</span> rtgui_win_flag flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rtgui_modal_code_t</span> modal_code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* last mouse event handled widget */</span></span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *last_mevent_widget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* window title */</span></span><br><span class="line">    <span class="keyword">char</span> *title;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_wintitle</span> *_<span class="title">title_wgt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call back */</span></span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*on_activate)(struct rtgui_object *widget, struct rtgui_event *event);</span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*on_deactivate)(struct rtgui_object *widget, struct rtgui_event *event);</span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*on_close)(struct rtgui_object *widget, struct rtgui_event *event);</span><br><span class="line">    <span class="comment">/* the key is sent to the focused widget by default. If the focused widget</span></span><br><span class="line"><span class="comment">     * and all of it's parents didn't handle the key event, it will be handled</span></span><br><span class="line"><span class="comment">     * by @func on_key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If you want to handle key event on your own, it's better to overload</span></span><br><span class="line"><span class="comment">     * this function other than handle EVENT_KBD in event_handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*on_key)(struct rtgui_object *widget, struct rtgui_event *event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reserved user data */</span></span><br><span class="line">    <span class="keyword">void</span> *user_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Private data. */</span></span><br><span class="line">    <span class="keyword">rt_base_t</span> (*_do_show)(struct rtgui_win *win);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* app ref_count */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span> app_ref_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* win magic flag, magic value is 0xA5A55A5A */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span>magic;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="定義物件類型"><a href="#定義物件類型" class="headerlink" title="定義物件類型"></a>定義物件類型</h3><div class="alert alert-success"><p><strong>File:</strong> window.c</p></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_CLASS_TYPE(win, <span class="string">"win"</span>,</span><br><span class="line">                  RTGUI_PARENT_TYPE(container),</span><br><span class="line">                  _rtgui_win_constructor,</span><br><span class="line">                  _rtgui_win_destructor,</span><br><span class="line">                  <span class="keyword">sizeof</span>(struct rtgui_win));</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="建立視窗"><a href="#建立視窗" class="headerlink" title="建立視窗"></a>建立視窗</h2><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立視窗</td><td>視窗指標</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*parent_window</code></th><th><code>*title</code></th><th><code>*rect</code></th><th><code>style</code></th></tr></thead><tbody><tr><td>上層視窗</td><td>視窗標題</td><td>視窗的大小</td><td>一些風格</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_win_t</span> *rtgui_win_create(struct rtgui_win *parent_window,</span><br><span class="line">                              <span class="keyword">const</span> <span class="keyword">char</span> *title,</span><br><span class="line">                              <span class="keyword">rtgui_rect_t</span> *rect,</span><br><span class="line">                              <span class="keyword">rt_uint16_t</span> style)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_win</span> *<span class="title">win</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate win memory */</span></span><br><span class="line">    win = RTGUI_WIN(rtgui_widget_create(RTGUI_WIN_TYPE));</span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rtgui_win_init(win, parent_window, title, rect, style) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rtgui_widget_destroy(RTGUI_WIDGET(win));</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> win;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_create);</span><br></pre></td></tr></tbody></table></figure><p>透過 <code>rtgui_win_init</code> 完成設定</p><hr><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化視窗</td><td>檢查碼</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*win</code></th><th><code>*parent_window</code></th><th><code>*title</code></th><th><code>*rect</code></th><th><code>style</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>上層視窗</td><td>視窗標題</td><td>視窗的大小</td><td>一些風格</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rtgui_win_init</span><span class="params">(struct rtgui_win *win, struct rtgui_win *parent_window,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">char</span> *title,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">rtgui_rect_t</span> *rect,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">rt_uint16_t</span> style)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set parent window */</span></span><br><span class="line">    win-&gt;parent_window = parent_window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set title, rect and style */</span></span><br><span class="line">    <span class="keyword">if</span> (title != RT_NULL)</span><br><span class="line">        win-&gt;title = rt_strdup(title);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        win-&gt;title = RT_NULL;</span><br><span class="line"></span><br><span class="line">    rtgui_widget_set_rect(RTGUI_WIDGET(win), rect);</span><br><span class="line">    win-&gt;style = style;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!((style &amp; RTGUI_WIN_STYLE_NO_TITLE) &amp;&amp; (style &amp; RTGUI_WIN_STYLE_NO_BORDER)))</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span> <span class="title">trect</span> = *<span class="title">rect</span>;</span></span><br><span class="line"></span><br><span class="line">        win-&gt;_title_wgt = rtgui_wintitle_create(win);</span><br><span class="line">        <span class="keyword">if</span> (!win-&gt;_title_wgt)</span><br><span class="line">            <span class="keyword">goto</span> __on_err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(style &amp; RTGUI_WIN_STYLE_NO_BORDER))</span><br><span class="line">        {</span><br><span class="line">            rtgui_rect_inflate(&amp;trect, WINTITLE_BORDER_SIZE);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!(style &amp; RTGUI_WIN_STYLE_NO_TITLE))</span><br><span class="line">        {</span><br><span class="line">            trect.y1 -= WINTITLE_HEIGHT;</span><br><span class="line">        }</span><br><span class="line">        rtgui_widget_set_rect(RTGUI_WIDGET(win-&gt;_title_wgt), &amp;trect);</span><br><span class="line">        <span class="comment">/* Update the clip of the wintitle manually. */</span></span><br><span class="line">        rtgui_region_subtract_rect(&amp;(RTGUI_WIDGET(win-&gt;_title_wgt)-&gt;clip),</span><br><span class="line">                                   &amp;(RTGUI_WIDGET(win-&gt;_title_wgt)-&gt;clip),</span><br><span class="line">                                   &amp;(RTGUI_WIDGET(win)-&gt;extent));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The window title is always un-hidden for simplicity. */</span></span><br><span class="line">        rtgui_widget_show(RTGUI_WIDGET(win-&gt;_title_wgt));</span><br><span class="line">        rtgui_region_init_with_extents(&amp;win-&gt;outer_clip, &amp;trect);</span><br><span class="line">        win-&gt;outer_extent = trect;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        rtgui_region_init_with_extents(&amp;win-&gt;outer_clip, rect);</span><br><span class="line">        win-&gt;outer_extent = *rect;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_rtgui_win_create_in_server(win) == RT_FALSE)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> __on_err;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    win-&gt;app-&gt;window_cnt++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__on_err:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_init);</span><br></pre></td></tr></tbody></table></figure><h3 id="建立主視窗"><a href="#建立主視窗" class="headerlink" title="建立主視窗"></a>建立主視窗</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立主視窗</td><td>視窗指標</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*parent_window</code></th><th><code>*title</code></th><th><code>style</code></th></tr></thead><tbody><tr><td>上層視窗</td><td>視窗標題</td><td>一些風格</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_win_t</span> *rtgui_mainwin_create(struct rtgui_win *parent_window, <span class="keyword">const</span> <span class="keyword">char</span> *title, <span class="keyword">rt_uint16_t</span> style)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span> <span class="title">rect</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get rect of main window */</span></span><br><span class="line">    rtgui_get_mainwin_rect(&amp;rect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rtgui_win_create(parent_window, title, &amp;rect, style);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_mainwin_create);</span><br></pre></td></tr></tbody></table></figure><p>建立一個固定大小的視窗，這個大小被設定在 <code>_mainwin_rect</code> 這個全域變數裡面，可以透過 <code>rtgui_get_mainwin_rect</code> 來取得這個值。</p><hr><h2 id="刪除視窗"><a href="#刪除視窗" class="headerlink" title="刪除視窗"></a>刪除視窗</h2><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>刪除視窗</td><td>void</td><td>目標視窗</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_destroy</span><span class="params">(struct rtgui_win *win)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* close the window first if it's not. */</span></span><br><span class="line">    <span class="keyword">if</span> (!(win-&gt;flag &amp; RTGUI_WIN_FLAG_CLOSED))</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_close</span> <span class="title">eclose</span>;</span></span><br><span class="line"></span><br><span class="line">        RTGUI_EVENT_WIN_CLOSE_INIT(&amp;eclose);</span><br><span class="line">        eclose.wid = win;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (win-&gt;style &amp; RTGUI_WIN_STYLE_DESTROY_ON_CLOSE)</span><br><span class="line">        {</span><br><span class="line">            _rtgui_win_deal_close(win,</span><br><span class="line">                                  (struct rtgui_event *)&amp;eclose,</span><br><span class="line">                                  RT_TRUE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            _rtgui_win_deal_close(win,</span><br><span class="line">                                  (struct rtgui_event *)&amp;eclose,</span><br><span class="line">                                  RT_TRUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_MODAL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* set the RTGUI_WIN_STYLE_DESTROY_ON_CLOSE flag so the window will be</span></span><br><span class="line"><span class="comment">         * destroyed after the event_loop */</span></span><br><span class="line">        win-&gt;style |= RTGUI_WIN_STYLE_DESTROY_ON_CLOSE;</span><br><span class="line">        rtgui_win_end_modal(win, RTGUI_MODAL_CANCEL);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        rtgui_widget_destroy(RTGUI_WIDGET(win));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_destroy);</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="關閉視窗"><a href="#關閉視窗" class="headerlink" title="關閉視窗"></a>關閉視窗</h2><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>關閉視窗</td><td>void</td><td>目標視窗</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* send a close event to myself to get a consistent behavior */</span></span><br><span class="line"><span class="keyword">rt_bool_t</span> rtgui_win_close(struct rtgui_win *win)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_close</span> <span class="title">eclose</span>;</span></span><br><span class="line"></span><br><span class="line">    RTGUI_EVENT_WIN_CLOSE_INIT(&amp;eclose);</span><br><span class="line">    eclose.wid = win;</span><br><span class="line">    <span class="keyword">return</span> _rtgui_win_deal_close(win,</span><br><span class="line">                                 (struct rtgui_event *)&amp;eclose,</span><br><span class="line">                                 RT_FALSE);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_close);</span><br></pre></td></tr></tbody></table></figure><p>使用 <code>_rtgui_win_deal_close</code> 完成關閉動作</p><hr><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>刪除視窗</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*win</code></th><th><code>*event</code></th><th><code>force_close</code></th></tr></thead><tbody><tr><td>目標視窗</td><td>關閉事件</td><td>是否要強致關閉</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">rt_bool_t</span> _rtgui_win_deal_close(struct rtgui_win *win,</span><br><span class="line">                                       struct rtgui_event *event,</span><br><span class="line">                                       <span class="keyword">rt_bool_t</span> force_close)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (win-&gt;on_close != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> ((win-&gt;on_close(RTGUI_OBJECT(win), event) == RT_FALSE) &amp;&amp; !force_close)</span><br><span class="line">            <span class="keyword">return</span> RT_FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    rtgui_win_hide(win);</span><br><span class="line"></span><br><span class="line">    win-&gt;flag |= RTGUI_WIN_FLAG_CLOSED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_MODAL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* rtgui_win_end_modal cleared the RTGUI_WIN_FLAG_MODAL in win-&gt;flag so</span></span><br><span class="line"><span class="comment">         * we have to record it. */</span></span><br><span class="line">        rtgui_win_end_modal(win, RTGUI_MODAL_CANCEL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    win-&gt;app-&gt;window_cnt--;</span><br><span class="line">    <span class="keyword">if</span> (win-&gt;app-&gt;window_cnt == <span class="number">0</span> &amp;&amp; !(win-&gt;app-&gt;state_flag &amp; RTGUI_APP_FLAG_KEEP))</span><br><span class="line">    {</span><br><span class="line">        rtgui_app_exit(rtgui_app_self(), <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;style &amp; RTGUI_WIN_STYLE_DESTROY_ON_CLOSE)</span><br><span class="line">    {</span><br><span class="line">        rtgui_win_destroy(win);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="設定視窗"><a href="#設定視窗" class="headerlink" title="設定視窗"></a>設定視窗</h2><h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定視窗大小</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*win</code></th><th><code>*rect</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>新大小</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_set_rect</span><span class="params">(<span class="keyword">rtgui_win_t</span> *win, <span class="keyword">rtgui_rect_t</span> *rect)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_resize</span> <span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL || rect == RT_NULL) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    RTGUI_WIDGET(win)-&gt;extent = *rect;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_CONNECTED)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* set window resize event to server */</span></span><br><span class="line">        RTGUI_EVENT_WIN_RESIZE_INIT(&amp;event);</span><br><span class="line">        event.wid = win;</span><br><span class="line">        event.rect = *rect;</span><br><span class="line"></span><br><span class="line">        rtgui_server_post_event(&amp;(event.parent), <span class="keyword">sizeof</span>(struct rtgui_event_win_resize));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_set_rect);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="OnActive-函式"><a href="#OnActive-函式" class="headerlink" title="OnActive 函式"></a>OnActive 函式</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 OnActive 函式</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*win</code></th><th><code>handler</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>OnActive 函式</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_set_onactivate</span><span class="params">(<span class="keyword">rtgui_win_t</span> *win, rtgui_event_handler_ptr handler)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (win != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        win-&gt;on_activate = handler;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_set_onactivate);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="OnDeactive-函式"><a href="#OnDeactive-函式" class="headerlink" title="OnDeactive 函式"></a>OnDeactive 函式</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 OnDeactive 函式</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*win</code></th><th><code>handler</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>OnDeactive 函式</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_set_ondeactivate</span><span class="params">(<span class="keyword">rtgui_win_t</span> *win, rtgui_event_handler_ptr handler)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (win != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        win-&gt;on_deactivate = handler;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_set_ondeactivate);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="OnClose-函式"><a href="#OnClose-函式" class="headerlink" title="OnClose 函式"></a>OnClose 函式</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 OnClose 函式</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*win</code></th><th><code>handler</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>OnClose 函式</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_set_onclose</span><span class="params">(<span class="keyword">rtgui_win_t</span> *win, rtgui_event_handler_ptr handler)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (win != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        win-&gt;on_close = handler;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_set_onclose);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="OnKey"><a href="#OnKey" class="headerlink" title="OnKey"></a>OnKey</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 OnKey 函式</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*win</code></th><th><code>handler</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>OnKey 函式</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_set_onkey</span><span class="params">(<span class="keyword">rtgui_win_t</span> *win, rtgui_event_handler_ptr handler)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (win != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        win-&gt;on_key = handler;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_set_onkey);</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="視窗的行為"><a href="#視窗的行為" class="headerlink" title="視窗的行為"></a>視窗的行為</h2><h3 id="動態模式"><a href="#動態模式" class="headerlink" title="動態模式"></a>動態模式</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>進入動態模式</td><td>檢查碼</td><td>視窗本體</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_base_t</span> rtgui_win_enter_modal(struct rtgui_win *win)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_base_t</span> exit_code = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_modal_enter</span> <span class="title">emodal</span>;</span></span><br><span class="line"></span><br><span class="line">    RTGUI_EVENT_WIN_MODAL_ENTER_INIT(&amp;emodal);</span><br><span class="line">    emodal.wid = win;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rtgui_server_post_event_sync((struct rtgui_event *)&amp;emodal,</span><br><span class="line">                                     <span class="keyword">sizeof</span>(emodal)) != RT_EOK)</span><br><span class="line">        <span class="keyword">return</span> exit_code;</span><br><span class="line"></span><br><span class="line">    win-&gt;flag |= RTGUI_WIN_FLAG_MODAL;</span><br><span class="line">    win-&gt;app_ref_count = win-&gt;app-&gt;ref_count + <span class="number">1</span>;</span><br><span class="line">    exit_code = rtgui_app_run(win-&gt;app);</span><br><span class="line">    win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_MODAL;</span><br><span class="line"></span><br><span class="line">    rtgui_win_hide(win);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exit_code;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_enter_modal);</span><br></pre></td></tr></tbody></table></figure><hr><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>離開動態模式</td><td>檢查碼</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*win</code></th><th><code>modal_code</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>動態模式編號</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_end_modal</span><span class="params">(struct rtgui_win *win, <span class="keyword">rtgui_modal_code_t</span> modal_code)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL || !(win-&gt;flag &amp; RTGUI_WIN_FLAG_MODAL))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (win-&gt;app_ref_count &lt; win-&gt;app-&gt;ref_count)</span><br><span class="line">    {</span><br><span class="line">        rtgui_app_exit(win-&gt;app, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        i ++;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">1000</span>)</span><br><span class="line">        {</span><br><span class="line">            rt_kprintf(<span class="string">" =*=&gt; rtgui_win_end_modal while (win-&gt;app_ref_count &lt; win-&gt;app-&gt;ref_count) \n"</span>);</span><br><span class="line">            RT_ASSERT(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    rtgui_app_exit(win-&gt;app, modal_code);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remove modal mode */</span></span><br><span class="line">    win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_MODAL;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_end_modal);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="現身"><a href="#現身" class="headerlink" title="現身"></a>現身</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>現身該視窗</td><td>檢查碼</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*win</code></th><th><code>is_modal</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>是否為動態模式</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_base_t</span> rtgui_win_show(struct rtgui_win *win, <span class="keyword">rt_bool_t</span> is_modal)</span><br><span class="line">{</span><br><span class="line">    RTGUI_WIDGET_UNHIDE(win);</span><br><span class="line"></span><br><span class="line">    win-&gt;magic = RTGUI_WIN_MAGIC;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_modal)</span><br><span class="line">        win-&gt;flag |= RTGUI_WIN_FLAG_MODAL;</span><br><span class="line">    <span class="keyword">if</span> (win-&gt;_do_show)</span><br><span class="line">        <span class="keyword">return</span> win-&gt;_do_show(win);</span><br><span class="line">    <span class="keyword">return</span> rtgui_win_do_show(win);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_show);</span><br></pre></td></tr></tbody></table></figure><p>如果視窗本身有設定 <code>_do_show</code> 函式的話，則呼叫本身的；否則呼叫 <code>rtgui_win_do_show</code></p><hr><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>視窗現身</td><td>檢查碼</td><td>視窗本體</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_base_t</span> rtgui_win_do_show(struct rtgui_win *win)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_base_t</span> exit_code = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_app</span> *<span class="title">app</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_show</span> <span class="title">eshow</span>;</span></span><br><span class="line"></span><br><span class="line">    RTGUI_EVENT_WIN_SHOW_INIT(&amp;eshow);</span><br><span class="line">    eshow.wid = win;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> exit_code;</span><br><span class="line"></span><br><span class="line">    win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_CLOSED;</span><br><span class="line">    win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_CB_PRESSED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if it does not register into server, create it in server */</span></span><br><span class="line">    <span class="keyword">if</span> (!(win-&gt;flag &amp; RTGUI_WIN_FLAG_CONNECTED))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (_rtgui_win_create_in_server(win) == RT_FALSE)</span><br><span class="line">            <span class="keyword">return</span> exit_code;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set window unhidden before notify the server */</span></span><br><span class="line">    rtgui_widget_show(RTGUI_WIDGET(win));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rtgui_server_post_event_sync(RTGUI_EVENT(&amp;eshow),</span><br><span class="line">                                     <span class="keyword">sizeof</span>(struct rtgui_event_win_show)) != RT_EOK)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* It could not be shown if a parent window is hidden. */</span></span><br><span class="line">        rtgui_widget_hide(RTGUI_WIDGET(win));</span><br><span class="line">        <span class="keyword">return</span> exit_code;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;focused_widget == RT_NULL)</span><br><span class="line">        rtgui_widget_focus(RTGUI_WIDGET(win));</span><br><span class="line"></span><br><span class="line">    app = win-&gt;app;</span><br><span class="line">    RT_ASSERT(app != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set main window */</span></span><br><span class="line">    <span class="keyword">if</span> (app-&gt;main_object == RT_NULL)</span><br><span class="line">        rtgui_app_set_main_win(app, win);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_MODAL)</span><br><span class="line">    {</span><br><span class="line">        exit_code = rtgui_win_enter_modal(win);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exit_code;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_do_show);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="隱藏"><a href="#隱藏" class="headerlink" title="隱藏"></a>隱藏</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>隱藏視窗</td><td>檢查碼</td><td>視窗本體</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_hide</span><span class="params">(struct rtgui_win *win)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(win != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RTGUI_WIDGET_IS_HIDE(win) &amp;&amp;</span><br><span class="line">            win-&gt;flag &amp; RTGUI_WIN_FLAG_CONNECTED)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* send hidden message to server */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_hide</span> <span class="title">ehide</span>;</span></span><br><span class="line">        RTGUI_EVENT_WIN_HIDE_INIT(&amp;ehide);</span><br><span class="line">        ehide.wid = win;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rtgui_server_post_event_sync(RTGUI_EVENT(&amp;ehide),</span><br><span class="line">                                         <span class="keyword">sizeof</span>(struct rtgui_event_win_hide)) != RT_EOK)</span><br><span class="line">        {</span><br><span class="line">            rt_kprintf(<span class="string">"hide win: %s failed\n"</span>, win-&gt;title);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        rtgui_widget_hide(RTGUI_WIDGET(win));</span><br><span class="line">        win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_ACTIVATE;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_hide);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="啟動"><a href="#啟動" class="headerlink" title="啟動"></a>啟動</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>啟動視窗</td><td>檢查碼</td><td>視窗本體</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rtgui_win_activate(struct rtgui_win *win)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_activate</span> <span class="title">eact</span>;</span></span><br><span class="line">    RTGUI_EVENT_WIN_ACTIVATE_INIT(&amp;eact);</span><br><span class="line">    eact.wid = win;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rtgui_server_post_event_sync(RTGUI_EVENT(&amp;eact),</span><br><span class="line">                                        <span class="keyword">sizeof</span>(eact));</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_activate);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="移動"><a href="#移動" class="headerlink" title="移動"></a>移動</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>進入動態模式</td><td>檢查碼</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*win</code></th><th><code>x</code></th><th><code>y</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>目標 x</td><td>目標 y</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_move</span><span class="params">(struct rtgui_win *win, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> *<span class="title">wgt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_move</span> <span class="title">emove</span>;</span></span><br><span class="line">    <span class="keyword">int</span> dx, dy;</span><br><span class="line">    RTGUI_EVENT_WIN_MOVE_INIT(&amp;emove);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;_title_wgt)</span><br><span class="line">    {</span><br><span class="line">        wgt = RTGUI_WIDGET(win-&gt;_title_wgt);</span><br><span class="line">        dx = x - wgt-&gt;extent.x1;</span><br><span class="line">        dy = y - wgt-&gt;extent.y1;</span><br><span class="line">        rtgui_widget_move_to_logic(wgt, dx, dy);</span><br><span class="line"></span><br><span class="line">        wgt = RTGUI_WIDGET(win);</span><br><span class="line">        rtgui_widget_move_to_logic(wgt, dx, dy);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        wgt = RTGUI_WIDGET(win);</span><br><span class="line">        dx = x - wgt-&gt;extent.x1;</span><br><span class="line">        dy = y - wgt-&gt;extent.y1;</span><br><span class="line">        rtgui_widget_move_to_logic(wgt, dx, dy);</span><br><span class="line">    }</span><br><span class="line">    rtgui_rect_move(&amp;win-&gt;outer_extent, dx, dy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_CONNECTED)</span><br><span class="line">    {</span><br><span class="line">        rtgui_widget_hide(RTGUI_WIDGET(win));</span><br><span class="line"></span><br><span class="line">        emove.wid   = win;</span><br><span class="line">        emove.x     = x;</span><br><span class="line">        emove.y     = y;</span><br><span class="line">        <span class="keyword">if</span> (rtgui_server_post_event_sync(RTGUI_EVENT(&amp;emove),</span><br><span class="line">                                         <span class="keyword">sizeof</span>(struct rtgui_event_win_move)) != RT_EOK)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    rtgui_widget_show(RTGUI_WIDGET(win));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_move);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="OnDraw"><a href="#OnDraw" class="headerlink" title="OnDraw"></a>OnDraw</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>OnDraw</td><td>boolean</td><td>視窗本體</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> rt_bool_t <span class="title">rtgui_win_ondraw</span><span class="params">(struct rtgui_win *win)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc</span> *<span class="title">dc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span> <span class="title">rect</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_paint</span> <span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* begin drawing */</span></span><br><span class="line">    dc = rtgui_dc_begin_drawing(RTGUI_WIDGET(win));</span><br><span class="line">    <span class="keyword">if</span> (dc == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RT_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get window rect */</span></span><br><span class="line">    rtgui_widget_get_rect(RTGUI_WIDGET(win), &amp;rect);</span><br><span class="line">    <span class="comment">/* fill area */</span></span><br><span class="line">    rtgui_dc_fill_rect(dc, &amp;rect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* widget drawing */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* paint each widget */</span></span><br><span class="line">    RTGUI_EVENT_PAINT_INIT(&amp;event);</span><br><span class="line">    event.wid = RT_NULL;</span><br><span class="line"></span><br><span class="line">    rtgui_container_dispatch_event(RTGUI_CONTAINER(win),</span><br><span class="line">                                   (<span class="keyword">rtgui_event_t</span> *)&amp;event);</span><br><span class="line"></span><br><span class="line">    rtgui_dc_end_drawing(dc, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_FALSE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="更新重疊區域"><a href="#更新重疊區域" class="headerlink" title="更新重疊區域"></a>更新重疊區域</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>更新重疊區域</td><td>void</td><td>視窗本體</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_update_clip</span><span class="params">(struct rtgui_win *win)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_container</span> *<span class="title">cnt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_list_node</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_CLOSED)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;_title_wgt)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* Reset the inner clip of title. */</span></span><br><span class="line">        RTGUI_WIDGET(win-&gt;_title_wgt)-&gt;extent = win-&gt;outer_extent;</span><br><span class="line">        rtgui_region_copy(&amp;RTGUI_WIDGET(win-&gt;_title_wgt)-&gt;clip, &amp;win-&gt;outer_clip);</span><br><span class="line">        rtgui_region_subtract_rect(&amp;RTGUI_WIDGET(win-&gt;_title_wgt)-&gt;clip,</span><br><span class="line">                                   &amp;RTGUI_WIDGET(win-&gt;_title_wgt)-&gt;clip,</span><br><span class="line">                                   &amp;RTGUI_WIDGET(win)-&gt;extent);</span><br><span class="line">        <span class="comment">/* Reset the inner clip of window. */</span></span><br><span class="line">        rtgui_region_intersect_rect(&amp;RTGUI_WIDGET(win)-&gt;clip,</span><br><span class="line">                                    &amp;win-&gt;outer_clip,</span><br><span class="line">                                    &amp;RTGUI_WIDGET(win)-&gt;extent);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        RTGUI_WIDGET(win)-&gt;extent = win-&gt;outer_extent;</span><br><span class="line">        rtgui_region_copy(&amp;RTGUI_WIDGET(win)-&gt;clip, &amp;win-&gt;outer_clip);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* update the clip info of each child */</span></span><br><span class="line">    cnt = RTGUI_CONTAINER(win);</span><br><span class="line">    rtgui_list_foreach(node, &amp;(cnt-&gt;children))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">rtgui_widget_t</span> *child = rtgui_list_entry(node, <span class="keyword">rtgui_widget_t</span>, sibling);</span><br><span class="line"></span><br><span class="line">        rtgui_widget_update_clip(child);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_update_clip);</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="Event-Handler"><a href="#Event-Handler" class="headerlink" title="Event Handler"></a>Event Handler</h2><p>此 event handler 也就是 window 的函式進入點</p><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>window 函式進入點</td><td>boolean</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*object</code></th><th><code>*event</code></th></tr></thead><tbody><tr><td>物件本體</td><td>行為本體</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_bool_t</span> rtgui_win_event_handler(struct rtgui_object *object, struct rtgui_event *event)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_win</span> *<span class="title">win</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(object != RT_NULL);</span><br><span class="line">    RT_ASSERT(event != RT_NULL);</span><br><span class="line"></span><br><span class="line">    win = RTGUI_WIN(object);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event-&gt;type)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_SHOW:</span><br><span class="line">        rtgui_win_do_show(win);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_HIDE:</span><br><span class="line">        rtgui_win_hide(win);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_CLOSE:</span><br><span class="line">        _rtgui_win_deal_close(win, event, RT_FALSE);</span><br><span class="line">        <span class="comment">/* don't broadcast WIN_CLOSE event to others */</span></span><br><span class="line">        <span class="keyword">return</span> RT_TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_MOVE:</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_move</span> *<span class="title">emove</span> = (<span class="title">struct</span> <span class="title">rtgui_event_win_move</span> *)<span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* move window */</span></span><br><span class="line">        rtgui_win_move(win, emove-&gt;x, emove-&gt;y);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_ACTIVATE:</span><br><span class="line">        <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_UNDER_MODAL ||</span><br><span class="line">                RTGUI_WIDGET_IS_HIDE(win))</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* activate a hide window */</span></span><br><span class="line">            <span class="keyword">return</span> RT_TRUE;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        win-&gt;flag |= RTGUI_WIN_FLAG_ACTIVATE;</span><br><span class="line">        <span class="comment">/* There are many cases where the paint event will follow this activate</span></span><br><span class="line"><span class="comment">         * event and just repaint the title is not a big deal. So just repaint</span></span><br><span class="line"><span class="comment">         * the title if there is one. If you want to update the content of the</span></span><br><span class="line"><span class="comment">         * window, do it in the on_activate callback.*/</span></span><br><span class="line">        <span class="keyword">if</span> (win-&gt;_title_wgt)</span><br><span class="line">            rtgui_widget_update(RTGUI_WIDGET(win-&gt;_title_wgt));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (win-&gt;on_activate != RT_NULL)</span><br><span class="line">        {</span><br><span class="line">            win-&gt;on_activate(RTGUI_OBJECT(object), event);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_DEACTIVATE:</span><br><span class="line">        win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_ACTIVATE;</span><br><span class="line">        <span class="comment">/* No paint event follow the deactive event. So we have to update</span></span><br><span class="line"><span class="comment">         * the title manually to reflect the change. */</span></span><br><span class="line">        <span class="keyword">if</span> (win-&gt;_title_wgt)</span><br><span class="line">            rtgui_widget_update(RTGUI_WIDGET(win-&gt;_title_wgt));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (win-&gt;on_deactivate != RT_NULL)</span><br><span class="line">            win-&gt;on_deactivate(RTGUI_OBJECT(object), event);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_UPDATE_END:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_CLIP_INFO:</span><br><span class="line">        <span class="comment">/* update win clip */</span></span><br><span class="line">        rtgui_win_update_clip(win);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_PAINT:</span><br><span class="line">        <span class="keyword">if</span> (win-&gt;_title_wgt)</span><br><span class="line">            rtgui_widget_update(RTGUI_WIDGET(win-&gt;_title_wgt));</span><br><span class="line">        rtgui_win_ondraw(win);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GUIENGIN_USING_VFRAMEBUFFER</span></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_VPAINT_REQ:</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_vpaint_req</span> *<span class="title">req</span> = (<span class="title">struct</span> <span class="title">rtgui_event_vpaint_req</span> *)<span class="title">event</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get drawing dc */</span></span><br><span class="line">        dc = rtgui_win_get_drawing(win);</span><br><span class="line"></span><br><span class="line">        req-&gt;sender-&gt;buffer = dc;</span><br><span class="line">        rt_completion_done(req-&gt;sender-&gt;cmp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_MOUSE_BUTTON:</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_mouse</span> *<span class="title">emouse</span> = (<span class="title">struct</span> <span class="title">rtgui_event_mouse</span>*)<span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rtgui_rect_contains_point(&amp;RTGUI_WIDGET(win)-&gt;extent,</span><br><span class="line">                                      emouse-&gt;x, emouse-&gt;y) == RT_EOK)</span><br><span class="line">            <span class="keyword">return</span> _win_handle_mouse_btn(win, event);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (win-&gt;_title_wgt)</span><br><span class="line">        {</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_object</span> *<span class="title">tobj</span> = <span class="title">RTGUI_OBJECT</span>(<span class="title">win</span>-&gt;_<span class="title">title_wgt</span>);</span></span><br><span class="line">            <span class="keyword">return</span> tobj-&gt;event_handler(tobj, event);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_MOUSE_MOTION:</span><br><span class="line">        <span class="keyword">return</span> rtgui_container_dispatch_mouse_event(RTGUI_CONTAINER(win),</span><br><span class="line">                (struct rtgui_event_mouse *)event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_KBD:</span><br><span class="line">        <span class="comment">/* we should dispatch key event firstly */</span></span><br><span class="line">        <span class="keyword">if</span> (!(win-&gt;flag &amp; RTGUI_WIN_FLAG_HANDLE_KEY))</span><br><span class="line">        {</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> *<span class="title">widget</span>;</span></span><br><span class="line">            <span class="keyword">rt_bool_t</span> res = RT_FALSE;</span><br><span class="line">            <span class="comment">/* we should dispatch the key event just once. Once entered the</span></span><br><span class="line"><span class="comment">             * dispatch mode, we should swtich to key handling mode. */</span></span><br><span class="line">            win-&gt;flag |= RTGUI_WIN_FLAG_HANDLE_KEY;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* dispatch the key event */</span></span><br><span class="line">            <span class="keyword">for</span> (widget = win-&gt;focused_widget;</span><br><span class="line">                    widget &amp;&amp; !res;</span><br><span class="line">                    widget = widget-&gt;parent)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (RTGUI_OBJECT(widget)-&gt;event_handler != RT_NULL)</span><br><span class="line">                    res = RTGUI_OBJECT(widget)-&gt;event_handler(</span><br><span class="line">                              RTGUI_OBJECT(widget), event);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_HANDLE_KEY;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* in key handling mode(it may reach here in</span></span><br><span class="line"><span class="comment">             * win-&gt;focused_widget-&gt;event_handler call) */</span></span><br><span class="line">            <span class="keyword">if</span> (win-&gt;on_key != RT_NULL)</span><br><span class="line">                <span class="keyword">return</span> win-&gt;on_key(RTGUI_OBJECT(win), event);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_COMMAND:</span><br><span class="line">        <span class="keyword">if</span> (rtgui_container_dispatch_event(RTGUI_CONTAINER(object), event) != RT_TRUE)</span><br><span class="line">        {</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> RT_TRUE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> rtgui_container_event_handler(object, event);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_FALSE;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_event_handler);</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;alert alert-success&quot;&gt;&lt;p&gt;&lt;stro
      
    
    </summary>
    
    
      <category term="RT-Thread GUI" scheme="http://blog.lusw.dev/categories/RT-Thread-GUI/"/>
    
    
      <category term="kernel" scheme="http://blog.lusw.dev/tags/kernel/"/>
    
      <category term="RT-Thread" scheme="http://blog.lusw.dev/tags/RT-Thread/"/>
    
      <category term="GUI" scheme="http://blog.lusw.dev/tags/GUI/"/>
    
      <category term="window" scheme="http://blog.lusw.dev/tags/window/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread GUI Widget</title>
    <link href="http://blog.lusw.dev/rtgui-widget/"/>
    <id>http://blog.lusw.dev/rtgui-widget/</id>
    <published>2019-01-01T10:42:37.000Z</published>
    <updated>2020-04-23T05:02:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>上一篇我們說明了 RTGUI 是如何透過 C 實現物件導向的設計邏輯，這篇將會說明在 RTGUI 中的最小物件 “widget” 是如何創建、運行及刪除的。</p><h2 id="結構"><a href="#結構" class="headerlink" title="結構"></a>結構</h2><div class="alert alert-success"><p><strong>File:</strong> widget.h</p></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * the base widget object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* inherit from rtgui_object */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_object</span> <span class="title">object</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the widget that contains this widget */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="comment">/* the window that contains this widget */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_win</span> *<span class="title">toplevel</span>;</span></span><br><span class="line">    <span class="comment">/* the widget children and sibling */</span></span><br><span class="line">    <span class="keyword">rtgui_list_t</span> sibling;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* widget flag */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hardware device context */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> dc_type;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_engine</span> *<span class="title">dc_engine</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the graphic context of widget */</span></span><br><span class="line">    <span class="keyword">rtgui_gc_t</span> gc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the widget extent */</span></span><br><span class="line">    <span class="keyword">rtgui_rect_t</span> extent;</span><br><span class="line">    <span class="comment">/* the visiable extent (includes the rectangles of children) */</span></span><br><span class="line">    <span class="keyword">rtgui_rect_t</span> extent_visiable;</span><br><span class="line">    <span class="comment">/* the rect clip information */</span></span><br><span class="line">    <span class="keyword">rtgui_region_t</span> clip;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* minimal width and height of widget */</span></span><br><span class="line">    <span class="keyword">rt_int16_t</span> min_width, min_height;</span><br><span class="line">    <span class="comment">/* widget align */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span> align;</span><br><span class="line">    <span class="keyword">rt_uint16_t</span> border;</span><br><span class="line">    <span class="keyword">rt_uint16_t</span> border_style;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call back */</span></span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*on_focus_in)(struct rtgui_object *widget, struct rtgui_event *event);</span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*on_focus_out)(struct rtgui_object *widget, struct rtgui_event *event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* user private data */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> user_data;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> <span class="title">rtgui_widget_t</span>;</span></span><br></pre></td></tr></tbody></table></figure><p>記錄包含他的 widget、所在的 window、一些屬性等</p><h3 id="四方形結構體"><a href="#四方形結構體" class="headerlink" title="四方形結構體"></a>四方形結構體</h3><div class="alert alert-success"><p><strong>File:</strong> rtgui.h</p></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rectangle structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">rt_int16_t</span> x1, y1, x2, y2;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span> <span class="title">rtgui_rect_t</span>;</span></span><br></pre></td></tr></tbody></table></figure><p>對角線 (x1,y1)、(x2,y2)</p><hr><h3 id="定義物件類型"><a href="#定義物件類型" class="headerlink" title="定義物件類型"></a>定義物件類型</h3><div class="alert alert-success"><p><strong>File:</strong> widget.c</p></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_CLASS_TYPE(widget, <span class="string">"widget"</span>,</span><br><span class="line">                  RTGUI_PARENT_TYPE(object),</span><br><span class="line">                  _rtgui_widget_constructor,</span><br><span class="line">                  _rtgui_widget_destructor,</span><br><span class="line">                  <span class="keyword">sizeof</span>(struct rtgui_widget));</span><br><span class="line">RTM_EXPORT(_rtgui_widget);</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="建立-widget"><a href="#建立-widget" class="headerlink" title="建立 widget"></a>建立 widget</h2><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget_type</code></th></tr></thead><tbody><tr><td>建立 widget</td><td>widget 指標</td><td>欲建立的 widget 種類</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_widget_t</span> *rtgui_widget_create(<span class="keyword">const</span> <span class="keyword">rtgui_type_t</span> *widget_type)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> *<span class="title">widget</span>;</span></span><br><span class="line"></span><br><span class="line">    widget = RTGUI_WIDGET(rtgui_object_create(widget_type));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> widget;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_create);</span><br></pre></td></tr></tbody></table></figure><p>呼叫 <code>rtgui_object_create</code>，型態為 widget 完成，並透過 <code>RTGUI_WIDGET</code> 檢查正確性</p><hr><h2 id="刪除-widget"><a href="#刪除-widget" class="headerlink" title="刪除 widget"></a>刪除 widget</h2><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>刪除 widget</td><td>void</td><td>欲刪除的 widget</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_destroy</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    rtgui_object_destroy(RTGUI_OBJECT(widget));</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_destroy);</span><br></pre></td></tr></tbody></table></figure><p>一樣透過 <code>rtgui_object_destroy</code> 來完成</p><hr><h2 id="設定-widget"><a href="#設定-widget" class="headerlink" title="設定 widget"></a>設定 widget</h2><p>RTT GUI 提供一些 API 給使用者去設定 widget 的樣式與行為</p><h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的大小</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*widget</code></th><th><code>x</code></th><th><code>y</code></th><th><code>width</code></th><th><code>height</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>起始座標 x</td><td>y</td><td>寬度</td><td>高度</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_rectangle</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rtgui_rect_t</span> rect;</span><br><span class="line"></span><br><span class="line">    rect.x1 = x;</span><br><span class="line">    rect.y1 = y;</span><br><span class="line">    rect.x2 = x + width;</span><br><span class="line">    rect.y2 = y + height;</span><br><span class="line"></span><br><span class="line">    rtgui_widget_set_rect(widget, &amp;rect);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_rectangle);</span><br></pre></td></tr></tbody></table></figure><p>填入正確的 (x1,y1)、(x2,y2)</p><hr><h3 id="Parent"><a href="#Parent" class="headerlink" title="Parent"></a>Parent</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的上層元素</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*widget</code></th><th><code>parent</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>上層元素 (widget)</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_parent</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">rtgui_widget_t</span> *parent)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* set parent and toplevel widget */</span></span><br><span class="line">    widget-&gt;parent = parent;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_parent);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="大小下界"><a href="#大小下界" class="headerlink" title="大小下界"></a>大小下界</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的大小下界</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*widget</code></th><th><code>width</code></th><th><code>height</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>寬度</td><td>高度</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_minsize</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line">    widget-&gt;min_width = width;</span><br><span class="line">    widget-&gt;min_height = height;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_minsize);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="寬度下界"><a href="#寬度下界" class="headerlink" title="寬度下界"></a>寬度下界</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的寬度下界</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*widget</code></th><th><code>width</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>寬度</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_minwidth</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">int</span> width)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    widget-&gt;min_width = width;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_minwidth);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="高度下界"><a href="#高度下界" class="headerlink" title="高度下界"></a>高度下界</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的高度下界</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*widget</code></th><th><code>height</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>高度</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_minheight</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    widget-&gt;min_height = height;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_minheight);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="邊框風格"><a href="#邊框風格" class="headerlink" title="邊框風格"></a>邊框風格</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的邊框風格</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*widget</code></th><th><code>style</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>風格</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set widget draw style</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_border</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">rt_uint32_t</span> style)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    widget-&gt;border_style = style;</span><br><span class="line">    <span class="keyword">switch</span> (style)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_NONE:</span><br><span class="line">        widget-&gt;border = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_SIMPLE:</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_UP:</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_DOWN:</span><br><span class="line">        widget-&gt;border = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_STATIC:</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_RAISE:</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_SUNKEN:</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_BOX:</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_EXTRA:</span><br><span class="line">        widget-&gt;border = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        widget-&gt;border = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_border);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Focus-函式"><a href="#Focus-函式" class="headerlink" title="Focus 函式"></a>Focus 函式</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的 focus func</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*widget</code></th><th><code>handler</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>focus func</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_onfocus</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, rtgui_event_handler_ptr handler)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    widget-&gt;on_focus_in = handler;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_onfocus);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Unfocus-函式"><a href="#Unfocus-函式" class="headerlink" title="Unfocus 函式"></a>Unfocus 函式</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的 unfocus func</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*widget</code></th><th><code>handler</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>focus func</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_onunfocus</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, rtgui_event_handler_ptr handler)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    widget-&gt;on_focus_out = handler;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_onunfocus);</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-info"><p>這裡是用<strong>指標函數</strong>的方式將行為函式填入結構中，要使用時可直接呼叫結構中的元素使用。</p></div><hr><h2 id="Widget-的行為"><a href="#Widget-的行為" class="headerlink" title="Widget 的行為"></a>Widget 的行為</h2><p>上一節整理了設定 widget 的風格，接下來整理 widget 的行為</p><h3 id="移動到相對位置"><a href="#移動到相對位置" class="headerlink" title="移動到相對位置"></a>移動到相對位置</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>移動 widget 到相對位置</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th align="center"><code>*widget</code></th><th align="center"><code>dx</code></th><th align="center"><code>dy</code></th></tr></thead><tbody><tr><td align="center">欲移動的 widget</td><td align="center">位移量 x</td><td align="center">y</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function moves widget and its children to a logic point</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_move_to_logic</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rtgui_rect_t</span> rect;</span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* give clip of this widget back to parent */</span></span><br><span class="line">    parent = widget-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (parent != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* get the parent rect, even if it's a transparent parent. */</span></span><br><span class="line">        rect = parent-&gt;extent_visiable;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we should find out the none-transparent parent */</span></span><br><span class="line">    <span class="keyword">while</span> (parent != RT_NULL &amp;&amp; parent-&gt;flag &amp; RTGUI_WIDGET_FLAG_TRANSPARENT) parent = parent-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (parent != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* reset clip info */</span></span><br><span class="line">        rtgui_region_init_with_extents(&amp;(widget-&gt;clip), &amp;(widget-&gt;extent));</span><br><span class="line">        rtgui_region_intersect_rect(&amp;(widget-&gt;clip), &amp;(widget-&gt;clip), &amp;rect);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* give back the extent */</span></span><br><span class="line">        rtgui_region_union(&amp;(parent-&gt;clip), &amp;(parent-&gt;clip), &amp;(widget-&gt;clip));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* move this widget (and its children if it's a container) to destination point */</span></span><br><span class="line">    _widget_move(widget, dx, dy);</span><br><span class="line">    <span class="comment">/* update this widget */</span></span><br><span class="line">    rtgui_widget_update_clip(widget);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_move_to_logic);</span><br></pre></td></tr></tbody></table></figure><hr><h4 id="移動-widget"><a href="#移動-widget" class="headerlink" title="移動 widget"></a>移動 widget</h4><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>移動 widget</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*widget</code></th><th><code>dx</code></th><th><code>dy</code></th></tr></thead><tbody><tr><td>欲移動的 widget</td><td>位移量 x</td><td>y</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _widget_move(struct rtgui_widget* widget, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_list_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *child, *parent;</span><br><span class="line"></span><br><span class="line">rtgui_rect_move(&amp;(widget-&gt;extent), dx, dy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* handle visiable extent */</span></span><br><span class="line">    widget-&gt;extent_visiable = widget-&gt;extent;</span><br><span class="line">    parent = widget-&gt;parent;</span><br><span class="line">    <span class="comment">/* we should find out the none-transparent parent */</span></span><br><span class="line">    <span class="keyword">while</span> (parent != RT_NULL &amp;&amp; parent-&gt;flag &amp; RTGUI_WIDGET_FLAG_TRANSPARENT) parent = parent-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;parent)</span><br><span class="line">        rtgui_rect_intersect(&amp;(widget-&gt;parent-&gt;extent_visiable), &amp;(widget-&gt;extent_visiable));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset clip info */</span></span><br><span class="line">    rtgui_region_init_with_extents(&amp;(widget-&gt;clip), &amp;(widget-&gt;extent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* move each child */</span></span><br><span class="line">    <span class="keyword">if</span> (RTGUI_IS_CONTAINER(widget))</span><br><span class="line">    {</span><br><span class="line">        rtgui_list_foreach(node, &amp;(RTGUI_CONTAINER(widget)-&gt;children))</span><br><span class="line">        {</span><br><span class="line">            child = rtgui_list_entry(node, <span class="keyword">rtgui_widget_t</span>, sibling);</span><br><span class="line"></span><br><span class="line">            _widget_move(child, dx, dy);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Focus-widget"><a href="#Focus-widget" class="headerlink" title="Focus widget"></a>Focus widget</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>focus widget</td><td>void</td><td>欲 focus 的 widget</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Focuses the widget. The focused widget is the widget which can receive the keyboard events</span></span><br><span class="line"><span class="comment"> * @param widget a widget</span></span><br><span class="line"><span class="comment"> * @note The widget has to be attached to a toplevel widget, otherwise it will have no effect</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_focus</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> *<span class="title">old_focus</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line">    RT_ASSERT(widget-&gt;toplevel != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RTGUI_WIDGET_IS_FOCUSABLE(widget) || !RTGUI_WIDGET_IS_ENABLE(widget))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    old_focus = RTGUI_WIN(widget-&gt;toplevel)-&gt;focused_widget;</span><br><span class="line">    <span class="keyword">if</span> (old_focus == widget)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* it's the same focused widget */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unfocused the old widget */</span></span><br><span class="line">    <span class="keyword">if</span> (old_focus != RT_NULL)</span><br><span class="line">        rtgui_widget_unfocus(old_focus);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set widget as focused */</span></span><br><span class="line">    widget-&gt;flag |= RTGUI_WIDGET_FLAG_FOCUS;</span><br><span class="line">    RTGUI_WIN(widget-&gt;toplevel)-&gt;focused_widget = widget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* invoke on focus in call back */</span></span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;on_focus_in != RT_NULL)</span><br><span class="line">        widget-&gt;on_focus_in(RTGUI_OBJECT(widget), RT_NULL);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_focus);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Unfocus-widget"><a href="#Unfocus-widget" class="headerlink" title="Unfocus widget"></a>Unfocus widget</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>focus widget</td><td>void</td><td>欲 unfocus 的 widget</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Unfocused the widget</span></span><br><span class="line"><span class="comment"> * @param widget a widget</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_unfocus</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!widget-&gt;toplevel || !RTGUI_WIDGET_IS_FOCUSED(widget))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    widget-&gt;flag &amp;= ~RTGUI_WIDGET_FLAG_FOCUS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;on_focus_out != RT_NULL)</span><br><span class="line">        widget-&gt;on_focus_out(RTGUI_OBJECT(widget), RT_NULL);</span><br><span class="line"></span><br><span class="line">    RTGUI_WIN(widget-&gt;toplevel)-&gt;focused_widget = RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ergodic constituent widget, make child loss of focus */</span></span><br><span class="line">    <span class="keyword">if</span> (RTGUI_IS_CONTAINER(widget))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">rtgui_list_t</span> *node;</span><br><span class="line">        rtgui_list_foreach(node, &amp;(RTGUI_CONTAINER(widget)-&gt;children))</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">rtgui_widget_t</span> *child = rtgui_list_entry(node, <span class="keyword">rtgui_widget_t</span>, sibling);</span><br><span class="line">            <span class="keyword">if</span> (RTGUI_WIDGET_IS_HIDE(child)) <span class="keyword">continue</span>;</span><br><span class="line">            rtgui_widget_unfocus(child);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_unfocus);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="位移-widget"><a href="#位移-widget" class="headerlink" title="位移 widget"></a>位移 widget</h3><h4 id="點向上位移"><a href="#點向上位移" class="headerlink" title="點向上位移"></a>點向上位移</h4><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>點向上位移</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*widget</code></th><th><code>*point</code></th></tr></thead><tbody><tr><td>目標 widget</td><td>目標點</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_point_to_device</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">rtgui_point_t</span> *point)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (point != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        point-&gt;x += widget-&gt;extent.x1;</span><br><span class="line">        point-&gt;y += widget-&gt;extent.y1;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_point_to_device);</span><br></pre></td></tr></tbody></table></figure><h4 id="點向下位移"><a href="#點向下位移" class="headerlink" title="點向下位移"></a>點向下位移</h4><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>點向上位移</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*widget</code></th><th><code>*point</code></th></tr></thead><tbody><tr><td>目標 widget</td><td>目標點</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_point_to_logic</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">rtgui_point_t</span> *point)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (point != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        point-&gt;x -= widget-&gt;extent.x1;</span><br><span class="line">        point-&gt;y -= widget-&gt;extent.y1;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_point_to_logic);</span><br></pre></td></tr></tbody></table></figure><h4 id="矩形向上位移"><a href="#矩形向上位移" class="headerlink" title="矩形向上位移"></a>矩形向上位移</h4><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>點向上位移</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*widget</code></th><th><code>*rect</code></th></tr></thead><tbody><tr><td>目標 widget</td><td>目標矩形</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_rect_to_device</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">rtgui_rect_t</span> *rect)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rect != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        rect-&gt;x1 += widget-&gt;extent.x1;</span><br><span class="line">        rect-&gt;x2 += widget-&gt;extent.x1;</span><br><span class="line"></span><br><span class="line">        rect-&gt;y1 += widget-&gt;extent.y1;</span><br><span class="line">        rect-&gt;y2 += widget-&gt;extent.y1;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_rect_to_device);</span><br></pre></td></tr></tbody></table></figure><h4 id="矩形向下位移"><a href="#矩形向下位移" class="headerlink" title="矩形向下位移"></a>矩形向下位移</h4><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>點向上位移</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*widget</code></th><th><code>*rect</code></th></tr></thead><tbody><tr><td>目標 widget</td><td>目標矩形</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_rect_to_logic</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">rtgui_rect_t</span> *rect)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rect != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        rect-&gt;x1 -= widget-&gt;extent.x1;</span><br><span class="line">        rect-&gt;x2 -= widget-&gt;extent.x1;</span><br><span class="line"></span><br><span class="line">        rect-&gt;y1 -= widget-&gt;extent.y1;</span><br><span class="line">        rect-&gt;y2 -= widget-&gt;extent.y1;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_rect_to_logic);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="更新重疊區域"><a href="#更新重疊區域" class="headerlink" title="更新重疊區域"></a>更新重疊區域</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>更新重疊區域</td><td>void</td><td>目標 widget</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function updates the clip info of widget</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_update_clip</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rtgui_rect_t</span> rect;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_list_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* no widget or widget is hide, no update clip */</span></span><br><span class="line">    <span class="keyword">if</span> (widget == RT_NULL || RTGUI_WIDGET_IS_HIDE(widget) || widget-&gt;parent == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    parent = widget-&gt;parent;</span><br><span class="line">    <span class="comment">/* reset visiable extent */</span></span><br><span class="line">    widget-&gt;extent_visiable = widget-&gt;extent;</span><br><span class="line">    rtgui_rect_intersect(&amp;(parent-&gt;extent_visiable), &amp;(widget-&gt;extent_visiable));</span><br><span class="line"></span><br><span class="line">    rect = parent-&gt;extent_visiable;</span><br><span class="line">    <span class="comment">/* reset clip to extent */</span></span><br><span class="line">    rtgui_region_reset(&amp;(widget-&gt;clip), &amp;(widget-&gt;extent));</span><br><span class="line">    <span class="comment">/* limit widget extent in parent extent */</span></span><br><span class="line">    rtgui_region_intersect_rect(&amp;(widget-&gt;clip), &amp;(widget-&gt;clip), &amp;rect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get the no transparent parent */</span></span><br><span class="line">    <span class="keyword">while</span> (parent != RT_NULL &amp;&amp; parent-&gt;flag &amp; RTGUI_WIDGET_FLAG_TRANSPARENT)</span><br><span class="line">    {</span><br><span class="line">        parent = parent-&gt;parent;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (parent != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* give my clip back to parent */</span></span><br><span class="line">        rtgui_region_union(&amp;(parent-&gt;clip), &amp;(parent-&gt;clip), &amp;(widget-&gt;clip));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* subtract widget clip in parent clip */</span></span><br><span class="line">        <span class="keyword">if</span> (!(widget-&gt;flag &amp; RTGUI_WIDGET_FLAG_TRANSPARENT) &amp;&amp; RTGUI_IS_CONTAINER(parent))</span><br><span class="line">        {</span><br><span class="line">            rtgui_region_subtract_rect(&amp;(parent-&gt;clip), &amp;(parent-&gt;clip), &amp;(widget-&gt;extent_visiable));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * note: since the layout widget introduction, the sibling widget should not intersect.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if it's a container object, update the clip info of children */</span></span><br><span class="line">    <span class="keyword">if</span> (RTGUI_IS_CONTAINER(widget))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">rtgui_widget_t</span> *child;</span><br><span class="line">        rtgui_list_foreach(node, &amp;(RTGUI_CONTAINER(widget)-&gt;children))</span><br><span class="line">        {</span><br><span class="line">            child = rtgui_list_entry(node, <span class="keyword">rtgui_widget_t</span>, sibling);</span><br><span class="line"></span><br><span class="line">            rtgui_widget_update_clip(child);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_update_clip);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="顯示-widget"><a href="#顯示-widget" class="headerlink" title="顯示 widget"></a>顯示 widget</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>顯示 widget</td><td>void</td><td>目標 widget</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_show</span><span class="params">(struct rtgui_widget *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_show</span> <span class="title">eshow</span>;</span></span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RTGUI_WIDGET_IS_HIDE(widget))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    RTGUI_WIDGET_UNHIDE(widget);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;toplevel != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        RTGUI_EVENT_SHOW_INIT(&amp;eshow);</span><br><span class="line">        <span class="keyword">if</span> (RTGUI_OBJECT(widget)-&gt;event_handler != RT_NULL)</span><br><span class="line">        {</span><br><span class="line">            RTGUI_OBJECT(widget)-&gt;event_handler(</span><br><span class="line">                RTGUI_OBJECT(widget),</span><br><span class="line">                &amp;eshow);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_show);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="隱藏-widget"><a href="#隱藏-widget" class="headerlink" title="隱藏 widget"></a>隱藏 widget</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>隱藏 widget</td><td>void</td><td>目標 widget</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_hide</span><span class="params">(struct rtgui_widget *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_hide</span> <span class="title">ehide</span>;</span></span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (RTGUI_WIDGET_IS_HIDE(widget))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;toplevel != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        RTGUI_EVENT_HIDE_INIT(&amp;ehide);</span><br><span class="line">        <span class="keyword">if</span> (RTGUI_OBJECT(widget)-&gt;event_handler != RT_NULL)</span><br><span class="line">        {</span><br><span class="line">            RTGUI_OBJECT(widget)-&gt;event_handler(</span><br><span class="line">                RTGUI_OBJECT(widget),</span><br><span class="line">                &amp;ehide);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    RTGUI_WIDGET_HIDE(widget);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_hide);</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="取得-widget-資訊"><a href="#取得-widget-資訊" class="headerlink" title="取得 widget 資訊"></a>取得 widget 資訊</h2><p>最後整理一些取得 widget 資訊的 API</p><h3 id="Top-Level"><a href="#Top-Level" class="headerlink" title="Top Level"></a>Top Level</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>取得 top level</td><td>所在 window</td><td>目標 widget</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct rtgui_win *<span class="title">rtgui_widget_get_toplevel</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *r;</span><br><span class="line"></span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;toplevel)</span><br><span class="line">        <span class="keyword">return</span> widget-&gt;toplevel;</span><br><span class="line"></span><br><span class="line">    rt_kprintf(<span class="string">"widget-&gt;toplevel not properly set\n"</span>);</span><br><span class="line">    r = widget;</span><br><span class="line">    <span class="comment">/* get the toplevel widget */</span></span><br><span class="line">    <span class="keyword">while</span> (r-&gt;parent != RT_NULL)</span><br><span class="line">        r = r-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set toplevel */</span></span><br><span class="line">    widget-&gt;toplevel = RTGUI_WIN(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RTGUI_WIN(r);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_get_toplevel);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="上層前景"><a href="#上層前景" class="headerlink" title="上層前景"></a>上層前景</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>取得上層前景</td><td>顏色</td><td>目標 widget</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_color_t</span> rtgui_widget_get_parent_foreground(<span class="keyword">rtgui_widget_t</span> *widget)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get parent widget */</span></span><br><span class="line">    parent = widget-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (parent == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RTGUI_WIDGET_FOREGROUND(widget);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (parent-&gt;parent != RT_NULL &amp;&amp; (RTGUI_WIDGET_FLAG(parent) &amp; RTGUI_WIDGET_FLAG_TRANSPARENT))</span><br><span class="line">        parent = parent-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get parent's color */</span></span><br><span class="line">    <span class="keyword">return</span> RTGUI_WIDGET_FOREGROUND(parent);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_get_parent_foreground);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="上層背景"><a href="#上層背景" class="headerlink" title="上層背景"></a>上層背景</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>取得上層背景</td><td>顏色</td><td>目標 widget</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_color_t</span> rtgui_widget_get_parent_background(<span class="keyword">rtgui_widget_t</span> *widget)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get parent widget */</span></span><br><span class="line">    parent = widget-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (parent == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RTGUI_WIDGET_BACKGROUND(widget);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (parent-&gt;parent != RT_NULL &amp;&amp; (RTGUI_WIDGET_FLAG(parent) &amp; RTGUI_WIDGET_FLAG_TRANSPARENT))</span><br><span class="line">        parent = parent-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get parent's color */</span></span><br><span class="line">    <span class="keyword">return</span> RTGUI_WIDGET_BACKGROUND(parent);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_get_parent_background);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="下一個兄弟"><a href="#下一個兄弟" class="headerlink" title="下一個兄弟"></a>下一個兄弟</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>取得下一個兄弟</td><td>void</td><td>目標 widget</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_widget_t</span> *rtgui_widget_get_next_sibling(<span class="keyword">rtgui_widget_t</span> *widget)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *sibling = RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;sibling.next != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        sibling = rtgui_list_entry(widget-&gt;sibling.next, <span class="keyword">rtgui_widget_t</span>, sibling);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sibling;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_get_next_sibling);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="上一個兄弟"><a href="#上一個兄弟" class="headerlink" title="上一個兄弟"></a>上一個兄弟</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>取得上一個兄弟</td><td>void</td><td>目標 widget</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_widget_t</span> *rtgui_widget_get_prev_sibling(<span class="keyword">rtgui_widget_t</span> *widget)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_list_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *sibling, *parent;</span><br><span class="line"></span><br><span class="line">    node = RT_NULL;</span><br><span class="line">    sibling = RT_NULL;</span><br><span class="line">    parent = widget-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (parent != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        rtgui_list_foreach(node, &amp;(RTGUI_CONTAINER(parent)-&gt;children))</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next == &amp;(widget-&gt;sibling))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node != RT_NULL)</span><br><span class="line">        sibling = rtgui_list_entry(node, <span class="keyword">rtgui_widget_t</span>, sibling);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sibling;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;上一篇我們說明了 RTGUI 是如何透過 C 實現物件導向的設計邏輯，這篇將
      
    
    </summary>
    
    
      <category term="RT-Thread GUI" scheme="http://blog.lusw.dev/categories/RT-Thread-GUI/"/>
    
    
      <category term="kernel" scheme="http://blog.lusw.dev/tags/kernel/"/>
    
      <category term="RT-Thread" scheme="http://blog.lusw.dev/tags/RT-Thread/"/>
    
      <category term="GUI" scheme="http://blog.lusw.dev/tags/GUI/"/>
    
      <category term="widget" scheme="http://blog.lusw.dev/tags/widget/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread GUI Object</title>
    <link href="http://blog.lusw.dev/rtgui-object/"/>
    <id>http://blog.lusw.dev/rtgui-object/</id>
    <published>2019-01-01T07:08:37.000Z</published>
    <updated>2020-04-23T05:02:31.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="RT-Thread-GUI-物件架構"><a href="#RT-Thread-GUI-物件架構" class="headerlink" title="RT-Thread GUI 物件架構"></a>RT-Thread GUI 物件架構</h2><p>在 RTGUI 中，最小的物件為 widget，再來是 window，window 也是一個 widget；而每個 widget 也是一個 object，這是為了仿造 C++ 的物件導向所設計的，相同的概念我們在 RT-Thread 中已經看過許多次了，在 GUI engine 中也是相同的設計，其中在 object 結構中又串在 type 的結構上，type 中定義了兩個函式：<code>constructor</code> 與 <code>destructor</code>，在 C++ 的 class 中，常使用 <code>init</code> 函式來初始化新建的 class，這裡的 <code>constructor</code> 與 <code>destructor</code> 即用來初始化新建立的物件，及在刪除物件時，釋放該釋放的記憶體。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[RTGUI粗讲（个人见解篇之三、RTGUI WIDGET （2））](https://blog.csdn.net/xuzhenglim/article/details/11883351)">[1]</span></a></sup></p><hr><h2 id="結構"><a href="#結構" class="headerlink" title="結構"></a>結構</h2><div class="alert alert-success"><p><strong>File:</strong> rtgui_object.h</p></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rtgui base object */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_object</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* object type */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">rtgui_type_t</span> *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the event handler */</span></span><br><span class="line">    rtgui_event_handler_ptr event_handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> rtgui_object_flag flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> id;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rtgui type structure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_type</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* type name */</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parent type link */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_type</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* constructor and destructor */</span></span><br><span class="line">    <span class="keyword">rtgui_constructor_t</span> constructor;</span><br><span class="line">    <span class="keyword">rtgui_destructor_t</span> destructor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* size of type */</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="定義物件類型"><a href="#定義物件類型" class="headerlink" title="定義物件類型"></a>定義物件類型</h2><p>RTGUI 設計了一個巨集函數來定義不同的物件，如下：</p><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_CLASS_TYPE(type, name, parent, constructor, destructor, size) \</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_type</span> _<span class="title">rtgui_</span>##<span class="title">type</span> = {</span> \</span><br><span class="line">name, \</span><br><span class="line">parent, \</span><br><span class="line">RTGUI_CONSTRUCTOR(constructor), \</span><br><span class="line">RTGUI_DESTRUCTOR(destructor), \</span><br><span class="line">size }; \</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">rtgui_type_t</span> *_rtgui_#<span class="meta">#type##_get_type(void) { return &amp;_rtgui_##type; } \</span></span><br><span class="line">RTM_EXPORT(_rtgui_##type##_get_type)</span><br></pre></td></tr></tbody></table></figure><p><code>##</code> 為連字符，在<a href="/rt-thread-RTM-EXPORT">RT-Thread 理解 RTM_EXPORT</a>裡有提過了，基本上就是填入值進去結構體</p><hr><h2 id="建立物件"><a href="#建立物件" class="headerlink" title="建立物件"></a>建立物件</h2><div class="alert alert-success"><p><strong>File:</strong> rtgui_object.c</p></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*object_type</code></th></tr></thead><tbody><tr><td>建立物件</td><td>物件指標</td><td>要建立的物件種類</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Creates a new object: it calls the corresponding constructors</span></span><br><span class="line"><span class="comment"> * (from the constructor of the base class to the constructor of the more</span></span><br><span class="line"><span class="comment"> * derived class) and then sets the values of the given properties</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param object_type the type of object to create</span></span><br><span class="line"><span class="comment"> * @return the created object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rtgui_object_t</span> *rtgui_object_create(<span class="keyword">const</span> <span class="keyword">rtgui_type_t</span> *object_type)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rtgui_object_t</span> *new_object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!object_type)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line">    new_object = rtgui_malloc(object_type-&gt;size);</span><br><span class="line">    <span class="keyword">if</span> (new_object == RT_NULL) <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTGUI_OBJECT_TRACE</span></span><br><span class="line">    obj_info.objs_number ++;</span><br><span class="line">    obj_info.allocated_size += object_type-&gt;size;</span><br><span class="line">    <span class="keyword">if</span> (obj_info.allocated_size &gt; obj_info.max_allocated)</span><br><span class="line">        obj_info.max_allocated = obj_info.allocated_size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    new_object-&gt;type = object_type;</span><br><span class="line"></span><br><span class="line">    rtgui_type_object_construct(object_type, new_object);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_object;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_object_create);</span><br></pre></td></tr></tbody></table></figure><p>建立物件相當簡單，透過欲建立的物件類型所定意義的 <code>construct</code> 函數來建立，其中 <code>rtgui_type_object_construct</code> 會呼叫正確的建立函式來初始化資料。</p><hr><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>呼叫正確的 <code>construct</code> 函式來初始化物件</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*type</code></th><th><code>*object</code></th></tr></thead><tbody><tr><td>欲初始化的物件類型</td><td>物件本體</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_type_object_construct</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtgui_type_t</span> *type, <span class="keyword">rtgui_object_t</span> *object)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* construct from parent to children */</span></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;parent != RT_NULL)</span><br><span class="line">        rtgui_type_object_construct(type-&gt;parent, object);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;constructor)</span><br><span class="line">        type-&gt;constructor(object);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果欲建立的物件類型在某一個物件類型的底下，如 window 之於 widget，則先呼叫在上層的 <code>construct</code>；接著呼叫自己的 <code>construct</code> 來完成建立的動作。</p><hr><p>再仔細的看一下 “object” 的 <code>construct</code> 函式，其動作為：填入 vaild 的旗標，並將 id 填入 object 的記憶體指標；以上動作在 <code>_rtgui_object_constructor</code> 完成</p><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*object</code></th></tr></thead><tbody><tr><td>“object” 建立函式</td><td>void</td><td>要建立的物件</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _rtgui_object_constructor(<span class="keyword">rtgui_object_t</span> *object)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!object)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    object-&gt;flag = RTGUI_OBJECT_FLAG_VALID;</span><br><span class="line">    object-&gt;id   = (<span class="keyword">rt_uint32_t</span>)object;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="刪除物件"><a href="#刪除物件" class="headerlink" title="刪除物件"></a>刪除物件</h2><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*object</code></th></tr></thead><tbody><tr><td>刪除物件</td><td>void</td><td>要刪除的物件</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Destroys the object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The object destructors will be called in inherited type order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param object the object to destroy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_object_destroy</span><span class="params">(<span class="keyword">rtgui_object_t</span> *object)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!object || object-&gt;flag &amp; RTGUI_OBJECT_FLAG_STATIC)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTGUI_OBJECT_TRACE</span></span><br><span class="line">    obj_info.objs_number --;</span><br><span class="line">    obj_info.allocated_size -= object-&gt;type-&gt;size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call destructor */</span></span><br><span class="line">    RT_ASSERT(object-&gt;type != RT_NULL);</span><br><span class="line">    rtgui_type_destructors_call(object-&gt;type, object);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* release object */</span></span><br><span class="line">    rtgui_free(object);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_object_destroy);</span><br></pre></td></tr></tbody></table></figure><p>這裡一樣透過 <code>rtgui_type_destructors_call</code> 來呼叫正確的 <code>destruct</code> 函式，<code>destruct</code> 負責釋放該釋放的記憶體；最後透過 <code>rtgui_free</code> 釋放整個物件。<code>regui_free</code> 則簡單的呼叫 <code>rt_free</code> 釋放記憶體，我們在前幾篇文章有討論過了（<a href="/rt-mem#Code-free">mempool</a>、<a href="/rt-memheap#釋放記憶體">memheap</a>、<a href="/rt-small-mem#釋放記憶體">small mem</a>、<a href="/rt-slab#釋放記憶體">slab</a>）</p><hr><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>呼叫正確的 <code>destructor</code> 函式來清除物件</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*type</code></th><th><code>*object</code></th></tr></thead><tbody><tr><td>欲清除的物件類型</td><td>物件本體</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_type_destructors_call</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtgui_type_t</span> *type, <span class="keyword">rtgui_object_t</span> *object)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* destruct from children to parent */</span></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;destructor)</span><br><span class="line">        type-&gt;destructor(object);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;parent)</span><br><span class="line">        rtgui_type_destructors_call(type-&gt;parent, object);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同樣的如果此物件類型是在某個物件類型的底下，先呼叫上層的 <code>destruct</code>；接著呼叫自己的 <code>desturct</code> 完成清除的動作。</p><hr><p>最後來看一下 “object” 的刪除函式：填入 none 的旗標，並將物件種類設為 NULL；動作在 <code>_rtgui_object_destructor</code> 完成</p><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*object</code></th></tr></thead><tbody><tr><td>“object” 的刪除函式</td><td>void</td><td>欲清除的物件</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Destroys the object */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _rtgui_object_destructor(<span class="keyword">rtgui_object_t</span> *object)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* Any valid objest should both have valid flag _and_ valid type. Only use</span></span><br><span class="line"><span class="comment">     * flag is not enough because the chunk of memory may be reallocted to other</span></span><br><span class="line"><span class="comment">     * object and thus the flag will become valid. */</span></span><br><span class="line">    object-&gt;flag = RTGUI_OBJECT_FLAG_NONE;</span><br><span class="line">    object-&gt;type = RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div id="footnotes"><hr class="clearfix"><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://blog.csdn.net/xuzhenglim/article/details/11883351" target="_blank" rel="noopener">RTGUI粗讲（个人见解篇之三、RTGUI WIDGET （2））</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;RT-Thread-GUI-物件架構&quot;&gt;&lt;a href=&quot;#RT-
      
    
    </summary>
    
    
      <category term="RT-Thread GUI" scheme="http://blog.lusw.dev/categories/RT-Thread-GUI/"/>
    
    
      <category term="kernel" scheme="http://blog.lusw.dev/tags/kernel/"/>
    
      <category term="RT-Thread" scheme="http://blog.lusw.dev/tags/RT-Thread/"/>
    
      <category term="GUI" scheme="http://blog.lusw.dev/tags/GUI/"/>
    
      <category term="OOP" scheme="http://blog.lusw.dev/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>使用 crontab 自動備份網站原始碼</title>
    <link href="http://blog.lusw.dev/auto-backup-with-crontab/"/>
    <id>http://blog.lusw.dev/auto-backup-with-crontab/</id>
    <published>2018-12-26T04:14:07.000Z</published>
    <updated>2020-04-22T08:51:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="shell-script"><a href="#shell-script" class="headerlink" title="shell script"></a>shell script</h2><p>透過 git 備份時，一定是使用下列指令</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">'log'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push</span></span><br></pre></td></tr></tbody></table></figure><p>而使用 shell script 可以讓我們一次執行一大串指令，因此我們來寫一個 shell script</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/zsh</span></span><br><span class="line">nowTime="$(date +'%Y-%m-%d %H:%M:%S')"</span><br><span class="line">echo "# Using crontab with auto.sh"</span><br><span class="line">echo "# File in ~/Desktop/auto.sh"</span><br><span class="line">echo "# Log  in ~/Desktop/cront.log"</span><br><span class="line">echo "#"</span><br><span class="line">echo "# Auto backup at ${nowTime}"</span><br><span class="line">echo "# --------------------------------------------------\n"</span><br><span class="line"></span><br><span class="line">cd /Users/username</span><br><span class="line">cd $1</span><br><span class="line">echo "Now at $(pwd)\n"</span><br><span class="line"></span><br><span class="line">log="auto backup at "${nowTime}</span><br><span class="line">git add .</span><br><span class="line">git commit -m "$log"</span><br><span class="line">result=$(git push site hexo_source_new 2&gt;&amp;1)</span><br><span class="line"></span><br><span class="line">case $result in</span><br><span class="line">    "Everything up-to-date")</span><br><span class="line">        osascript -e 'display notification "Everything up-to-date." with title "Automatically backup" sound name "basso"'</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        osascript -e 'display notification "Done!" with title "Automatically backup" sound name "hero"'</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br><span class="line">echo ${result}</span><br><span class="line">echo "Backup complete."</span><br></pre></td></tr></tbody></table></figure><p>其中我們為了方便整理，在提交的紀錄上增加了時間；並且在 push 完根據結果有不同的通知</p><div class="alert alert-danger"><p>此通知是基於 mac 上的 applescript 所寫的，在 linux 上會產生錯誤</p></div><h2 id="建立-crontab"><a href="#建立-crontab" class="headerlink" title="建立 crontab"></a>建立 crontab</h2><p>寫好 script shell 後，再來就是要定時的執行它。使用 crontab 可以在指定的時間，或是固定的區間內執行。</p><p>使用方式，輸入指令 <code>crontab -e</code>，接著會跳進 vim，寫入</p><figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line">@hourly chmod +<span class="keyword">x</span> /Users/PATH_TO_YOUR.<span class="keyword">sh</span></span><br><span class="line">@hourly /Users/PATH_TO_YOUR.<span class="keyword">sh</span> PATH_TO_YOUR_SOURCE &gt;&gt; /Users/PATH_TO_YOUR.<span class="built_in">log</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>這裡首先提升一次權限，並設定每一次整點都備份一次 <code>@hourly</code>，並將結果寫入 log 中。我們需要先建立一個 .log 檔：</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch /Users/PATH_TO_YOUR.log</span></span><br></pre></td></tr></tbody></table></figure><p>當然這裡的所有路徑因人而異，檔名也無所謂，最後 <code>:wq</code> 存檔退出，安裝完畢</p><p><img src="https://i.imgur.com/w3qGjus.png" alt="" title="大功告成"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;shell-script&quot;&gt;&lt;a href=&quot;#shell-scr
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.lusw.dev/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.lusw.dev/tags/Linux/"/>
    
      <category term="crontab" scheme="http://blog.lusw.dev/tags/crontab/"/>
    
  </entry>
  
  <entry>
    <title>自訂網域名稱：Google Domain</title>
    <link href="http://blog.lusw.dev/custom-domain-by-google-domain/"/>
    <id>http://blog.lusw.dev/custom-domain-by-google-domain/</id>
    <published>2018-12-13T03:17:28.000Z</published>
    <updated>2020-04-22T08:55:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="購買網域"><a href="#購買網域" class="headerlink" title="購買網域"></a>購買網域</h2><p>網路上已經有很多如何在 <a href="https://domains.google.com/m/registrar/omuskywalker.com?hl=en#" target="_blank" rel="noopener">Google Domain</a> 上買網域的文章了，在此就不特別贅述，放上我看的幾篇文章：</p><ul><li><a href="https://free.com.tw/google-domains/" target="_blank" rel="noopener">台灣用戶也能在 Google Domains 註冊購買網域名稱，詳細申請設定教學</a></li><li><a href="https://sofree.cc/google-domains/" target="_blank" rel="noopener">[教學]如何用 Google Domains 買網址、註冊網域？ - 香腸炒魷魚</a></li></ul><div class="alert alert-default"><p>比較特別的的地方是，現在只開放部分國家可使用，所以在填地址的時候，可以去 google map 搜尋隨便一個美國的地址，然後使用</p></div><h2 id="設定-DNS"><a href="#設定-DNS" class="headerlink" title="設定 DNS"></a>設定 DNS</h2><p>根據 Github 官方的說明，需設定 type <code>A</code> 的 IP 位址為</p><ul><li>185.199.108.153</li><li>185.199.109.153</li><li>185.199.110.153</li><li>185.199.111.153</li></ul><p>以及一個 CNAME，name 可以填任意字串，此字串就是你的 subdomain（像是我填 blog），如果不知道填什麼，可以填 www。最後你的畫面會長這樣：<br><img src="https://i.imgur.com/OTJsgaX.png" alt=""><br>CNAME 的 data 請填 <code>你的 github ID</code>+<code>.github.io.</code>，注意最後有一個點</p><p>這些都設定完，之後你的網址就會變成 <code>subdomain.domain.com</code></p><div class="alert alert-warning"><p>一個很重要的事情是，發布 hexo 的 github repo 須為 <strong>github.io</strong> 類型的，否則設定會有誤</p></div><h2 id="設定-github-CNAME"><a href="#設定-github-CNAME" class="headerlink" title="設定 github CNAME"></a>設定 github CNAME</h2><p>Github 官方有提供 301 轉址功能，只要在網頁的 branch 下建立一個 <code>CNAME</code> 檔案，就會把舊網址轉址到新網址。你的 CNAME 應該要填以下內容：</p><figure class="highlight stylus"><table><tbody><tr><td class="code"><pre><span class="line">subdomain<span class="selector-class">.domain</span><span class="selector-class">.com</span></span><br></pre></td></tr></tbody></table></figure><p>其中 <code>subdomain</code> 與 <code>domain</code> 與自己的有關，像我的就是</p><figure class="highlight stylus"><table><tbody><tr><td class="code"><pre><span class="line">blog<span class="selector-class">.omuskywalker</span><span class="selector-class">.com</span></span><br></pre></td></tr></tbody></table></figure><p>如果你上面的 subdomain 設定為 www，而你的頂級網域（也就是你買的 domain 名字）沒有要給特別的網站用的話，也可以這樣寫：</p><figure class="highlight stylus"><table><tbody><tr><td class="code"><pre><span class="line">domain.com</span><br><span class="line">subdomain<span class="selector-class">.domain</span><span class="selector-class">.com</span></span><br></pre></td></tr></tbody></table></figure><p>這麼一來不管是上面哪兩種，都會連到你的 blog</p><div class="alert alert-info"><p>如果跟我一樣是用 hexo 的人，CNAME 請放在 /source 底下，這樣每次 <code>hexo d</code> 才不會被蓋掉</p></div><p>如果這些都有設定好，你的 github 應該會長這樣：<br><img src="https://i.imgur.com/e5GzzZH.png" alt=""></p><p>大概過幾個小時，你的新網址就可以用了（大功告成）!</p><h2 id="補充：HTTPS"><a href="#補充：HTTPS" class="headerlink" title="補充：HTTPS"></a>補充：HTTPS</h2><p>Github page 有提供內建的 HTTPS，只要你的網站設定好一陣子（不會很久，一天內），會有這個選項可以按：<br><img src="https://i.imgur.com/z9HdVbV.png" alt=""><br>按下去，就會獲得 HTTPS 了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;購買網域&quot;&gt;&lt;a href=&quot;#購買網域&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Note" scheme="http://blog.lusw.dev/categories/Note/"/>
    
    
      <category term="hexo" scheme="http://blog.lusw.dev/tags/hexo/"/>
    
      <category term="github-page" scheme="http://blog.lusw.dev/tags/github-page/"/>
    
      <category term="CNAME" scheme="http://blog.lusw.dev/tags/CNAME/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread SLAB 動態管理</title>
    <link href="http://blog.lusw.dev/rt-slab/"/>
    <id>http://blog.lusw.dev/rt-slab/</id>
    <published>2018-12-05T07:42:50.000Z</published>
    <updated>2020-04-23T05:02:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>使用此管理方式： <code>#defined RT_USING_HEAP &amp;&amp; #defined RT_USING_SLAB</code></p></blockquote><p>SLAB 將記憶體根據不同的對象切成不同的區 (zone)，對象通常是大小，也可看成是一個 zone 代表一個 pool，不同的 zone 放在一個 array 管理。</p><p>一個 zone 大小介於 32kB~128kB 之間，最多可以有 72 種 zone；zone 對象大小上上限 16kB，超過由頁分配器分配</p><ul><li>alloc：根據需要的大小，找到對應的 zone 取得記憶體；如假設需要 32kB，我們去尋找對象為 32kB 的 zone。<ul><li>若是該 zone 為空（找不到），直接向頁分配器分配一個新的 zone，取得第一塊 free chunk</li><li>若非空，直接取得第一塊，如果拿完該 zone 已經沒有 free chunk 頁分配器須將此 zone 刪除</li></ul></li><li>free：找到對應的 zone 插入至 free list，如果該 zone 的所有 free chunk 都已經釋放完畢，則須將此 zone 整個釋放到分配器裡</li></ul><p><img src="https://i.imgur.com/GZdBl7V.png" alt="" title="SLAB example"></p><hr><h2 id="結構"><a href="#結構" class="headerlink" title="結構"></a>結構</h2><div class="alert alert-success"><p><strong>File:</strong> slab.c</p></div><h3 id="Zone"><a href="#Zone" class="headerlink" title="Zone"></a>Zone</h3><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The IN-BAND zone header is placed at the beginning of each zone.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slab_zone</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span>  z_magic;        <span class="comment">/* magic number for sanity check */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span>  z_nfree;        <span class="comment">/* total free chunks / ualloc space in zone */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span>  z_nmax;         <span class="comment">/* maximum free chunks */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">slab_zone</span> *<span class="title">z_next</span>;</span>   <span class="comment">/* zoneary[] link if z_nfree non-zero */</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span>  *z_baseptr;     <span class="comment">/* pointer to start of chunk array */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span>  z_uindex;       <span class="comment">/* current initial allocation index */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span>  z_chunksize;    <span class="comment">/* chunk size for validation */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span>  z_zoneindex;    <span class="comment">/* zone index */</span></span><br><span class="line">    slab_chunk  *z_freechunk;   <span class="comment">/* free chunk list */</span></span><br><span class="line">} slab_zone;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Chunk structure for free elements</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slab_chunk</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">slab_chunk</span> *<span class="title">c_next</span>;</span></span><br><span class="line">} slab_chunk;</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Page-Allocator"><a href="#Page-Allocator" class="headerlink" title="Page Allocator"></a>Page Allocator</h3><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* page allocator */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> *<span class="title">next</span>;</span>      <span class="comment">/* next valid page */</span></span><br><span class="line">    <span class="keyword">rt_size_t</span> page;                 <span class="comment">/* number of page  */</span></span><br><span class="line">    <span class="comment">/* dummy */</span></span><br><span class="line">    <span class="keyword">char</span> dummy[RT_MM_PAGE_SIZE - (<span class="keyword">sizeof</span>(struct rt_page_head *) + <span class="keyword">sizeof</span>(<span class="keyword">rt_size_t</span>))];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Descriptor"><a href="#Descriptor" class="headerlink" title="Descriptor"></a>Descriptor</h3><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Array of descriptors that describe the contents of each page</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_TYPE_FREE      0x00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_TYPE_SMALL     0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_TYPE_LARGE     0x02</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memusage</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> type: <span class="number">2</span> ;       <span class="comment">/* page type */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> size: <span class="number">30</span>;       <span class="comment">/* pages allocated or offset from zone */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="初始化-heap"><a href="#初始化-heap" class="headerlink" title="初始化 heap"></a>初始化 heap</h2><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 heap</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*begin_addr</code></th><th><code>*end_addr</code></th></tr></thead><tbody><tr><td>記憶體起始位址</td><td>結束位址</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ingroup SystemInit</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function will init system heap</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param begin_addr the beginning address of system page</span></span><br><span class="line"><span class="comment"> * @param end_addr the end address of system page</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_system_heap_init</span><span class="params">(<span class="keyword">void</span> *begin_addr, <span class="keyword">void</span> *end_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> limsize, npages;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* align begin and end addr to page */</span></span><br><span class="line">    heap_start = RT_ALIGN((<span class="keyword">rt_uint32_t</span>)begin_addr, RT_MM_PAGE_SIZE);</span><br><span class="line">    heap_end   = RT_ALIGN_DOWN((<span class="keyword">rt_uint32_t</span>)end_addr, RT_MM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heap_start &gt;= heap_end)</span><br><span class="line">    {</span><br><span class="line">        rt_kprintf(<span class="string">"rt_system_heap_init, wrong address[0x%x - 0x%x]\n"</span>,</span><br><span class="line">                   (<span class="keyword">rt_uint32_t</span>)begin_addr, (<span class="keyword">rt_uint32_t</span>)end_addr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>向上對齊起始位址，向下對其結束位址</li><li>檢查是否合法</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><span class="line">limsize = heap_end - heap_start;</span><br><span class="line">npages  = limsize / RT_MM_PAGE_SIZE;</span><br></pre></td></tr></tbody></table></figure><ul><li>計算最大的 size，設定頁數量</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* initialize heap semaphore */</span></span><br><span class="line">rt_sem_init(&amp;heap_sem, <span class="string">"heap"</span>, <span class="number">1</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line"></span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"heap[0x%x - 0x%x], size 0x%x, 0x%x pages\n"</span>,</span><br><span class="line">                             heap_start, heap_end, limsize, npages));</span><br></pre></td></tr></tbody></table></figure><ul><li>初始化 semaphore，值為 1</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">369</span><br><span class="line">370</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* init pages */</span></span><br><span class="line">rt_page_init((<span class="keyword">void</span> *)heap_start, npages);</span><br></pre></td></tr></tbody></table></figure><ul><li>初始化 page</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* calculate zone size */</span></span><br><span class="line">zone_size = ZALLOC_MIN_ZONE_SIZE;</span><br><span class="line"><span class="keyword">while</span> (zone_size &lt; ZALLOC_MAX_ZONE_SIZE &amp;&amp; (zone_size &lt;&lt; <span class="number">1</span>) &lt; (limsize / <span class="number">1024</span>))</span><br><span class="line">    zone_size &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">zone_limit = zone_size / <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (zone_limit &gt; ZALLOC_ZONE_LIMIT)</span><br><span class="line">    zone_limit = ZALLOC_ZONE_LIMIT;</span><br><span class="line"></span><br><span class="line">zone_page_cnt = zone_size / RT_MM_PAGE_SIZE;</span><br></pre></td></tr></tbody></table></figure><ul><li>計算 zone 的大小、對象大小的上限及總頁數</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br></pre></td><td class="code"><pre><span class="line">    RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"zone size 0x%x, zone page count 0x%x\n"</span>,</span><br><span class="line">                                 zone_size, zone_page_cnt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate memusage array */</span></span><br><span class="line">    limsize  = npages * <span class="keyword">sizeof</span>(struct memusage);</span><br><span class="line">    limsize  = RT_ALIGN(limsize, RT_MM_PAGE_SIZE);</span><br><span class="line">    memusage = rt_page_alloc(limsize / RT_MM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"memusage 0x%x, size 0x%x\n"</span>,</span><br><span class="line">                                 (<span class="keyword">rt_uint32_t</span>)memusage, limsize));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最後建立一個陣列紀錄頁的資訊</li></ul><hr><h3 id="rt-page-init"><a href="#rt-page-init" class="headerlink" title="rt_page_init"></a>rt_page_init</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化頁分配器</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*addr</code></th><th><code>npages</code></th></tr></thead><tbody><tr><td>存放頁的記憶體位址</td><td>頁的總數</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initialize the page allocator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rt_page_init</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">rt_size_t</span> npages)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(addr != RT_NULL);</span><br><span class="line">    RT_ASSERT(npages != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    rt_page_list = RT_NULL;</span><br><span class="line">    rt_page_free(addr, npages);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>將 page list 設為空，釋放所有的 page</li></ul><hr><h2 id="分配記憶體"><a href="#分配記憶體" class="headerlink" title="分配記憶體"></a>分配記憶體</h2><h3 id="rt-malloc"><a href="#rt-malloc" class="headerlink" title="rt_malloc"></a>rt_malloc</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>size</code></th></tr></thead><tbody><tr><td>要求記憶體</td><td>記憶體位址</td><td>欲要求的大小</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will allocate a block from system heap memory.</span></span><br><span class="line"><span class="comment"> * - If the nbytes is less than zero,</span></span><br><span class="line"><span class="comment"> * or</span></span><br><span class="line"><span class="comment"> * - If there is no nbytes sized memory valid in system,</span></span><br><span class="line"><span class="comment"> * the RT_NULL is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param size the size of memory to be allocated</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the allocated memory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_malloc</span><span class="params">(<span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    slab_zone *z;</span><br><span class="line">    <span class="keyword">rt_int32_t</span> zi;</span><br><span class="line">    slab_chunk *chunk;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">memusage</span> *<span class="title">kup</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zero size, return RT_NULL */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 size = 0，回傳 NULL</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Handle large allocations directly.  There should not be very many of</span></span><br><span class="line"><span class="comment"> * these so performance is not a big issue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (size &gt;= zone_limit)</span><br><span class="line">{</span><br><span class="line">    size = RT_ALIGN(size, RT_MM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    chunk = rt_page_alloc(size &gt;&gt; RT_MM_PAGE_BITS);</span><br><span class="line">    <span class="keyword">if</span> (chunk == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 size 超過一個 chunk 的上限，則透過頁分配器來分配</li><li>且如果失敗了，直接回傳 <code>NULL</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set kup */</span></span><br><span class="line">kup = btokup(chunk);</span><br><span class="line">kup-&gt;type = PAGE_TYPE_LARGE;</span><br><span class="line">kup-&gt;size = size &gt;&gt; RT_MM_PAGE_BITS;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定頁的資訊：<ul><li>type：<code>PAGE_TYPE_LARGE</code></li><li>size：用了幾頁</li></ul></li><li>btokup：<code>&amp;memusage[((rt_uint32_t)(addr) - heap_start) &gt;&gt; RT_MM_PAGE_BITS]</code><ul><li>找到陣列中與起始位置的差值，位移 12-bit，即除一頁的大小</li></ul></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br></pre></td><td class="code"><pre><span class="line">        RT_DEBUG_LOG(RT_DEBUG_SLAB,</span><br><span class="line">                     (<span class="string">"malloc a large memory 0x%x, page cnt %d, kup %d\n"</span>,</span><br><span class="line">                      size,</span><br><span class="line">                      size &gt;&gt; RT_MM_PAGE_BITS,</span><br><span class="line">                      ((<span class="keyword">rt_uint32_t</span>)chunk - heap_start) &gt;&gt; RT_MM_PAGE_BITS));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* lock heap */</span></span><br><span class="line">        rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem += size;</span><br><span class="line">        <span class="keyword">if</span> (used_mem &gt; max_mem)</span><br><span class="line">            max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>要鎖，更新使用大小，跳到 <code>__done</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lock heap */</span></span><br><span class="line">rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to allocate out of an existing zone.  First try the free list,</span></span><br><span class="line"><span class="comment"> * then allocate out of unallocated space.  If we find a good zone move</span></span><br><span class="line"><span class="comment"> * it to the head of the list so later allocations find it quickly</span></span><br><span class="line"><span class="comment"> * (we might have thousands of zones in the list).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: zoneindex() will panic of size is too large.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">zi = zoneindex(&amp;size);</span><br><span class="line">RT_ASSERT(zi &lt; NZONES);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 size 小於一個 chunk 的上限，尋找此大小對應的 zone</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"try to malloc 0x%x on zone: %d\n"</span>, size, zi));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((z = zone_array[zi]) != RT_NULL)</span><br><span class="line">{</span><br><span class="line">    RT_ASSERT(z-&gt;z_nfree &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove us from the zone_array[] when we become empty */</span></span><br><span class="line">    <span class="keyword">if</span> (--z-&gt;z_nfree == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        zone_array[zi] = z-&gt;z_next;</span><br><span class="line">        z-&gt;z_next = RT_NULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果該 zone 不為空，且此 zone 剩最後一顆可用時，將此 zone 刪除</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * No chunks are available but nfree said we had some memory, so</span></span><br><span class="line"><span class="comment">         * it must be available in the never-before-used-memory area</span></span><br><span class="line"><span class="comment">         * governed by uindex.  The consequences are very serious if our zone</span></span><br><span class="line"><span class="comment">         * got corrupted so we use an explicit rt_kprintf rather then a KASSERT.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (z-&gt;z_uindex + <span class="number">1</span> != z-&gt;z_nmax)</span><br><span class="line">        {</span><br><span class="line">            z-&gt;z_uindex = z-&gt;z_uindex + <span class="number">1</span>;</span><br><span class="line">            chunk = (slab_chunk *)(z-&gt;z_baseptr + z-&gt;z_uindex * size);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* find on free chunk list */</span></span><br><span class="line">            chunk = z-&gt;z_freechunk;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* remove this chunk from list */</span></span><br><span class="line">            z-&gt;z_freechunk = z-&gt;z_freechunk-&gt;c_next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem += z-&gt;z_chunksize;</span><br><span class="line">        <span class="keyword">if</span> (used_mem &gt; max_mem)</span><br><span class="line">            max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>取得一塊，跳至 done<ul><li>從 <code>uindex</code> 找，這種方式取得的屬於此 zone 最初的 chunk</li><li>如果不行，從 free list 中取得，並從 free list 移除此 chunk；這種的 chunk 是已經被要過，又還回來的</li></ul></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If all zones are exhausted we need to allocate a new zone for this</span></span><br><span class="line"><span class="comment"> * index.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * At least one subsystem, the tty code (see CROUND) expects power-of-2</span></span><br><span class="line"><span class="comment"> * allocations to be power-of-2 aligned.  We maintain compatibility by</span></span><br><span class="line"><span class="comment"> * adjusting the base offset below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_int32_t</span> off;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z = zone_free) != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* remove zone from free zone list */</span></span><br><span class="line">        zone_free = z-&gt;z_next;</span><br><span class="line">        -- zone_free_cnt;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果找到的 zone 為空，且 <code>zone_free</code> 不為空：代表有可用的空 zone 可以使用</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* unlock heap, since page allocator will think about lock */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate a zone from page */</span></span><br><span class="line">    z = rt_page_alloc(zone_size / RT_MM_PAGE_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (z == RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        chunk = RT_NULL;</span><br><span class="line">        <span class="keyword">goto</span> __exit;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>否則需要重新與頁分配器要一個 zone</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* lock heap */</span></span><br><span class="line">    rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"alloc a new zone: 0x%x\n"</span>,</span><br><span class="line">                                 (<span class="keyword">rt_uint32_t</span>)z));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set message usage */</span></span><br><span class="line">    <span class="keyword">for</span> (off = <span class="number">0</span>, kup = btokup(z); off &lt; zone_page_cnt; off ++)</span><br><span class="line">    {</span><br><span class="line">        kup-&gt;type = PAGE_TYPE_SMALL;</span><br><span class="line">        kup-&gt;size = off;</span><br><span class="line"></span><br><span class="line">        kup ++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著設定每一頁的資訊</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">616</span><br><span class="line">617</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* clear to zero */</span></span><br><span class="line">rt_memset(z, <span class="number">0</span>, <span class="keyword">sizeof</span>(slab_zone));</span><br></pre></td></tr></tbody></table></figure><ul><li>清空整個 zone</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* offset of slab zone struct in zone */</span></span><br><span class="line">off = <span class="keyword">sizeof</span>(slab_zone);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Guarentee power-of-2 alignment for power-of-2-sized chunks.</span></span><br><span class="line"><span class="comment"> * Otherwise just 8-byte align the data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((size | (size - <span class="number">1</span>)) + <span class="number">1</span> == (size &lt;&lt; <span class="number">1</span>))</span><br><span class="line">    off = (off + size - <span class="number">1</span>) &amp; ~(size - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    off = (off + MIN_CHUNK_MASK) &amp; ~MIN_CHUNK_MASK;</span><br></pre></td></tr></tbody></table></figure><ul><li>計算我們要用的對齊法：<ul><li>如果 size 是二的次方，將 off (zone 的頭) 與 size 向上對齊</li><li>否則直接與 8 向上對齊</li></ul></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br></pre></td><td class="code"><pre><span class="line">z-&gt;z_magic     = ZALLOC_SLAB_MAGIC;</span><br><span class="line">z-&gt;z_zoneindex = zi;</span><br><span class="line">z-&gt;z_nmax      = (zone_size - off) / size;</span><br><span class="line">z-&gt;z_nfree     = z-&gt;z_nmax - <span class="number">1</span>;</span><br><span class="line">z-&gt;z_baseptr   = (<span class="keyword">rt_uint8_t</span> *)z + off;</span><br><span class="line">z-&gt;z_uindex    = <span class="number">0</span>;</span><br><span class="line">z-&gt;z_chunksize = size;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定 magic、對應 <code>zone_array</code> 的 index<ul><li>最大數量為 <code>zone_size</code> - off 再除以一個 chunk 的大小</li><li>目前可用的數量則為最大數量減 1，因為待會會拿走一塊</li><li>基址為起始位址加上 <code>off，uindex</code> 為 0，這是之後 alloc 時可直接使用這兩個來找到 free chunk</li><li>最後設定 chunk size</li></ul></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br></pre></td><td class="code"><pre><span class="line">        chunk = (slab_chunk *)(z-&gt;z_baseptr + z-&gt;z_uindex * size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* link to zone array */</span></span><br><span class="line">        z-&gt;z_next = zone_array[zi];</span><br><span class="line">        zone_array[zi] = z;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem += z-&gt;z_chunksize;</span><br><span class="line">        <span class="keyword">if</span> (used_mem &gt; max_mem)</span><br><span class="line">            max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>拿走第一塊，並將這個 zone 插上對應的 zone array entry</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br></pre></td><td class="code"><pre><span class="line">done:</span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_malloc_hook, ((<span class="keyword">char</span> *)chunk, size));</span><br><span class="line"></span><br><span class="line">__exit:</span><br><span class="line">    <span class="keyword">return</span> chunk;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_malloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後回傳找到的 chunk</li></ul><hr><h4 id="zoneindex"><a href="#zoneindex" class="headerlink" title="zoneindex"></a>zoneindex</h4><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*bytes</code></th></tr></thead><tbody><tr><td>尋找傳入的 size 對應 zone array 的 index</td><td>index</td><td>傳入的大小</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Calculate the zone index for the allocation request size and set the</span></span><br><span class="line"><span class="comment"> * allocation request size to that particular zone's chunk size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">rt_inline <span class="keyword">int</span> <span class="title">zoneindex</span><span class="params">(<span class="keyword">rt_uint32_t</span> *bytes)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* unsigned for shift opt */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> n = (<span class="keyword">rt_uint32_t</span>) * bytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">128</span>)</span><br><span class="line">    {</span><br><span class="line">        *bytes = n = (n + <span class="number">7</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 8 byte chunks, 16 zones */</span></span><br><span class="line">        <span class="keyword">return</span> (n / <span class="number">8</span> - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">256</span>)</span><br><span class="line">    {</span><br><span class="line">        *bytes = n = (n + <span class="number">15</span>) &amp; ~<span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (n / <span class="number">16</span> + <span class="number">7</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">8192</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">512</span>)</span><br><span class="line">        {</span><br><span class="line">            *bytes = n = (n + <span class="number">31</span>) &amp; ~<span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (n / <span class="number">32</span> + <span class="number">15</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1024</span>)</span><br><span class="line">        {</span><br><span class="line">            *bytes = n = (n + <span class="number">63</span>) &amp; ~<span class="number">63</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (n / <span class="number">64</span> + <span class="number">23</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2048</span>)</span><br><span class="line">        {</span><br><span class="line">            *bytes = n = (n + <span class="number">127</span>) &amp; ~<span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (n / <span class="number">128</span> + <span class="number">31</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4096</span>)</span><br><span class="line">        {</span><br><span class="line">            *bytes = n = (n + <span class="number">255</span>) &amp; ~<span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (n / <span class="number">256</span> + <span class="number">39</span>);</span><br><span class="line">        }</span><br><span class="line">        *bytes = n = (n + <span class="number">511</span>) &amp; ~<span class="number">511</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (n / <span class="number">512</span> + <span class="number">47</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">16384</span>)</span><br><span class="line">    {</span><br><span class="line">        *bytes = n = (n + <span class="number">1023</span>) &amp; ~<span class="number">1023</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (n / <span class="number">1024</span> + <span class="number">55</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    rt_kprintf(<span class="string">"Unexpected byte count %d"</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>根據不同的 range，將傳入的大小對齊，並平均分配每個 range 有 16 個 zone index</p><hr><h4 id="rt-page-alloc"><a href="#rt-page-alloc" class="headerlink" title="rt_page_alloc"></a>rt_page_alloc</h4><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>npages</code></th></tr></thead><tbody><tr><td>要求頁記憶體</td><td>頁</td><td>欲要求的頁數</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_page_alloc</span><span class="params">(<span class="keyword">rt_size_t</span> npages)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> *<span class="title">b</span>, *<span class="title">n</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> **<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (npages == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lock heap */</span></span><br><span class="line">    rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line">    <span class="keyword">for</span> (prev = &amp;rt_page_list; (b = *prev) != RT_NULL; prev = &amp;(b-&gt;next))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (b-&gt;page &gt; npages)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* splite pages */</span></span><br><span class="line">            n       = b + npages;</span><br><span class="line">            n-&gt;next = b-&gt;next;</span><br><span class="line">            n-&gt;page = b-&gt;page - npages;</span><br><span class="line">            *prev   = n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果找到一個頁數大於需求的，選擇此頁，並分割</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (b-&gt;page == npages)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* this node fit, remove this node */</span></span><br><span class="line">            *prev = b-&gt;next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlock heap */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果有一個剛剛好，選擇此頁</li><li>最後回傳選擇的頁</li></ul><hr><h3 id="rt-realloc"><a href="#rt-realloc" class="headerlink" title="rt_realloc"></a>rt_realloc</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>增長/縮減記憶體</td><td>記憶體位址</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*rmem</code></th><th><code>newsize</code></th></tr></thead><tbody><tr><td>欲增長/縮減的記憶體位址</td><td>新的大小</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will change the size of previously allocated memory block.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param ptr the previously allocated memory block</span></span><br><span class="line"><span class="comment"> * @param size the new size of memory block</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the allocated memory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *nptr;</span><br><span class="line">    slab_zone *z;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">memusage</span> *<span class="title">kup</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> rt_malloc(size);</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_free(ptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果傳入的 <code>ptr</code> 為空，<code>malloc(size)</code></li><li>如果傳入的 <code>size</code> 為 0，<code>free(ptr)</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the original allocation's zone.  If the new request winds up</span></span><br><span class="line"><span class="comment"> * using the same chunk size we do not have to do anything.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">kup = btokup((<span class="keyword">rt_uint32_t</span>)ptr &amp; ~RT_MM_PAGE_MASK);</span><br><span class="line"><span class="keyword">if</span> (kup-&gt;type == PAGE_TYPE_LARGE)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_size_t</span> osize;</span><br><span class="line"></span><br><span class="line">    osize = kup-&gt;size &lt;&lt; RT_MM_PAGE_BITS;</span><br><span class="line">    <span class="keyword">if</span> ((nptr = rt_malloc(size)) == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    rt_memcpy(nptr, ptr, size &gt; osize ? osize : size);</span><br><span class="line">    rt_free(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nptr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著檢查此 <code>ptr</code> 所在的頁資訊，如果是 LARGE，代表原來的 <code>ptr</code> 是由頁分配器所分配的</li><li>新 <code>malloc(size)</code>，並還原資料，釋放舊的記憶體</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (kup-&gt;type == PAGE_TYPE_SMALL)</span><br><span class="line">{</span><br><span class="line">    z = (slab_zone *)(((<span class="keyword">rt_uint32_t</span>)ptr &amp; ~RT_MM_PAGE_MASK) -</span><br><span class="line">                      kup-&gt;size * RT_MM_PAGE_SIZE);</span><br><span class="line">    RT_ASSERT(z-&gt;z_magic == ZALLOC_SLAB_MAGIC);</span><br><span class="line"></span><br><span class="line">    zoneindex(&amp;size);</span><br><span class="line">    <span class="keyword">if</span> (z-&gt;z_chunksize == size)</span><br><span class="line">        <span class="keyword">return</span> (ptr); <span class="comment">/* same chunk */</span></span><br></pre></td></tr></tbody></table></figure><ul><li>如果是 SMALL，首先找到歸屬得 zone：<ul><li>透過減掉頁資訊上的 size 乘以頁的大小，即可找到zone的初始位址</li><li>在 <code>malloc</code> 中，建立 zone 時 size 是從 0 開始填，一頁一頁加一</li><li>如果新的大小與原本的 chunk 相同，不做事</li></ul></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Allocate memory for the new request size.  Note that zoneindex has</span></span><br><span class="line"><span class="comment">         * already adjusted the request size to the appropriate chunk size, which</span></span><br><span class="line"><span class="comment">         * should optimize our bcopy().  Then copy and return the new pointer.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((nptr = rt_malloc(size)) == RT_NULL)</span><br><span class="line">            <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line">        rt_memcpy(nptr, ptr, size &gt; z-&gt;z_chunksize ? z-&gt;z_chunksize : size);</span><br><span class="line">        rt_free(ptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_realloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果不同，<code>malloc(size)</code>，並還原資料，釋放舊的記憶體</li></ul><hr><h3 id="rt-calloc"><a href="#rt-calloc" class="headerlink" title="rt_calloc"></a>rt_calloc</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>要求一段連續的記憶體</td><td>記憶體位址</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>count</code></th><th><code>size</code></th></tr></thead><tbody><tr><td>欲要求的數量</td><td>一塊的大小</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will contiguously allocate enough space for count objects</span></span><br><span class="line"><span class="comment"> * that are size bytes of memory each and returns a pointer to the allocated</span></span><br><span class="line"><span class="comment"> * memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The allocated memory is filled with bytes of value zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param count number of objects to allocate</span></span><br><span class="line"><span class="comment"> * @param size size of the objects to allocate</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return pointer to allocated memory / NULL pointer if there is an error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_calloc</span><span class="params">(<span class="keyword">rt_size_t</span> count, <span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    <span class="comment">/* allocate 'count' objects of size 'size' */</span></span><br><span class="line">    p = rt_malloc(count * size);</span><br><span class="line">    <span class="comment">/* zero the memory */</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        rt_memset(p, <span class="number">0</span>, count * size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_calloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>與 memheap 相同，一次要一塊 <code>count</code> 乘 <code>size</code> 的記憶體</li><li>清 0 並回傳起始位址</li></ul><hr><h2 id="釋放記憶體"><a href="#釋放記憶體" class="headerlink" title="釋放記憶體"></a>釋放記憶體</h2><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*ptr</code></th></tr></thead><tbody><tr><td>釋放記憶體</td><td>void</td><td>欲釋放的記憶體</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will release the previous allocated memory block by rt_malloc.</span></span><br><span class="line"><span class="comment"> * The released memory block is taken back to system heap.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param ptr the address of memory which will be released</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    slab_zone *z;</span><br><span class="line">    slab_chunk *chunk;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">memusage</span> *<span class="title">kup</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free a RT_NULL pointer */</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_free_hook, (ptr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get memory usage */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RT_DEBUG_SLAB</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">rt_uint32_t</span> addr = ((<span class="keyword">rt_uint32_t</span>)ptr &amp; ~RT_MM_PAGE_MASK);</span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_SLAB,</span><br><span class="line">                     (<span class="string">"free a memory 0x%x and align to 0x%x, kup index %d\n"</span>,</span><br><span class="line">                      (<span class="keyword">rt_uint32_t</span>)ptr,</span><br><span class="line">                      (<span class="keyword">rt_uint32_t</span>)addr,</span><br><span class="line">                      ((<span class="keyword">rt_uint32_t</span>)(addr) - heap_start) &gt;&gt; RT_MM_PAGE_BITS));</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    kup = btokup((<span class="keyword">rt_uint32_t</span>)ptr &amp; ~RT_MM_PAGE_MASK);</span><br><span class="line">    <span class="comment">/* release large allocation */</span></span><br><span class="line">    <span class="keyword">if</span> (kup-&gt;type == PAGE_TYPE_LARGE)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">rt_uint32_t</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* lock heap */</span></span><br><span class="line">        rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line">        <span class="comment">/* clear page counter */</span></span><br><span class="line">        size = kup-&gt;size;</span><br><span class="line">        kup-&gt;size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem -= size * RT_MM_PAGE_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_SLAB,</span><br><span class="line">                     (<span class="string">"free large memory block 0x%x, page count %d\n"</span>,</span><br><span class="line">                      (<span class="keyword">rt_uint32_t</span>)ptr, size));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* free this page */</span></span><br><span class="line">        rt_page_free(ptr, size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果要釋放的記憶體是由頁分配器分配的，根據頁資訊中的 size 來釋放，並清 0</li><li>實際呼叫 <code>rt_page_free(ptr, size)</code> 來完成</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* lock heap */</span></span><br><span class="line">    rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zone case. get out zone. */</span></span><br><span class="line">    z = (slab_zone *)(((<span class="keyword">rt_uint32_t</span>)ptr &amp; ~RT_MM_PAGE_MASK) -</span><br><span class="line">                      kup-&gt;size * RT_MM_PAGE_SIZE);</span><br><span class="line">    RT_ASSERT(z-&gt;z_magic == ZALLOC_SLAB_MAGIC);</span><br><span class="line"></span><br><span class="line">    chunk          = (slab_chunk *)ptr;</span><br><span class="line">    chunk-&gt;c_next  = z-&gt;z_freechunk;</span><br><span class="line">    z-&gt;z_freechunk = chunk;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">    used_mem -= z-&gt;z_chunksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>如果是由 zone 分配，找到歸屬的 zone，並將需要釋放的 chunk 插到 free list 上</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bump the number of free chunks.  If it becomes non-zero the zone</span></span><br><span class="line"><span class="comment"> * must be added back onto the appropriate list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (z-&gt;z_nfree++ == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    z-&gt;z_next = zone_array[z-&gt;z_zoneindex];</span><br><span class="line">    zone_array[z-&gt;z_zoneindex] = z;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>更新 <code>nfree</code>，如果本來為 0 ，則需要將此 zone 插回 zone array</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the zone becomes totally free, and there are other zones we</span></span><br><span class="line"><span class="comment"> * can allocate from, move this zone to the FreeZones list.  Since</span></span><br><span class="line"><span class="comment"> * this code can be called from an IPI callback, do *NOT* try to mess</span></span><br><span class="line"><span class="comment"> * with kernel_map here.  Hysteresis will be performed at malloc() time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (z-&gt;z_nfree == z-&gt;z_nmax &amp;&amp;</span><br><span class="line">    (z-&gt;z_next || zone_array[z-&gt;z_zoneindex] != z))</span><br><span class="line">{</span><br><span class="line">    slab_zone **pz;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"free zone 0x%x\n"</span>,</span><br><span class="line">                                 (<span class="keyword">rt_uint32_t</span>)z, z-&gt;z_zoneindex));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remove zone from zone array list */</span></span><br><span class="line">    <span class="keyword">for</span> (pz = &amp;zone_array[z-&gt;z_zoneindex]; z != *pz; pz = &amp;(*pz)-&gt;z_next)</span><br><span class="line">        ;</span><br><span class="line">    *pz = z-&gt;z_next;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果釋放完這個 chunk 後整個 zone 都釋放完了，我們需要釋放整個 zone</li><li>這裡還同時確保在同一個 zone array entry 中還有其他的 zone 可以分配</li><li>接著我們把這個 zone 從 zone array 移除</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset zone */</span></span><br><span class="line">z-&gt;z_magic = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* insert to free zone list */</span></span><br><span class="line">z-&gt;z_next = zone_free;</span><br><span class="line">zone_free = z;</span><br><span class="line"></span><br><span class="line">++ zone_free_cnt;</span><br></pre></td></tr></tbody></table></figure><ul><li>重設 magic，將這個 zone 插上 free zone，free count 加一</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* release zone to page allocator */</span></span><br><span class="line">        <span class="keyword">if</span> (zone_free_cnt &gt; ZONE_RELEASE_THRESH)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">rt_base_t</span> i;</span><br><span class="line"></span><br><span class="line">            z         = zone_free;</span><br><span class="line">            zone_free = z-&gt;z_next;</span><br><span class="line">            -- zone_free_cnt;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* set message usage */</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>, kup = btokup(z); i &lt; zone_page_cnt; i ++)</span><br><span class="line">            {</span><br><span class="line">                kup-&gt;type = PAGE_TYPE_FREE;</span><br><span class="line">                kup-&gt;size = <span class="number">0</span>;</span><br><span class="line">                kup ++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* unlock heap */</span></span><br><span class="line">            rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* release pages */</span></span><br><span class="line">            rt_page_free(z, zone_size / RT_MM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* unlock heap */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_free);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果已經有 <code>ZONE_RELEASE_THRESH</code> (2) 個以上的 free zone，完全釋放一個 zone 給頁分配器<ul><li>從 free zone 中移除，free count 減一</li><li>重設頁資訊：type free、size 0</li><li>透過 <code>rt_page_free</code> 完成</li></ul></li></ul><hr><h3 id="rt-page-free"><a href="#rt-page-free" class="headerlink" title="rt_page_free"></a>rt_page_free</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>釋放頁記憶體</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*addr</code></th><th><code>pages</code></th></tr></thead><tbody><tr><td>欲釋放的頁</td><td>欲釋放的大小</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_page_free</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">rt_size_t</span> npages)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> *<span class="title">b</span>, *<span class="title">n</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> **<span class="title">prev</span>;</span></span><br><span class="line">    RT_ASSERT(addr != RT_NULL);</span><br><span class="line">    RT_ASSERT((<span class="keyword">rt_uint32_t</span>)addr % RT_MM_PAGE_SIZE == <span class="number">0</span>);</span><br><span class="line">    RT_ASSERT(npages != <span class="number">0</span>);</span><br><span class="line">    n = (struct rt_page_head *)addr;</span><br><span class="line">    <span class="comment">/* lock heap */</span></span><br><span class="line">    rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line">    <span class="keyword">for</span> (prev = &amp;rt_page_list; (b = *prev) != RT_NULL; prev = &amp;(b-&gt;next))</span><br><span class="line">    {</span><br><span class="line">        RT_ASSERT(b-&gt;page &gt; <span class="number">0</span>);</span><br><span class="line">        RT_ASSERT(b &gt; n || b + b-&gt;page &lt;= n);</span><br><span class="line">        <span class="keyword">if</span> (b + b-&gt;page == n)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (b + (b-&gt;page += npages) == b-&gt;next)</span><br><span class="line">            {</span><br><span class="line">                b-&gt;page += b-&gt;next-&gt;page;</span><br><span class="line">                b-&gt;next  = b-&gt;next-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">goto</span> _return;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (b == n + npages)</span><br><span class="line">        {</span><br><span class="line">            n-&gt;page = b-&gt;page + npages;</span><br><span class="line">            n-&gt;next = b-&gt;next;</span><br><span class="line">            *prev   = n;</span><br><span class="line">            <span class="keyword">goto</span> _return;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (b &gt; n + npages)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    n-&gt;page = npages;</span><br><span class="line">    n-&gt;next = b;</span><br><span class="line">    *prev   = n;</span><br><span class="line">_return:</span><br><span class="line">    <span class="comment">/* unlock heap */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;使用此管理方式： &lt;code&gt;#defined R
      
    
    </summary>
    
    
      <category term="RT-Thread" scheme="http://blog.lusw.dev/categories/RT-Thread/"/>
    
    
      <category term="kernel" scheme="http://blog.lusw.dev/tags/kernel/"/>
    
      <category term="RT-Thread" scheme="http://blog.lusw.dev/tags/RT-Thread/"/>
    
      <category term="記憶體管理" scheme="http://blog.lusw.dev/tags/%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86/"/>
    
      <category term="SLAB" scheme="http://blog.lusw.dev/tags/SLAB/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread 小記憶體動態管理</title>
    <link href="http://blog.lusw.dev/rt-small-mem/"/>
    <id>http://blog.lusw.dev/rt-small-mem/</id>
    <published>2018-12-05T07:42:44.000Z</published>
    <updated>2020-04-23T05:02:36.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>使用此管理方式： <code>#defined RT_USING_HEAP &amp;&amp; #defined RT_USING_SMALL_MEM</code></p></blockquote><ul><li>與 memory heap 的做法類似，一開始是一塊大的記憶體，包含 header</li><li>分配記憶體時適當的切割</li><li>所有的記憶體塊透過 header 串起來，形成一個雙向鏈結</li></ul><p><img src="https://i.imgur.com/tbptSYO.png" alt="" title="small memory example"></p><hr><h2 id="結構"><a href="#結構" class="headerlink" title="結構"></a>結構</h2><div class="alert alert-success"><p><strong>File:</strong> mem.c</p></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* magic and used flag */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span> magic;</span><br><span class="line">    <span class="keyword">rt_uint16_t</span> used;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_size_t</span> next, prev;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span> thread[<span class="number">4</span>];   <span class="comment">/* thread name */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>此結構即為一個記憶體塊的 header</li><li>包含了<ul><li>magic 碼 <code>0x1ea0</code></li><li>使用中標記</li><li>前一顆與下一顆</li><li>使用此記憶體的 thread 名稱（選）</li></ul></li></ul><hr><h2 id="初始化-heap"><a href="#初始化-heap" class="headerlink" title="初始化 heap"></a>初始化 heap</h2><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 heap</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*begin_addr</code></th><th><code>*end_addr</code></th></tr></thead><tbody><tr><td>記憶體起始位址</td><td>結束位址</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ingroup SystemInit</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function will initialize system heap memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param begin_addr the beginning address of system heap memory.</span></span><br><span class="line"><span class="comment"> * @param end_addr the end address of system heap memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_system_heap_init</span><span class="params">(<span class="keyword">void</span> *begin_addr, <span class="keyword">void</span> *end_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">mem</span>;</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> begin_align = RT_ALIGN((<span class="keyword">rt_uint32_t</span>)begin_addr, RT_ALIGN_SIZE);</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> end_align = RT_ALIGN_DOWN((<span class="keyword">rt_uint32_t</span>)end_addr, RT_ALIGN_SIZE);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br></pre></td></tr></tbody></table></figure><ul><li>向上對齊起始位址與向下對齊結束位址</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* alignment addr */</span></span><br><span class="line"><span class="keyword">if</span> ((end_align &gt; (<span class="number">2</span> * SIZEOF_STRUCT_MEM)) &amp;&amp;</span><br><span class="line">    ((end_align - <span class="number">2</span> * SIZEOF_STRUCT_MEM) &gt;= begin_align))</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* calculate the aligned memory size */</span></span><br><span class="line">    mem_size_aligned = end_align - begin_align - <span class="number">2</span> * SIZEOF_STRUCT_MEM;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    rt_kprintf(<span class="string">"mem init, error begin address 0x%x, and end address 0x%x\n"</span>,</span><br><span class="line">               (<span class="keyword">rt_uint32_t</span>)begin_addr, (<span class="keyword">rt_uint32_t</span>)end_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著檢查起始與結束位址是否合法</li><li>如果合法，給定 <code>mem_size</code> 為結束位址 - 起始位址 - 2 倍的 <code>struct mem</code> 大小</li><li>也就是與 <code>mem_heap</code> 相同，一開始的記憶體設定為一大塊，頭與尾都要有一個 header</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* point to begin address of heap */</span></span><br><span class="line">heap_ptr = (<span class="keyword">rt_uint8_t</span> *)begin_align;</span><br><span class="line"></span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"mem init, heap begin address 0x%x, size %d\n"</span>,</span><br><span class="line">                            (<span class="keyword">rt_uint32_t</span>)heap_ptr, mem_size_aligned));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initialize the start of the heap */</span></span><br><span class="line">mem        = (struct heap_mem *)heap_ptr;</span><br><span class="line">mem-&gt;magic = HEAP_MAGIC;</span><br><span class="line">mem-&gt;next  = mem_size_aligned + SIZEOF_STRUCT_MEM;</span><br><span class="line">mem-&gt;prev  = <span class="number">0</span>;</span><br><span class="line">mem-&gt;used  = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>接著設定前面的 header：<ul><li>設定 magic 碼</li><li>下一塊為結尾的 header</li><li>上一塊為自己</li><li>以及沒有使用過</li></ul></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">    rt_mem_setname(mem, <span class="string">"INIT"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize the end of the heap */</span></span><br><span class="line">    heap_end        = (struct heap_mem *)&amp;heap_ptr[mem-&gt;next];</span><br><span class="line">    heap_end-&gt;magic = HEAP_MAGIC;</span><br><span class="line">    heap_end-&gt;used  = <span class="number">1</span>;</span><br><span class="line">    heap_end-&gt;next  = mem_size_aligned + SIZEOF_STRUCT_MEM;</span><br><span class="line">    heap_end-&gt;prev  = mem_size_aligned + SIZEOF_STRUCT_MEM;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">    rt_mem_setname(heap_end, <span class="string">"INIT"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>接著設定結尾的 header<ul><li>magic 碼</li><li>已被使用過</li><li>上一塊與下一塊指向自己</li></ul></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line">    rt_sem_init(&amp;heap_sem, <span class="string">"heap"</span>, <span class="number">1</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize the lowest-free pointer to the start of the heap */</span></span><br><span class="line">    lfree = (struct heap_mem *)heap_ptr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最後初始化 semaphore</li><li>把這一塊掛上 <code>lfree</code></li></ul><hr><h2 id="分配記憶體"><a href="#分配記憶體" class="headerlink" title="分配記憶體"></a>分配記憶體</h2><h3 id="Code-rt-malloc"><a href="#Code-rt-malloc" class="headerlink" title="Code: rt_malloc"></a>Code: rt_malloc</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>size</code></th></tr></thead><tbody><tr><td>要求記憶體</td><td>記憶體位址</td><td>欲要求的大小</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocate a block of memory with a minimum of 'size' bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param size is the minimum size of the requested block in bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return pointer to allocated memory or NULL if no free memory was found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_malloc</span><span class="params">(<span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_size_t</span> ptr, ptr2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">mem</span>, *<span class="title">mem2</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 <code>size</code> 為 0，回傳 NULL</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size != RT_ALIGN(size, RT_ALIGN_SIZE))</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"malloc size %d, but align to %d\n"</span>,</span><br><span class="line">                                size, RT_ALIGN(size, RT_ALIGN_SIZE)));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"malloc size %d\n"</span>, size));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* alignment size */</span></span><br><span class="line">size = RT_ALIGN(size, RT_ALIGN_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &gt; mem_size_aligned)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"no memory\n"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>向上對齊 <code>size</code>，如果超過可用大小，回傳 NULL</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* every data block must be at least MIN_SIZE_ALIGNED long */</span></span><br><span class="line"><span class="keyword">if</span> (size &lt; MIN_SIZE_ALIGNED)</span><br><span class="line">    size = MIN_SIZE_ALIGNED;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果小於 min size，設為 min size</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* take memory semaphore */</span></span><br><span class="line">rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br></pre></td></tr></tbody></table></figure><ul><li>取得 semaphore</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ptr = (<span class="keyword">rt_uint8_t</span> *)lfree - heap_ptr;</span><br><span class="line">     ptr &lt; mem_size_aligned - size;</span><br><span class="line">     ptr = ((struct heap_mem *)&amp;heap_ptr[ptr])-&gt;next)</span><br><span class="line">{</span><br><span class="line">    mem = (struct heap_mem *)&amp;heap_ptr[ptr];</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-info"><p>這裡特別的說明一下 for 迴圈：<br>首先起點是 <code>lfree</code> - <code>heap_ptr</code>，這裡代表最左邊的 free block 與 heap 起點的距離。 我們把 <code>heap_ptr</code> 看成是一個 <code>rt_uint8_t</code> 的陣列，也就是一格一個 byte 的陣列。 再來把 <code>lfree</code> - <code>heap_ptr</code> 看成是差量 (offset)，單位是 byte。 如此一來，<code>&amp;heap_ptr[ptr]</code> 就會是 <code>lfree</code> 的起始位置了。</p><p>再來我們看 <code>next</code>，在初始化的時候，<code>next</code> 是指向 0，這個意思是下一顆在陣列的第 0 個，也就是自己；所以 <code>next</code> 存放的是下一顆的 index，而不是起始位置。</p><p>最後來看上界，理論上我們需要從 lfree 找到最後一顆，實際上如果最後幾顆不夠大的話是不需要檢查的，所以這裡上界設在 <code>mem_size_aligned</code> - <code>size</code> 的意思就是說如果最後幾顆的大小總和不夠大，我們可以略過。</p></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((!mem-&gt;used) &amp;&amp; (mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM)) &gt;= size)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* mem is not used and at least perfect fit is possible:</span></span><br><span class="line"><span class="comment">     * mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */</span></span><br></pre></td></tr></tbody></table></figure><ul><li>first fit，如果找到第一顆可用的就進去</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM) &gt;=</span><br><span class="line">    (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))</span><br><span class="line">{</span><br></pre></td></tr></tbody></table></figure><ul><li>又，如果這顆夠大到可以切割的話</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br></pre></td><td class="code"><pre><span class="line">                <span class="comment">/* (in addition to the above, we test if another struct heap_mem (SIZEOF_STRUCT_MEM) containing</span></span><br><span class="line"><span class="comment">                 * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')</span></span><br><span class="line"><span class="comment">                 * -&gt; split large block, create empty remainder,</span></span><br><span class="line"><span class="comment">                 * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if</span></span><br><span class="line"><span class="comment">                 * mem-&gt;next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,</span></span><br><span class="line"><span class="comment">                 * struct heap_mem would fit in but no data between mem2 and mem2-&gt;next</span></span><br><span class="line"><span class="comment">                 * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty</span></span><br><span class="line"><span class="comment">                 *       region that couldn't hold data, but when mem-&gt;next gets freed,</span></span><br><span class="line"><span class="comment">                 *       the 2 regions would be combined, resulting in more free memory</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                ptr2 = ptr + SIZEOF_STRUCT_MEM + size;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* create mem2 struct */</span></span><br><span class="line">                mem2       = (struct heap_mem *)&amp;heap_ptr[ptr2];</span><br><span class="line">                mem2-&gt;magic = HEAP_MAGIC;</span><br><span class="line">                mem2-&gt;used = <span class="number">0</span>;</span><br><span class="line">                mem2-&gt;next = mem-&gt;next;</span><br><span class="line">                mem2-&gt;prev = ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">                rt_mem_setname(mem2, <span class="string">"    "</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>設定下一顆的資料，同時把 <code>next</code> 與 <code>prev</code> 接到正確位置</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* and insert it between mem and mem-&gt;next */</span></span><br><span class="line">mem-&gt;next = ptr2;</span><br><span class="line">mem-&gt;used = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mem2-&gt;next != mem_size_aligned + SIZEOF_STRUCT_MEM)</span><br><span class="line">{</span><br><span class="line">    ((struct heap_mem *)&amp;heap_ptr[mem2-&gt;next])-&gt;prev = ptr2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著把原本那塊的 <code>next</code> 指向新的那塊，設為使用中</li><li>如果新的那塊 <code>next</code> 不是最後一塊，設定 <code>prev</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">                used_mem += (size + SIZEOF_STRUCT_MEM);</span><br><span class="line">                <span class="keyword">if</span> (max_mem &lt; used_mem)</span><br><span class="line">                    max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            }</span><br></pre></td></tr></tbody></table></figure><ul><li>最後更新 <code>used_mem</code> 與 <code>max_mem</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="comment">/* (a mem2 struct does no fit into the user data space of mem and mem-&gt;next will always</span></span><br><span class="line"><span class="comment">                 * be used at this point: if not we have 2 unused structs in a row, plug_holes should have</span></span><br><span class="line"><span class="comment">                 * take care of this).</span></span><br><span class="line"><span class="comment">                 * -&gt; near fit or excact fit: do not split, no mem2 creation</span></span><br><span class="line"><span class="comment">                 * also can't move mem-&gt;next directly behind mem, since mem-&gt;next</span></span><br><span class="line"><span class="comment">                 * will always be used at this point!</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                mem-&gt;used = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">                used_mem += mem-&gt;next - ((<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr);</span><br><span class="line">                <span class="keyword">if</span> (max_mem &lt; used_mem)</span><br><span class="line">                    max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果不可切割，只需設定使用中即可</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">/* set memory block magic */</span></span><br><span class="line">            mem-&gt;magic = HEAP_MAGIC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">            <span class="keyword">if</span> (rt_thread_self())</span><br><span class="line">                rt_mem_setname(mem, rt_thread_self()-&gt;name);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rt_mem_setname(mem, <span class="string">"NONE"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mem == lfree)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">/* Find next free block after mem and update lowest free pointer */</span></span><br><span class="line">                <span class="keyword">while</span> (lfree-&gt;used &amp;&amp; lfree != heap_end)</span><br><span class="line">                    lfree = (struct heap_mem *)&amp;heap_ptr[lfree-&gt;next];</span><br><span class="line"></span><br><span class="line">                RT_ASSERT(((lfree == heap_end) || (!lfree-&gt;used)));</span><br><span class="line">            }</span><br></pre></td></tr></tbody></table></figure><ul><li>視情況更新 <code>lfree</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br></pre></td><td class="code"><pre><span class="line">        rt_sem_release(&amp;heap_sem);</span><br><span class="line">        RT_ASSERT((<span class="keyword">rt_uint32_t</span>)mem + SIZEOF_STRUCT_MEM + size &lt;= (<span class="keyword">rt_uint32_t</span>)heap_end);</span><br><span class="line">        RT_ASSERT((<span class="keyword">rt_uint32_t</span>)((<span class="keyword">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM) % RT_ALIGN_SIZE == <span class="number">0</span>);</span><br><span class="line">        RT_ASSERT((((<span class="keyword">rt_uint32_t</span>)mem) &amp; (RT_ALIGN_SIZE - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_MEM,</span><br><span class="line">                     (<span class="string">"allocate memory at 0x%x, size: %d\n"</span>,</span><br><span class="line">                      (<span class="keyword">rt_uint32_t</span>)((<span class="keyword">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM),</span><br><span class="line">                      (<span class="keyword">rt_uint32_t</span>)(mem-&gt;next - ((<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr))));</span><br><span class="line"></span><br><span class="line">        RT_OBJECT_HOOK_CALL(rt_malloc_hook,</span><br><span class="line">                            (((<span class="keyword">void</span> *)((<span class="keyword">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM)), size));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* return the memory data except mem struct */</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>還鎖，並回傳找到的記憶體位址</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br></pre></td><td class="code"><pre><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_malloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>沒找到一樣還鎖，並回傳 NULL</li></ul><hr><h3 id="Code-rt-realloc"><a href="#Code-rt-realloc" class="headerlink" title="Code: rt_realloc"></a>Code: rt_realloc</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>增長/縮減記憶體</td><td>記憶體位址</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*rmeme</code></th><th><code>newsize</code></th></tr></thead><tbody><tr><td>欲增長/縮減的記憶體位址</td><td>新的大小</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will change the previously allocated memory block.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rmem pointer to memory allocated by rt_malloc</span></span><br><span class="line"><span class="comment"> * @param newsize the required new size</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the changed memory block address</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_realloc</span><span class="params">(<span class="keyword">void</span> *rmem, <span class="keyword">rt_size_t</span> newsize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_size_t</span> size;</span><br><span class="line">    <span class="keyword">rt_size_t</span> ptr, ptr2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">mem</span>, *<span class="title">mem2</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *nmem;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* alignment size */</span></span><br><span class="line">    newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (newsize &gt; mem_size_aligned)</span><br><span class="line">    {</span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"realloc: out of memory\n"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (newsize == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_free(rmem);</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>向上對齊 size，如果：<ul><li>大於可用大小，回傳 NULL</li><li>等於 0，free 記憶體，回傳 NULL</li></ul></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* allocate a new memory block */</span></span><br><span class="line"><span class="keyword">if</span> (rmem == RT_NULL)</span><br><span class="line">    <span class="keyword">return</span> rt_malloc(newsize);</span><br></pre></td></tr></tbody></table></figure><ul><li>如原來的記憶體為空，直接 <code>malloc</code>，並回傳</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br></pre></td><td class="code"><pre><span class="line">rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">rt_uint8_t</span> *)rmem &lt; (<span class="keyword">rt_uint8_t</span> *)heap_ptr ||</span><br><span class="line">    (<span class="keyword">rt_uint8_t</span> *)rmem &gt;= (<span class="keyword">rt_uint8_t</span> *)heap_end)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* illegal memory */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rmem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著取得鎖，檢查傳入的記憶體是否合法</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br></pre></td><td class="code"><pre><span class="line">mem = (struct heap_mem *)((<span class="keyword">rt_uint8_t</span> *)rmem - SIZEOF_STRUCT_MEM);</span><br><span class="line"></span><br><span class="line">ptr = (<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr;</span><br><span class="line">size = mem-&gt;next - ptr - SIZEOF_STRUCT_MEM;</span><br><span class="line"><span class="keyword">if</span> (size == newsize)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* the size is the same as */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rmem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>找到記憶體塊的起始位址，算出 size，如果記憶體大小不需要變動，不做事，回傳原本的記憶體位址</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE &lt; size)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* split memory block */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem -= (size - newsize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;</span><br><span class="line">        mem2 = (struct heap_mem *)&amp;heap_ptr[ptr2];</span><br><span class="line">        mem2-&gt;magic = HEAP_MAGIC;</span><br><span class="line">        mem2-&gt;used = <span class="number">0</span>;</span><br><span class="line">        mem2-&gt;next = mem-&gt;next;</span><br><span class="line">        mem2-&gt;prev = ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">        rt_mem_setname(mem2, <span class="string">"    "</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        mem-&gt;next = ptr2;</span><br><span class="line">        <span class="keyword">if</span> (mem2-&gt;next != mem_size_aligned + SIZEOF_STRUCT_MEM)</span><br><span class="line">        {</span><br><span class="line">            ((struct heap_mem *)&amp;heap_ptr[mem2-&gt;next])-&gt;prev = ptr2;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果可以切割，與上面的動作相同</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br></pre></td><td class="code"><pre><span class="line">    plug_holes(mem2);</span><br><span class="line"></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rmem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>使用 <code>plug_holes</code> 來合併 free block</li><li>還鎖，回傳更新後的記憶體位置</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br></pre></td><td class="code"><pre><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* expand memory */</span></span><br><span class="line">    nmem = rt_malloc(newsize);</span><br><span class="line">    <span class="keyword">if</span> (nmem != RT_NULL) <span class="comment">/* check memory */</span></span><br><span class="line">    {</span><br><span class="line">        rt_memcpy(nmem, rmem, size &lt; newsize ? size : newsize);</span><br><span class="line">        rt_free(rmem);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nmem;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_realloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果不可切割，或是需要增長，直接要一塊 new size，釋放原本的記憶體</li><li>最後回傳新的記憶體位址</li></ul><hr><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*mem</code></th></tr></thead><tbody><tr><td>合併 free block</td><td>void</td><td>欲合併的記憶體位址</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">plug_holes</span><span class="params">(struct heap_mem *mem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">nmem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">pmem</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT((<span class="keyword">rt_uint8_t</span> *)mem &gt;= heap_ptr);</span><br><span class="line">    RT_ASSERT((<span class="keyword">rt_uint8_t</span> *)mem &lt; (<span class="keyword">rt_uint8_t</span> *)heap_end);</span><br><span class="line">    RT_ASSERT(mem-&gt;used == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* plug hole forward */</span></span><br><span class="line">    nmem = (struct heap_mem *)&amp;heap_ptr[mem-&gt;next];</span><br><span class="line">    <span class="keyword">if</span> (mem != nmem &amp;&amp;</span><br><span class="line">        nmem-&gt;used == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (<span class="keyword">rt_uint8_t</span> *)nmem != (<span class="keyword">rt_uint8_t</span> *)heap_end)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* if mem-&gt;next is unused and not end of heap_ptr,</span></span><br><span class="line"><span class="comment">         * combine mem and mem-&gt;next</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (lfree == nmem)</span><br><span class="line">        {</span><br><span class="line">            lfree = mem;</span><br><span class="line">        }</span><br><span class="line">        mem-&gt;next = nmem-&gt;next;</span><br><span class="line">        ((struct heap_mem *)&amp;heap_ptr[nmem-&gt;next])-&gt;prev = (<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果可以與下一顆合併</li><li>檢查是否需要更新 <code>lfree</code></li><li>重新接上 <code>next</code> 與 <code>prev</code> (<code>next</code> 的 <code>prev</code>)</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* plug hole backward */</span></span><br><span class="line">    pmem = (struct heap_mem *)&amp;heap_ptr[mem-&gt;prev];</span><br><span class="line">    <span class="keyword">if</span> (pmem != mem &amp;&amp; pmem-&gt;used == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* if mem-&gt;prev is unused, combine mem and mem-&gt;prev */</span></span><br><span class="line">        <span class="keyword">if</span> (lfree == mem)</span><br><span class="line">        {</span><br><span class="line">            lfree = pmem;</span><br><span class="line">        }</span><br><span class="line">        pmem-&gt;next = mem-&gt;next;</span><br><span class="line">        ((struct heap_mem *)&amp;heap_ptr[mem-&gt;next])-&gt;prev = (<span class="keyword">rt_uint8_t</span> *)pmem - heap_ptr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果可以與上一顆合併，動作一樣</li></ul><hr><h3 id="Code-rt-calloc"><a href="#Code-rt-calloc" class="headerlink" title="Code: rt_calloc"></a>Code: rt_calloc</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>要求一段連續的記憶體</td><td>記憶體位址</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>count</code></th><th><code>size</code></th></tr></thead><tbody><tr><td>欲要求的數量</td><td>一塊的大小</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will contiguously allocate enough space for count objects</span></span><br><span class="line"><span class="comment"> * that are size bytes of memory each and returns a pointer to the allocated</span></span><br><span class="line"><span class="comment"> * memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The allocated memory is filled with bytes of value zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param count number of objects to allocate</span></span><br><span class="line"><span class="comment"> * @param size size of the objects to allocate</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return pointer to allocated memory / NULL pointer if there is an error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_calloc</span><span class="params">(<span class="keyword">rt_size_t</span> count, <span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate 'count' objects of size 'size' */</span></span><br><span class="line">    p = rt_malloc(count * size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zero the memory */</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        rt_memset(p, <span class="number">0</span>, count * size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_calloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>與 memheap 相同，一次要一塊 count 乘 size 的記憶體</li><li>清 0 並回傳起始位址</li></ul><hr><h2 id="釋放記憶體"><a href="#釋放記憶體" class="headerlink" title="釋放記憶體"></a>釋放記憶體</h2><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*rmem</code></th></tr></thead><tbody><tr><td>釋放記憶體</td><td>void</td><td>欲釋放的記憶體</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will release the previously allocated memory block by</span></span><br><span class="line"><span class="comment"> * rt_malloc. The released memory block is taken back to system heap.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rmem the address of memory which will be released</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_free</span><span class="params">(<span class="keyword">void</span> *rmem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">mem</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rmem == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果需要釋放得記憶體為空，不做事</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">RT_ASSERT((((<span class="keyword">rt_uint32_t</span>)rmem) &amp; (RT_ALIGN_SIZE - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">RT_ASSERT((<span class="keyword">rt_uint8_t</span> *)rmem &gt;= (<span class="keyword">rt_uint8_t</span> *)heap_ptr &amp;&amp;</span><br><span class="line">          (<span class="keyword">rt_uint8_t</span> *)rmem &lt; (<span class="keyword">rt_uint8_t</span> *)heap_end);</span><br><span class="line"></span><br><span class="line">RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">rt_uint8_t</span> *)rmem &lt; (<span class="keyword">rt_uint8_t</span> *)heap_ptr ||</span><br><span class="line">    (<span class="keyword">rt_uint8_t</span> *)rmem &gt;= (<span class="keyword">rt_uint8_t</span> *)heap_end)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"illegal memory\n"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the corresponding struct heap_mem ... */</span></span><br><span class="line">mem = (struct heap_mem *)((<span class="keyword">rt_uint8_t</span> *)rmem - SIZEOF_STRUCT_MEM);</span><br></pre></td></tr></tbody></table></figure><ul><li>檢查記憶體位址是否合法，並找到真正的記憶體區塊位址</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEM,</span><br><span class="line">             (<span class="string">"release memory 0x%x, size: %d\n"</span>,</span><br><span class="line">              (<span class="keyword">rt_uint32_t</span>)rmem,</span><br><span class="line">              (<span class="keyword">rt_uint32_t</span>)(mem-&gt;next - ((<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr))));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* protect the heap from concurrent access */</span></span><br><span class="line">rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... which has to be in a used state ... */</span></span><br><span class="line"><span class="keyword">if</span> (!mem-&gt;used || mem-&gt;magic != HEAP_MAGIC)</span><br><span class="line">{</span><br><span class="line">    rt_kprintf(<span class="string">"to free a bad data block:\n"</span>);</span><br><span class="line">    rt_kprintf(<span class="string">"mem: 0x%08x, used flag: %d, magic code: 0x%04x\n"</span>, mem, mem-&gt;used, mem-&gt;magic);</span><br><span class="line">}</span><br><span class="line">RT_ASSERT(mem-&gt;used);</span><br><span class="line">RT_ASSERT(mem-&gt;magic == HEAP_MAGIC);</span><br></pre></td></tr></tbody></table></figure><ul><li>要鎖，檢查是否是使用中的區塊，及是否屬於 heap</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* ... and is now unused. */</span></span><br><span class="line">    mem-&gt;used  = <span class="number">0</span>;</span><br><span class="line">    mem-&gt;magic = HEAP_MAGIC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">    rt_mem_setname(mem, <span class="string">"    "</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem &lt; lfree)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* the newly freed struct is now the lowest */</span></span><br><span class="line">        lfree = mem;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>接著設為可使用，及更新 <code>lfree</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">    used_mem -= (mem-&gt;next - ((<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* finally, see if prev or next are free also */</span></span><br><span class="line">    plug_holes(mem);</span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_free);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後合併記憶體塊，並還鎖</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;使用此管理方式： &lt;code&gt;#defined R
      
    
    </summary>
    
    
      <category term="RT-Thread" scheme="http://blog.lusw.dev/categories/RT-Thread/"/>
    
    
      <category term="kernel" scheme="http://blog.lusw.dev/tags/kernel/"/>
    
      <category term="RT-Thread" scheme="http://blog.lusw.dev/tags/RT-Thread/"/>
    
      <category term="記憶體管理" scheme="http://blog.lusw.dev/tags/%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread Memory Heap</title>
    <link href="http://blog.lusw.dev/rt-memheap/"/>
    <id>http://blog.lusw.dev/rt-memheap/</id>
    <published>2018-12-05T07:42:29.000Z</published>
    <updated>2020-04-23T05:02:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>使用此管理方式： <code>#define RT_USING_MEMHEAP_AS_HEAP</code></p></blockquote><ul><li>memheap 的管理方法（動態管理）:<ul><li>從 RAM 中要一塊記憶體</li><li>根據使用者需要的大小進行切割</li><li>剩下的以雙向鏈結的方式接起來，形成 free list</li></ul></li></ul><h2 id="結構"><a href="#結構" class="headerlink" title="結構"></a>結構</h2><div class="alert alert-success"><p><strong>File:</strong> rtdef.h</p></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMHEAP</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * memory item on the heap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span>             magic;                      <span class="comment">/**&lt; magic number for memheap */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap</span>      *<span class="title">pool_ptr</span>;</span>                   <span class="comment">/**&lt; point of pool */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">next</span>;</span>                       <span class="comment">/**&lt; next memheap item */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">prev</span>;</span>                       <span class="comment">/**&lt; prev memheap item */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">next_free</span>;</span>                  <span class="comment">/**&lt; next free memheap item */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">prev_free</span>;</span>                  <span class="comment">/**&lt; prev free memheap item */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base structure of memory heap object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_object</span>        <span class="title">parent</span>;</span>                     <span class="comment">/**&lt; inherit from rt_object */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>                   *start_addr;                 <span class="comment">/**&lt; pool start address and size */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint32_t</span>             pool_size;                  <span class="comment">/**&lt; pool size */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span>             available_size;             <span class="comment">/**&lt; available size */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span>             max_used_size;              <span class="comment">/**&lt; maximum allocated size */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">block_list</span>;</span>                 <span class="comment">/**&lt; used block list */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">free_list</span>;</span>                  <span class="comment">/**&lt; free block list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span>  <span class="title">free_header</span>;</span>                <span class="comment">/**&lt; free block list header */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_semaphore</span>     <span class="title">lock</span>;</span>                       <span class="comment">/**&lt; semaphore lock */</span></span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>*start_addr</code> 指向可用的記憶體<br><br></li><li><code>pool_size</code> 代表總共可用的大小</li><li><code>available_size</code> 目前可用的大小</li><li><code>max_used_size</code> 已使用的歷史中，最大的使用大小<br><br></li><li><code>*block_list</code> 所有切割過的區塊（包含 header）<br><br></li><li><code>*free_list</code> 目前所有可用的區塊</li><li><code>*free_list</code> 的第一顆<br><br></li><li><code>lock</code> semaphore</li></ul><hr><div class="alert alert-success"><p><strong>File:</strong> memheap.c</p></div><h2 id="建立-memory-heap"><a href="#建立-memory-heap" class="headerlink" title="建立 memory heap"></a>建立 memory heap</h2><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立 memheap</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*begin_addr</code></th><th><code>*end_addr</code></th></tr></thead><tbody><tr><td>起始位址（欲分配的）</td><td>結束位址</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_system_heap_init</span><span class="params">(<span class="keyword">void</span> *begin_addr, <span class="keyword">void</span> *end_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* initialize a default heap in the system */</span></span><br><span class="line">    rt_memheap_init(&amp;_heap,</span><br><span class="line">                    <span class="string">"heap"</span>,</span><br><span class="line">                    begin_addr,</span><br><span class="line">                    (<span class="keyword">rt_uint32_t</span>)end_addr - (<span class="keyword">rt_uint32_t</span>)begin_addr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>將起始位置，大小，結構體傳入 <code>rt_memheap_init</code></li></ul><hr><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 memheap</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*memheap</code></th><th><code>*name</code></th><th><code>*start_addr</code></th><th><code>size</code></th></tr></thead><tbody><tr><td>memheap 結構</td><td>名字</td><td>欲分配的記憶體起始位址</td><td>記憶體大小</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The initialized memory pool will be:</span></span><br><span class="line"><span class="comment"> * +-----------------------------------+--------------------------+</span></span><br><span class="line"><span class="comment"> * | whole freed memory block          | Used Memory Block Tailer |</span></span><br><span class="line"><span class="comment"> * +-----------------------------------+--------------------------+</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * block_list --&gt; whole freed memory block</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The length of Used Memory Block Tailer is 0,</span></span><br><span class="line"><span class="comment"> * which is prevents block merging across list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_memheap_init(struct rt_memheap *memheap,</span><br><span class="line">                         <span class="keyword">const</span> <span class="keyword">char</span>        *name,</span><br><span class="line">                         <span class="keyword">void</span>              *start_addr,</span><br><span class="line">                         <span class="keyword">rt_uint32_t</span>        size)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">item</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(memheap != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize pool object */</span></span><br><span class="line">    rt_object_init(&amp;(memheap-&gt;parent), RT_Object_Class_MemHeap, name);</span><br><span class="line"></span><br><span class="line">    memheap-&gt;start_addr     = start_addr;</span><br><span class="line">    memheap-&gt;pool_size      = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);</span><br><span class="line">    memheap-&gt;available_size = memheap-&gt;pool_size - (<span class="number">2</span> * RT_MEMHEAP_SIZE);</span><br><span class="line">    memheap-&gt;max_used_size  = memheap-&gt;pool_size - memheap-&gt;available_size;</span><br></pre></td></tr></tbody></table></figure><ul><li>首先填入 <code>start_addr</code></li><li>向下對齊 <code>size</code></li><li>設定可用大小為 <code>size</code> 減掉 2 個 header</li><li>設定最大已使用大小為目前已使用的大小（即 2 倍的 header）</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* initialize the free list header */</span></span><br><span class="line">item            = &amp;(memheap-&gt;free_header);</span><br><span class="line">item-&gt;magic     = RT_MEMHEAP_MAGIC;</span><br><span class="line">item-&gt;pool_ptr  = memheap;</span><br><span class="line">item-&gt;next      = RT_NULL;</span><br><span class="line">item-&gt;prev      = RT_NULL;</span><br><span class="line">item-&gt;next_free = item;</span><br><span class="line">item-&gt;prev_free = item;</span><br></pre></td></tr></tbody></table></figure><ul><li>先初始化 free list：<ul><li>讓 item 指向 free list 的 header</li><li>設定 magic 碼</li><li>將 <code>pool_ptr</code> 指向 memheap 結構</li><li><code>next</code>、<code>prev</code> 指向 <code>NULL</code></li><li><code>next_free</code>、<code>prev_free</code> 指向自己</li></ul></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set the free list to free list header */</span></span><br><span class="line">memheap-&gt;free_list = item;</span><br></pre></td></tr></tbody></table></figure><ul><li>給定 free list</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* initialize the first big memory block */</span></span><br><span class="line">item            = (struct rt_memheap_item *)start_addr;</span><br><span class="line">item-&gt;magic     = RT_MEMHEAP_MAGIC;</span><br><span class="line">item-&gt;pool_ptr  = memheap;</span><br><span class="line">item-&gt;next      = RT_NULL;</span><br><span class="line">item-&gt;prev      = RT_NULL;</span><br><span class="line">item-&gt;next_free = item;</span><br><span class="line">item-&gt;prev_free = item;</span><br></pre></td></tr></tbody></table></figure><ul><li>接著將整個 pool 設定為一個可用的 block<ul><li>讓 item 指向 起始位址</li><li>設定 magic 碼</li><li>將 <code>pool_ptr</code> 指向 memheap 結構</li><li><code>next</code>、<code>prev</code> 指向 <code>NULL</code></li><li><code>next_free</code>、<code>prev_free</code> 指向自己</li></ul></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">item-&gt;next = (struct rt_memheap_item *)</span><br><span class="line">             ((<span class="keyword">rt_uint8_t</span> *)item + memheap-&gt;available_size + RT_MEMHEAP_SIZE);</span><br><span class="line">item-&gt;prev = item-&gt;next;</span><br></pre></td></tr></tbody></table></figure><ul><li>讓 next 與 prev 指到結尾的 header</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* block list header */</span></span><br><span class="line">memheap-&gt;block_list = item;</span><br></pre></td></tr></tbody></table></figure><ul><li>給定 block_list</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* place the big memory block to free list */</span></span><br><span class="line">item-&gt;next_free = memheap-&gt;free_list-&gt;next_free;</span><br><span class="line">item-&gt;prev_free = memheap-&gt;free_list;</span><br><span class="line">memheap-&gt;free_list-&gt;next_free-&gt;prev_free = item;</span><br><span class="line">memheap-&gt;free_list-&gt;next_free            = item;</span><br></pre></td></tr></tbody></table></figure><ul><li>將 free list (item) 的 <code>next</code> 指向 <code>memheap-&gt;free_list-&gt;next_free</code>，也就是 free list</li><li><code>prev</code> 同上</li><li>將 free list (heap) 的 <code>next</code> 指向 <code>item</code></li><li><code>prev</code> 同上</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* move to the end of memory pool to build a small tailer block,</span></span><br><span class="line"><span class="comment"> * which prevents block merging</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">item = item-&gt;next;</span><br><span class="line"><span class="comment">/* it's a used memory block */</span></span><br><span class="line">item-&gt;magic     = RT_MEMHEAP_MAGIC | RT_MEMHEAP_USED;</span><br><span class="line">item-&gt;pool_ptr  = memheap;</span><br><span class="line">item-&gt;next      = (struct rt_memheap_item *)start_addr;</span><br><span class="line">item-&gt;prev      = (struct rt_memheap_item *)start_addr;</span><br><span class="line"><span class="comment">/* not in free list */</span></span><br><span class="line">item-&gt;next_free = item-&gt;prev_free = RT_NULL;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定尾巴的 header<ul><li>讓 item 指向 free list 的 header</li><li>設定 magic 碼為<strong>使用過</strong>的</li><li>將 <code>pool_ptr</code> 指向 memheap 結構</li><li><code>next</code>、<code>prev</code> 指向起始位置</li><li><code>next_free</code>、<code>prev_free</code> 指向 <code>NULL</code></li></ul></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* initialize semaphore lock */</span></span><br><span class="line">    rt_sem_init(&amp;(memheap-&gt;lock), name, <span class="number">1</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">                 (<span class="string">"memory heap: start addr 0x%08x, size %d, free list header 0x%08x\n"</span>,</span><br><span class="line">                  start_addr, size, &amp;(memheap-&gt;free_header)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_memheap_init);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後初始化 semaphore 並使用 FIFO</li></ul><hr><h2 id="刪除-memory-heap"><a href="#刪除-memory-heap" class="headerlink" title="刪除 memory heap"></a>刪除 memory heap</h2><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*heap</code></th></tr></thead><tbody><tr><td>刪除 memheap</td><td><code>RT_EOK</code></td><td>欲刪除的 memheap</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_memheap_detach(struct rt_memheap *heap)</span><br><span class="line">{</span><br><span class="line">    RT_ASSERT(heap);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;heap-&gt;parent) == RT_Object_Class_MemHeap);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;heap-&gt;parent));</span><br><span class="line"></span><br><span class="line">    rt_object_detach(&amp;(heap-&gt;lock.parent.parent));</span><br><span class="line">    rt_object_detach(&amp;(heap-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return a successful completion. */</span></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_memheap_detach);</span><br></pre></td></tr></tbody></table></figure><ul><li>使用 <code>rt_object_detach</code> 刪除 semaphore 與 memheap</li></ul><hr><h2 id="分配記憶體"><a href="#分配記憶體" class="headerlink" title="分配記憶體"></a>分配記憶體</h2><h3 id="Code-rt-malloc"><a href="#Code-rt-malloc" class="headerlink" title="Code: rt_malloc"></a>Code: rt_malloc</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>size</code></th></tr></thead><tbody><tr><td>要求一塊記憶體</td><td>取得的記憶體</td><td>欲要求的大小</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_malloc</span><span class="params">(<span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to allocate in system heap */</span></span><br><span class="line">    ptr = rt_memheap_alloc(&amp;_heap, size);</span><br></pre></td></tr></tbody></table></figure><ul><li>首先嘗試從系統的 heap（<code>_heap</code>）要求記憶體（透過 <code>rt_memheap_alloc</code>）</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr == RT_NULL)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_object</span> *<span class="title">object</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_list_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap</span> *<span class="title">heap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_object_information</span> *<span class="title">information</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to allocate on other memory heap */</span></span><br><span class="line">    information = rt_object_get_information(RT_Object_Class_MemHeap);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果失敗，嘗試從其他的 heap 要求</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br></pre></td><td class="code"><pre><span class="line">RT_ASSERT(information != RT_NULL);</span><br><span class="line"><span class="keyword">for</span> (node  = information-&gt;object_list.next;</span><br><span class="line">     node != &amp;(information-&gt;object_list);</span><br><span class="line">     node  = node-&gt;next)</span><br><span class="line">{</span><br><span class="line">    object = rt_list_entry(node, struct rt_object, <span class="built_in">list</span>);</span><br><span class="line">    heap   = (struct rt_memheap *)object;</span><br><span class="line"></span><br><span class="line">    RT_ASSERT(heap);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;heap-&gt;parent) == RT_Object_Class_MemHeap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* not allocate in the default system heap */</span></span><br><span class="line">    <span class="keyword">if</span> (heap == &amp;_heap)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>跳過系統的 heap</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br></pre></td><td class="code"><pre><span class="line">            ptr = rt_memheap_alloc(heap, size);</span><br><span class="line">            <span class="keyword">if</span> (ptr != RT_NULL)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_malloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>一樣透過 <code>rt_memheap_alloc</code> 來完成</li><li>如果成功就跳出迴圈，最後回傳記憶體位址</li></ul><hr><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>要求一塊記憶體</td><td>取得的記憶體</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*heap</code></th><th><code>size</code></th></tr></thead><tbody><tr><td>目標 heap</td><td>欲要求的大小</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_memheap_alloc</span><span class="params">(struct rt_memheap *heap, <span class="keyword">rt_uint32_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_err_t</span> result;</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> free_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">header_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(heap != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;heap-&gt;parent) == RT_Object_Class_MemHeap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* align allocated size */</span></span><br><span class="line">    size = RT_ALIGN(size, RT_ALIGN_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (size &lt; RT_MEMHEAP_MINIALLOC)</span><br><span class="line">        size = RT_MEMHEAP_MINIALLOC;</span><br></pre></td></tr></tbody></table></figure><ul><li>首先向上對齊 <code>size</code></li><li>如果小於 <code>RT_MEMHEAP_MINIALLOC</code> (12)，設定為 <code>RT_MEMHEAP_MINIALLOC</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"allocate %d on heap:%8.*s"</span>,</span><br><span class="line">                                size, RT_NAME_MAX, heap-&gt;parent.name));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &lt; heap-&gt;available_size)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* search on free list */</span></span><br><span class="line">    free_size = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 heap 還夠使用，先將 <code>free_size</code> 設為 0</li><li><code>free_size</code> 代表我們目前找到的可用大小</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lock memheap */</span></span><br><span class="line">result = rt_sem_take(&amp;(heap-&gt;lock), RT_WAITING_FOREVER);</span><br><span class="line"><span class="keyword">if</span> (result != RT_EOK)</span><br><span class="line">{</span><br><span class="line">    rt_set_errno(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著試著索取 semaphore</li><li>如果失敗，設定錯誤碼並回傳 NULL</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get the first free memory block */</span></span><br><span class="line">header_ptr = heap-&gt;free_list-&gt;next_free;</span><br><span class="line"><span class="keyword">while</span> (header_ptr != heap-&gt;free_list &amp;&amp; free_size &lt; size)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* get current freed memory block size */</span></span><br><span class="line">    free_size = MEMITEM_SIZE(header_ptr);</span><br><span class="line">    <span class="keyword">if</span> (free_size &lt; size)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* move to next free memory block */</span></span><br><span class="line">        header_ptr = header_ptr-&gt;next_free;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著從 free list 上一個一個找</li><li>使用 <em>first fit</em>，找到一個大魚的就退出迴圈</li><li><code>MEMITEM_SIZE(item)</code>：<code>((rt_uint32_t)item-&gt;next - (rt_uint32_t)item - RT_MEMHEAP_SIZE)</code></li><li>利用下一顆的位址減掉自己的位址取的總體大小，再減掉 header 的大小</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* determine if the memory is available. */</span></span><br><span class="line"><span class="keyword">if</span> (free_size &gt;= size)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* a block that satisfies the request has been found. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* determine if the block needs to be split. */</span></span><br><span class="line">    <span class="keyword">if</span> (free_size &gt;= (size + RT_MEMHEAP_SIZE + RT_MEMHEAP_MINIALLOC))</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">new_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* split the block. */</span></span><br><span class="line">        new_ptr = (struct rt_memheap_item *)</span><br><span class="line">                  (((<span class="keyword">rt_uint8_t</span> *)header_ptr) + size + RT_MEMHEAP_SIZE);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果有成功找到（不是因為走完迴圈才往下）</li><li>且這塊大到可以再切一塊，切割這塊：<ul><li>從找到的那塊開始往後一個 <code>size</code> 與一個 <code>RT_MEMHEAP_SIZE</code> 作為新的 header</li></ul></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">             (<span class="string">"split: block[0x%08x] nextm[0x%08x] prevm[0x%08x] to new[0x%08x]\n"</span>,</span><br><span class="line">              header_ptr,</span><br><span class="line">              header_ptr-&gt;next,</span><br><span class="line">              header_ptr-&gt;prev,</span><br><span class="line">              new_ptr));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* mark the new block as a memory block and freed. */</span></span><br><span class="line">new_ptr-&gt;magic = RT_MEMHEAP_MAGIC;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* put the pool pointer into the new block. */</span></span><br><span class="line">new_ptr-&gt;pool_ptr = heap;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定 magic 碼</li><li>設定所屬 heap</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* break down the block list */</span></span><br><span class="line">new_ptr-&gt;prev          = header_ptr;</span><br><span class="line">new_ptr-&gt;next          = header_ptr-&gt;next;</span><br><span class="line">header_ptr-&gt;next-&gt;prev = new_ptr;</span><br><span class="line">header_ptr-&gt;next       = new_ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>將此 block 插入 <code>block_list</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove header ptr from free list */</span></span><br><span class="line">header_ptr-&gt;next_free-&gt;prev_free = header_ptr-&gt;prev_free;</span><br><span class="line">header_ptr-&gt;prev_free-&gt;next_free = header_ptr-&gt;next_free;</span><br><span class="line">header_ptr-&gt;next_free = RT_NULL;</span><br><span class="line">header_ptr-&gt;prev_free = RT_NULL;</span><br></pre></td></tr></tbody></table></figure><ul><li>從 free list 中移除找到的 block </li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* insert new_ptr to free list */</span></span><br><span class="line">new_ptr-&gt;next_free = heap-&gt;free_list-&gt;next_free;</span><br><span class="line">new_ptr-&gt;prev_free = heap-&gt;free_list;</span><br><span class="line">heap-&gt;free_list-&gt;next_free-&gt;prev_free = new_ptr;</span><br><span class="line">heap-&gt;free_list-&gt;next_free            = new_ptr;</span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"new ptr: next_free 0x%08x, prev_free 0x%08x\n"</span>,</span><br><span class="line">                                new_ptr-&gt;next_free,</span><br><span class="line">                                new_ptr-&gt;prev_free));</span><br></pre></td></tr></tbody></table></figure><ul><li>將分割好的 block 插入 free list</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* decrement the available byte count.  */</span></span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size -</span><br><span class="line">                           size -</span><br><span class="line">                           RT_MEMHEAP_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;pool_size - heap-&gt;available_size &gt; heap-&gt;max_used_size)</span><br><span class="line">        heap-&gt;max_used_size = heap-&gt;pool_size - heap-&gt;available_size;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>更新 <code>available_size</code> 與 <code>max_used_size</code> (如果需要)</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* decrement the entire free size from the available bytes count. */</span></span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size - free_size;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;pool_size - heap-&gt;available_size &gt; heap-&gt;max_used_size)</span><br><span class="line">        heap-&gt;max_used_size = heap-&gt;pool_size - heap-&gt;available_size;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果不能切割，一樣更新 <code>available_size</code> 與 <code>max_used_size</code> (如果需要)</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* remove header_ptr from free list */</span></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">                 (<span class="string">"one block: block[0x%08x], next_free 0x%08x, prev_free 0x%08x\n"</span>,</span><br><span class="line">                  header_ptr,</span><br><span class="line">                  header_ptr-&gt;next_free,</span><br><span class="line">                  header_ptr-&gt;prev_free));</span><br><span class="line"></span><br><span class="line">    header_ptr-&gt;next_free-&gt;prev_free = header_ptr-&gt;prev_free;</span><br><span class="line">    header_ptr-&gt;prev_free-&gt;next_free = header_ptr-&gt;next_free;</span><br><span class="line">    header_ptr-&gt;next_free = RT_NULL;</span><br><span class="line">    header_ptr-&gt;prev_free = RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>從 free list 中移除找到的 block </li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Mark the allocated block as not available. */</span></span><br><span class="line">header_ptr-&gt;magic |= RT_MEMHEAP_USED;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* release lock */</span></span><br><span class="line">rt_sem_release(&amp;(heap-&gt;lock));</span><br></pre></td></tr></tbody></table></figure><ul><li>標記為使用中，釋放 semaphore</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Return a memory address to the caller.  */</span></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">                 (<span class="string">"alloc mem: memory[0x%08x], heap[0x%08x], size: %d\n"</span>,</span><br><span class="line">                  (<span class="keyword">void</span> *)((<span class="keyword">rt_uint8_t</span> *)header_ptr + RT_MEMHEAP_SIZE),</span><br><span class="line">                  header_ptr,</span><br><span class="line">                  size));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)((<span class="keyword">rt_uint8_t</span> *)header_ptr + RT_MEMHEAP_SIZE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最後回傳 block 記憶體位址 + header</li><li>即回傳可用的區塊</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* release lock */</span></span><br><span class="line">        rt_sem_release(&amp;(heap-&gt;lock));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"allocate memory: failed\n"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return the completion status.  */</span></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_memheap_alloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果找失敗，一樣釋放 semaphore</li><li>不論是找失敗，或是記憶體不足，皆回傳 NULL</li></ul><hr><h3 id="Code-rt-realloc"><a href="#Code-rt-realloc" class="headerlink" title="Code: rt_realloc"></a>Code: rt_realloc</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>重新要求記憶體（增長或縮減）</td><td>新分配完的記憶體塊</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*rmem</code></th><th><code>newsize</code></th></tr></thead><tbody><tr><td>欲重新分配的記憶體</td><td>新的大小</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_realloc</span><span class="params">(<span class="keyword">void</span> *rmem, <span class="keyword">rt_size_t</span> newsize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *new_ptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">header_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rmem == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> rt_malloc(newsize);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果傳入的記憶體位置為空，直接 <code>rt_malloc(newsize)</code> 並回傳</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newsize == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    rt_free(rmem);</span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 <code>newsize</code> 為 0，free 傳入的記憶體位置，回傳 NULL</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get old memory item */</span></span><br><span class="line">header_ptr = (struct rt_memheap_item *)</span><br><span class="line">             ((<span class="keyword">rt_uint8_t</span> *)rmem - RT_MEMHEAP_SIZE);</span><br></pre></td></tr></tbody></table></figure><ul><li>取得傳入的記憶體塊所屬的 header</li><li>malloc 時回傳的是可使用的起始位址，並不會包含 header，因此這裡減掉一個 header 的大小</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">671</span><br></pre></td><td class="code"><pre><span class="line">new_ptr = rt_memheap_realloc(header_ptr-&gt;pool_ptr, rmem, newsize);</span><br></pre></td></tr></tbody></table></figure><ul><li>透過 <code>rt_memheap_realloc</code> 來完成</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (new_ptr == RT_NULL &amp;&amp; newsize != <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* allocate memory block from other memheap */</span></span><br><span class="line">    new_ptr = rt_malloc(newsize);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果無法在原本的 heap 完成增長（或縮減），直接從別的 heap 要一塊 <code>newsize</code> 大的記憶體</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (new_ptr != RT_NULL &amp;&amp; rmem != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">rt_size_t</span> oldsize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get the size of old memory block */</span></span><br><span class="line">        oldsize = MEMITEM_SIZE(header_ptr);</span><br><span class="line">        <span class="keyword">if</span> (newsize &gt; oldsize)</span><br><span class="line">            rt_memcpy(new_ptr, rmem, oldsize);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rt_memcpy(new_ptr, rmem, newsize);</span><br><span class="line"></span><br><span class="line">        rt_free(rmem);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果最後有要成功，復原原本的資料</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> new_ptr;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_realloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後回傳新的記憶體位址</li></ul><hr><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>重新要求記憶體（增長或縮減）</td><td>新分配完的記憶體塊</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>heap</code></th><th><code>*ptr</code></th><th><code>newsize</code></th></tr></thead><tbody><tr><td>目標 heap</td><td>欲重新分配的記憶體</td><td>新的大小</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_memheap_realloc</span><span class="params">(struct rt_memheap *heap, <span class="keyword">void</span> *ptr, <span class="keyword">rt_size_t</span> newsize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_err_t</span> result;</span><br><span class="line">    <span class="keyword">rt_size_t</span> oldsize;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">header_ptr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">new_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(heap);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;heap-&gt;parent) == RT_Object_Class_MemHeap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newsize == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_memheap_free(ptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 <code>newsize</code> 為 0，free 並回傳 NULL</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* align allocated size */</span></span><br><span class="line">newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);</span><br><span class="line"><span class="keyword">if</span> (newsize &lt; RT_MEMHEAP_MINIALLOC)</span><br><span class="line">    newsize = RT_MEMHEAP_MINIALLOC;</span><br></pre></td></tr></tbody></table></figure><ul><li>向上對齊 <code>newsize</code></li><li>如果小於 <code>RT_MEMHEAP_MINIALLOC</code> (12)，設定為 <code>RT_MEMHEAP_MINIALLOC</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr == RT_NULL)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> rt_memheap_alloc(heap, newsize);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果傳入的記憶體位置為空，直接 malloc newsize 的大小並回傳</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get memory block header and get the size of memory block */</span></span><br><span class="line">header_ptr = (struct rt_memheap_item *)</span><br><span class="line">             ((<span class="keyword">rt_uint8_t</span> *)ptr - RT_MEMHEAP_SIZE);</span><br><span class="line">oldsize = MEMITEM_SIZE(header_ptr);</span><br></pre></td></tr></tbody></table></figure><ul><li>取得傳入的 block 所屬的 header</li><li>一併計算這塊的大小</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* re-allocate memory */</span></span><br><span class="line"><span class="keyword">if</span> (newsize &gt; oldsize)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">void</span> *new_ptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">next_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lock memheap */</span></span><br><span class="line">    result = rt_sem_take(&amp;(heap-&gt;lock), RT_WAITING_FOREVER);</span><br><span class="line">    <span class="keyword">if</span> (result != RT_EOK)</span><br><span class="line">    {</span><br><span class="line">        rt_set_errno(result);</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果需要增長記憶體，先取得 semaphore</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br></pre></td><td class="code"><pre><span class="line">next_ptr = header_ptr-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* header_ptr should not be the tail */</span></span><br><span class="line">RT_ASSERT(next_ptr &gt; header_ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* check whether the following free space is enough to expand */</span></span><br><span class="line"><span class="keyword">if</span> (!RT_MEMHEAP_IS_USED(next_ptr))</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_int32_t</span> nextsize;</span><br><span class="line"></span><br><span class="line">    nextsize = MEMITEM_SIZE(next_ptr);</span><br><span class="line">    RT_ASSERT(next_ptr &gt; <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>先判斷下一顆可不可用</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Here is the ASCII art of the situation that we can make use of</span></span><br><span class="line"><span class="comment"> * the next free node without alloc/memcpy, |*| is the control</span></span><br><span class="line"><span class="comment"> * block:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      oldsize           free node</span></span><br><span class="line"><span class="comment"> * |*|-----------|*|----------------------|*|</span></span><br><span class="line"><span class="comment"> *         newsize          &gt;= minialloc</span></span><br><span class="line"><span class="comment"> * |*|----------------|*|-----------------|*|</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nextsize + oldsize &gt; newsize + RT_MEMHEAP_MINIALLOC)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* decrement the entire free size from the available bytes count. */</span></span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size - (newsize - oldsize);</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;pool_size - heap-&gt;available_size &gt; heap-&gt;max_used_size)</span><br><span class="line">        heap-&gt;max_used_size = heap-&gt;pool_size - heap-&gt;available_size;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果可用，而且下一顆足夠分割出一塊新的 block</li><li>更新 <code>available_size</code> 與 <code>max_used_size</code> (如果需要)</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove next_ptr from free list */</span></span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">             (<span class="string">"remove block: block[0x%08x], next_free 0x%08x, prev_free 0x%08x"</span>,</span><br><span class="line">              next_ptr,</span><br><span class="line">              next_ptr-&gt;next_free,</span><br><span class="line">              next_ptr-&gt;prev_free));</span><br><span class="line"></span><br><span class="line">next_ptr-&gt;next_free-&gt;prev_free = next_ptr-&gt;prev_free;</span><br><span class="line">next_ptr-&gt;prev_free-&gt;next_free = next_ptr-&gt;next_free;</span><br><span class="line">next_ptr-&gt;next-&gt;prev = next_ptr-&gt;prev;</span><br><span class="line">next_ptr-&gt;prev-&gt;next = next_ptr-&gt;next;</span><br></pre></td></tr></tbody></table></figure><ul><li>從 free list 移除舊的下一顆</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">363</span><br><span class="line">364</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* build a new one on the right place */</span></span><br><span class="line">next_ptr = (struct rt_memheap_item *)((<span class="keyword">char</span> *)ptr + newsize);</span><br></pre></td></tr></tbody></table></figure><ul><li>重新定指新的下一顆（傳入的起始位址加上 <code>newsize</code>）</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">             (<span class="string">"new free block: block[0x%08x] nextm[0x%08x] prevm[0x%08x]"</span>,</span><br><span class="line">              next_ptr,</span><br><span class="line">              next_ptr-&gt;next,</span><br><span class="line">              next_ptr-&gt;prev));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* mark the new block as a memory block and freed. */</span></span><br><span class="line">next_ptr-&gt;magic = RT_MEMHEAP_MAGIC;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* put the pool pointer into the new block. */</span></span><br><span class="line">next_ptr-&gt;pool_ptr = heap;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定 magic 碼</li><li>設定所屬 heap</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br></pre></td><td class="code"><pre><span class="line">next_ptr-&gt;prev          = header_ptr;</span><br><span class="line">next_ptr-&gt;next          = header_ptr-&gt;next;</span><br><span class="line">header_ptr-&gt;next-&gt;prev = next_ptr;</span><br><span class="line">header_ptr-&gt;next       = next_ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>插入 block list</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* insert next_ptr to free list */</span></span><br><span class="line">next_ptr-&gt;next_free = heap-&gt;free_list-&gt;next_free;</span><br><span class="line">next_ptr-&gt;prev_free = heap-&gt;free_list;</span><br><span class="line">heap-&gt;free_list-&gt;next_free-&gt;prev_free = next_ptr;</span><br><span class="line">heap-&gt;free_list-&gt;next_free            = next_ptr;</span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"new ptr: next_free 0x%08x, prev_free 0x%08x"</span>,</span><br><span class="line">                                next_ptr-&gt;next_free,</span><br><span class="line">                                next_ptr-&gt;prev_free));</span><br></pre></td></tr></tbody></table></figure><p>插入 free list</p><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* release lock */</span></span><br><span class="line">        rt_sem_release(&amp;(heap-&gt;lock));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>釋放 semaphore 並回傳更新後的記憶體位址</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* release lock */</span></span><br><span class="line">    rt_sem_release(&amp;(heap-&gt;lock));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* re-allocate a memory block */</span></span><br><span class="line">    new_ptr = (<span class="keyword">void</span> *)rt_memheap_alloc(heap, newsize);</span><br><span class="line">    <span class="keyword">if</span> (new_ptr != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        rt_memcpy(new_ptr, ptr, oldsize &lt; newsize ? oldsize : newsize);</span><br><span class="line">        rt_memheap_free(ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_ptr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果下一顆不夠大，重新在原本的 heap 上要一塊 <code>newsize</code> 大的記憶體</li><li>成功的話還原資料，並釋放原本的記憶體 </li><li>回傳新的記憶體位址</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* don't split when there is less than one node space left */</span></span><br><span class="line"><span class="keyword">if</span> (newsize + RT_MEMHEAP_SIZE + RT_MEMHEAP_MINIALLOC &gt;= oldsize)</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果是需要縮減，且縮減後剩下的大小不足以切成一塊</li><li>什麼事都不做，直接回傳原本的位址</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lock memheap */</span></span><br><span class="line">result = rt_sem_take(&amp;(heap-&gt;lock), RT_WAITING_FOREVER);</span><br><span class="line"><span class="keyword">if</span> (result != RT_EOK)</span><br><span class="line">{</span><br><span class="line">    rt_set_errno(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>可以分割的話先取得 semaphore</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* split the block. */</span></span><br><span class="line">new_ptr = (struct rt_memheap_item *)</span><br><span class="line">          (((<span class="keyword">rt_uint8_t</span> *)header_ptr) + newsize + RT_MEMHEAP_SIZE);</span><br></pre></td></tr></tbody></table></figure><ul><li>定址新的 block</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">             (<span class="string">"split: block[0x%08x] nextm[0x%08x] prevm[0x%08x] to new[0x%08x]\n"</span>,</span><br><span class="line">              header_ptr,</span><br><span class="line">              header_ptr-&gt;next,</span><br><span class="line">              header_ptr-&gt;prev,</span><br><span class="line">              new_ptr));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* mark the new block as a memory block and freed. */</span></span><br><span class="line">new_ptr-&gt;magic = RT_MEMHEAP_MAGIC;</span><br><span class="line"><span class="comment">/* put the pool pointer into the new block. */</span></span><br><span class="line">new_ptr-&gt;pool_ptr = heap;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定 magic 碼</li><li>設定所屬 heap</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* break down the block list */</span></span><br><span class="line">new_ptr-&gt;prev          = header_ptr;</span><br><span class="line">new_ptr-&gt;next          = header_ptr-&gt;next;</span><br><span class="line">header_ptr-&gt;next-&gt;prev = new_ptr;</span><br><span class="line">header_ptr-&gt;next       = new_ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>插入至 block list</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* determine if the block can be merged with the next neighbor. */</span></span><br><span class="line"><span class="keyword">if</span> (!RT_MEMHEAP_IS_USED(new_ptr-&gt;next))</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">free_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* merge block with next neighbor. */</span></span><br><span class="line">    free_ptr = new_ptr-&gt;next;</span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size - MEMITEM_SIZE(free_ptr);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果新的 block 下一顆未使用，即可合併</li><li>先將可用大小減掉下一顆的大小，待會會加回來</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">             (<span class="string">"merge: right node 0x%08x, next_free 0x%08x, prev_free 0x%08x\n"</span>,</span><br><span class="line">              header_ptr, header_ptr-&gt;next_free, header_ptr-&gt;prev_free));</span><br><span class="line"></span><br><span class="line">free_ptr-&gt;next-&gt;prev = new_ptr;</span><br><span class="line">new_ptr-&gt;next   = free_ptr-&gt;next;</span><br></pre></td></tr></tbody></table></figure><ul><li>從 block list 移除下一顆</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* remove free ptr from free list */</span></span><br><span class="line">    free_ptr-&gt;next_free-&gt;prev_free = free_ptr-&gt;prev_free;</span><br><span class="line">    free_ptr-&gt;prev_free-&gt;next_free = free_ptr-&gt;next_free;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>從 free list 移除下一顆，完成合併</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* insert the split block to free list */</span></span><br><span class="line">new_ptr-&gt;next_free = heap-&gt;free_list-&gt;next_free;</span><br><span class="line">new_ptr-&gt;prev_free = heap-&gt;free_list;</span><br><span class="line">heap-&gt;free_list-&gt;next_free-&gt;prev_free = new_ptr;</span><br><span class="line">heap-&gt;free_list-&gt;next_free            = new_ptr;</span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"new free ptr: next_free 0x%08x, prev_free 0x%08x\n"</span>,</span><br><span class="line">                                new_ptr-&gt;next_free,</span><br><span class="line">                                new_ptr-&gt;prev_free));</span><br></pre></td></tr></tbody></table></figure><ul><li>無論下一顆是否可以合併，都把新的 block 插入 free list</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* increment the available byte count.  */</span></span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size + MEMITEM_SIZE(new_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* release lock */</span></span><br><span class="line">    rt_sem_release(&amp;(heap-&gt;lock));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* return the old memory block */</span></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_memheap_realloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>更新可用大小，並釋放 semaphore</li><li>回傳更新後的記憶體位址</li></ul><hr><h3 id="Code-rt-calloc"><a href="#Code-rt-calloc" class="headerlink" title="Code: rt_calloc"></a>Code: rt_calloc</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>要求多個連續的記憶體</td><td>第一塊的位址</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>count</code></th><th><code>size</code></th></tr></thead><tbody><tr><td>欲要求的數量</td><td>欲要求的大小</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_calloc</span><span class="params">(<span class="keyword">rt_size_t</span> count, <span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">rt_size_t</span> total_size;</span><br><span class="line"></span><br><span class="line">    total_size = count * size;</span><br><span class="line">    ptr = rt_malloc(total_size);</span><br><span class="line">    <span class="keyword">if</span> (ptr != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* clean memory */</span></span><br><span class="line">        rt_memset(ptr, <span class="number">0</span>, total_size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_calloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>即要求一塊 <code>count * size</code> 大的記憶體</li></ul><hr><h2 id="釋放記憶體"><a href="#釋放記憶體" class="headerlink" title="釋放記憶體"></a>釋放記憶體</h2><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*rmem</code></th></tr></thead><tbody><tr><td>釋放一塊記憶體</td><td>void</td><td>欲釋放的記憶體</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_free</span><span class="params">(<span class="keyword">void</span> *rmem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    rt_memheap_free(rmem);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_free);</span><br></pre></td></tr></tbody></table></figure><ul><li>透過 <code>rt_memheap_free</code> 完成</li></ul><hr><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*ptr</code></th></tr></thead><tbody><tr><td>釋放一塊記憶體</td><td>void</td><td>欲釋放的記憶體</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_memheap_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_err_t</span> result;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap</span> *<span class="title">heap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">header_ptr</span>, *<span class="title">new_ptr</span>;</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> insert_header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* NULL check */</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == RT_NULL) <span class="keyword">return</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果傳入 NULL，什麼事都不用做</li><li><code>return</code> 退出副程式</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set initial status as OK */</span></span><br><span class="line">insert_header = <span class="number">1</span>;</span><br><span class="line">new_ptr       = RT_NULL;</span><br><span class="line">header_ptr    = (struct rt_memheap_item *)</span><br><span class="line">                ((<span class="keyword">rt_uint8_t</span> *)ptr - RT_MEMHEAP_SIZE);</span><br></pre></td></tr></tbody></table></figure><ul><li>初始化一些參數，並找到傳入的 block 所屬的 header</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"free memory: memory[0x%08x], block[0x%08x]\n"</span>,</span><br><span class="line">                                ptr, header_ptr));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* check magic */</span></span><br><span class="line">RT_ASSERT((header_ptr-&gt;magic &amp; RT_MEMHEAP_MASK) == RT_MEMHEAP_MAGIC);</span><br><span class="line">RT_ASSERT(header_ptr-&gt;magic &amp; RT_MEMHEAP_USED);</span><br><span class="line"><span class="comment">/* check whether this block of memory has been over-written. */</span></span><br><span class="line">RT_ASSERT((header_ptr-&gt;next-&gt;magic &amp; RT_MEMHEAP_MASK) == RT_MEMHEAP_MAGIC);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get pool ptr */</span></span><br><span class="line">heap = header_ptr-&gt;pool_ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>定址 heap</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br></pre></td><td class="code"><pre><span class="line">RT_ASSERT(heap);</span><br><span class="line">RT_ASSERT(rt_object_get_type(&amp;heap-&gt;parent) == RT_Object_Class_MemHeap);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* lock memheap */</span></span><br><span class="line">result = rt_sem_take(&amp;(heap-&gt;lock), RT_WAITING_FOREVER);</span><br><span class="line"><span class="keyword">if</span> (result != RT_EOK)</span><br><span class="line">{</span><br><span class="line">    rt_set_errno(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>先取得 semaphore</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Mark the memory as available. */</span></span><br><span class="line">header_ptr-&gt;magic &amp;= ~RT_MEMHEAP_USED;</span><br><span class="line"><span class="comment">/* Adjust the available number of bytes. */</span></span><br><span class="line">heap-&gt;available_size = heap-&gt;available_size + MEMITEM_SIZE(header_ptr);</span><br></pre></td></tr></tbody></table></figure><ul><li>將使用中的標記清除，更新可用大小</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Determine if the block can be merged with the previous neighbor. */</span></span><br><span class="line"><span class="keyword">if</span> (!RT_MEMHEAP_IS_USED(header_ptr-&gt;prev))</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"merge: left node 0x%08x\n"</span>,</span><br><span class="line">                                    header_ptr-&gt;prev));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* adjust the available number of bytes. */</span></span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size + RT_MEMHEAP_SIZE;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果可以往前合併，更新可用大小（加一個 header 的大小）</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* yes, merge block with previous neighbor. */</span></span><br><span class="line">(header_ptr-&gt;prev)-&gt;next = header_ptr-&gt;next;</span><br><span class="line">(header_ptr-&gt;next)-&gt;prev = header_ptr-&gt;prev;</span><br></pre></td></tr></tbody></table></figure><ul><li>從 block list 移除此 block</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* move header pointer to previous. */</span></span><br><span class="line">    header_ptr = header_ptr-&gt;prev;</span><br><span class="line">    <span class="comment">/* don't insert header to free list */</span></span><br><span class="line">    insert_header = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>重新定址 <code>header_ptr</code></li><li>設定 <code>insert_header</code> 為 0，表示待會不需要將此 block 插回 free list（現在此 block 是與前一塊合併的，已經在 free list 上了）</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* determine if the block can be merged with the next neighbor. */</span></span><br><span class="line"><span class="keyword">if</span> (!RT_MEMHEAP_IS_USED(header_ptr-&gt;next))</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* adjust the available number of bytes. */</span></span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size + RT_MEMHEAP_SIZE;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果可以往前合併，更新可用大小（加一個 header 的大小）</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* merge block with next neighbor. */</span></span><br><span class="line">new_ptr = header_ptr-&gt;next;</span><br><span class="line"></span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">             (<span class="string">"merge: right node 0x%08x, next_free 0x%08x, prev_free 0x%08x\n"</span>,</span><br><span class="line">              new_ptr, new_ptr-&gt;next_free, new_ptr-&gt;prev_free));</span><br><span class="line"></span><br><span class="line">new_ptr-&gt;next-&gt;prev = header_ptr;</span><br><span class="line">header_ptr-&gt;next    = new_ptr-&gt;next;</span><br></pre></td></tr></tbody></table></figure><ul><li>定址下一塊，並從 block list 移除下一塊</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* remove new ptr from free list */</span></span><br><span class="line">    new_ptr-&gt;next_free-&gt;prev_free = new_ptr-&gt;prev_free;</span><br><span class="line">    new_ptr-&gt;prev_free-&gt;next_free = new_ptr-&gt;next_free;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>一併從 free list 中移除</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (insert_header)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* no left merge, insert to free list */</span></span><br><span class="line">    header_ptr-&gt;next_free = heap-&gt;free_list-&gt;next_free;</span><br><span class="line">    header_ptr-&gt;prev_free = heap-&gt;free_list;</span><br><span class="line">    heap-&gt;free_list-&gt;next_free-&gt;prev_free = header_ptr;</span><br><span class="line">    heap-&gt;free_list-&gt;next_free            = header_ptr;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">                 (<span class="string">"insert to free list: next_free 0x%08x, prev_free 0x%08x\n"</span>,</span><br><span class="line">                  header_ptr-&gt;next_free, header_ptr-&gt;prev_free));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果需要，插回 free list 上</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* release lock */</span></span><br><span class="line">    rt_sem_release(&amp;(heap-&gt;lock));</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_memheap_free);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後釋放 semaphore</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;使用此管理方式： &lt;code&gt;#define RT
      
    
    </summary>
    
    
      <category term="RT-Thread" scheme="http://blog.lusw.dev/categories/RT-Thread/"/>
    
    
      <category term="kernel" scheme="http://blog.lusw.dev/tags/kernel/"/>
    
      <category term="RT-Thread" scheme="http://blog.lusw.dev/tags/RT-Thread/"/>
    
      <category term="記憶體管理" scheme="http://blog.lusw.dev/tags/%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86/"/>
    
      <category term="Memory Heap" scheme="http://blog.lusw.dev/tags/Memory-Heap/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread Memory Pool</title>
    <link href="http://blog.lusw.dev/rt-mem/"/>
    <id>http://blog.lusw.dev/rt-mem/</id>
    <published>2018-11-29T03:24:59.000Z</published>
    <updated>2020-04-23T05:02:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>使用此管理方式： <code>#define RT_USING_MEMPOOL</code></p></blockquote><ul><li>分配記憶體的時間需固定，而且可確定（可預測）的</li><li>分配記憶體同時也要盡量避免碎片化，才能減少系統需重啟的次數</li><li>RT-Thread 使用了靜態與動態管理，其中動態又分為小記憶體管理，與大記憶體管理（SLAB)</li></ul><hr><ul><li>mempool 的管理方法（靜態管理）:<ul><li>從 RAM 中要一塊記憶體</li><li>將此記憶體切成<strong>固定大小</strong>的區塊</li><li>以間接定址的方式接起來，形成 free list</li></ul></li></ul><h2 id="結構"><a href="#結構" class="headerlink" title="結構"></a>結構</h2><div class="alert alert-success"><p><strong>File:</strong> redef.h</p></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMPOOL</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base structure of Memory pool object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_mempool</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_object</span> <span class="title">parent</span>;</span>                            <span class="comment">/**&lt; inherit from rt_object */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>            *start_address;                     <span class="comment">/**&lt; memory pool start */</span></span><br><span class="line">    <span class="keyword">rt_size_t</span>        size;                              <span class="comment">/**&lt; size of memory pool */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_size_t</span>        block_size;                        <span class="comment">/**&lt; size of memory blocks */</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span>      *block_list;                        <span class="comment">/**&lt; memory blocks list */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_size_t</span>        block_total_count;                 <span class="comment">/**&lt; numbers of memory block */</span></span><br><span class="line">    <span class="keyword">rt_size_t</span>        block_free_count;                  <span class="comment">/**&lt; numbers of free memory block */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_list_t</span>        suspend_thread;                    <span class="comment">/**&lt; threads pended on this resource */</span></span><br><span class="line">    <span class="keyword">rt_size_t</span>        suspend_thread_count;              <span class="comment">/**&lt; numbers of thread pended on this resource */</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_mempool</span> *<span class="title">rt_mp_t</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>我們從文本的圖來解釋結構：<br><img src="https://i.imgur.com/9KWhnUY.png" alt="memory pool example" title="memory pool example"></p><ul><li><code>start_address</code> 為每個 mempool 的起始位置，此圖為例則為<em>mempool 1</em> 的起始位置</li><li><code>size</code> 為 mempool 的大小，此圖為例則為<em>mempool 1</em> 的大小（灰色區塊）<br><br></li><li><code>block_size</code> 為由 mempool 產出的空閒鏈表中，每一塊的大小，以<em>mempool 1</em> 為例，則為 32k</li><li><code>block_list</code> 為空閒鏈表，此圖為例則為<em>mempool 1</em> 旁邊的鏈結<br><br></li><li><code>block_total_count</code> 為空閒鏈表創建時的總塊數，以<em>mempool 1</em> 為例，則為 128</li><li><code>block_free_count</code> 為為空閒鏈表現在可用的總塊數<br><br></li><li><code>suspend_thread</code> 則為等待隊伍，此圖為例為最右邊的鏈結</li><li><code>suspend_thread_count</code> 則為等待隊伍的總排隊數，以此圖為例為 3</li></ul><hr><div class="alert alert-success"><p><strong>File:</strong> mempool.c</p></div><h2 id="建立-memory-pool"><a href="#建立-memory-pool" class="headerlink" title="建立 memory pool"></a>建立 memory pool</h2><ul><li>建立 memory pool 的方法一樣也可分為靜態的與動態的</li><li>這裡的動態是指從原先記憶體 heap 的區塊拿取記憶體</li></ul><h3 id="動態"><a href="#動態" class="headerlink" title="動態"></a>動態</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立 mempool（使用 heap）</td><td>mempool</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*name</code></th><th><code>block_count</code></th><th><code>block_size</code></th></tr></thead><tbody><tr><td>名字</td><td>要切割的總塊數</td><td>一塊 free block 的大小</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will create a mempool object and allocate the memory pool from</span></span><br><span class="line"><span class="comment"> * heap.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name the name of memory pool</span></span><br><span class="line"><span class="comment"> * @param block_count the count of blocks in memory pool</span></span><br><span class="line"><span class="comment"> * @param block_size the size for each block</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the created mempool object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_mp_t</span> rt_mp_create(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">                     <span class="keyword">rt_size_t</span>   block_count,</span><br><span class="line">                     <span class="keyword">rt_size_t</span>   block_size)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_uint8_t</span> *block_ptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mempool</span> *<span class="title">mp</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_size_t</span> offset;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate object */</span></span><br><span class="line">    mp = (struct rt_mempool *)rt_object_allocate(RT_Object_Class_MemPool, name);</span><br><span class="line">    <span class="comment">/* allocate object failed */</span></span><br><span class="line">    <span class="keyword">if</span> (mp == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br></pre></td></tr></tbody></table></figure><ul><li>首先一樣先從 heap 取一塊記憶體作為 mempool 使用</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* initialize memory pool */</span></span><br><span class="line">block_size     = RT_ALIGN(block_size, RT_ALIGN_SIZE);</span><br><span class="line">mp-&gt;block_size = block_size;</span><br><span class="line">mp-&gt;size       = (block_size + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *)) * block_count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocate memory */</span></span><br><span class="line">mp-&gt;start_address = rt_malloc((block_size + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *)) *</span><br><span class="line">                              block_count);</span><br><span class="line"><span class="keyword">if</span> (mp-&gt;start_address == RT_NULL)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* no memory, delete memory pool object */</span></span><br><span class="line">    rt_object_delete(&amp;(mp-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著對齊 <code>block_size</code> 後填入結構中，一併計算 mempool 的大小</li><li>並從 heap 中取出一塊待會做成 free list</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line">mp-&gt;block_total_count = block_count;</span><br><span class="line">mp-&gt;block_free_count  = mp-&gt;block_total_count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initialize suspended thread list */</span></span><br><span class="line">rt_list_init(&amp;(mp-&gt;suspend_thread));</span><br><span class="line">mp-&gt;suspend_thread_count = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>填入總數，建立等待鏈</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* initialize free block list */</span></span><br><span class="line">    block_ptr = (<span class="keyword">rt_uint8_t</span> *)mp-&gt;start_address;</span><br><span class="line">    <span class="keyword">for</span> (offset = <span class="number">0</span>; offset &lt; mp-&gt;block_total_count; offset ++)</span><br><span class="line">    {</span><br><span class="line">        *(<span class="keyword">rt_uint8_t</span> **)(block_ptr + offset * (block_size + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *)))</span><br><span class="line">            = block_ptr + (offset + <span class="number">1</span>) * (block_size + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">rt_uint8_t</span> **)(block_ptr + (offset - <span class="number">1</span>) * (block_size + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *)))</span><br><span class="line">        = RT_NULL;</span><br><span class="line"></span><br><span class="line">    mp-&gt;block_list = block_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mp;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mp_create);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後製作 free list：<ul><li>一個 free block 分成兩部分：前 8-bit (rt_uint8_t *）與一個 block_size</li><li>前 8-bit 存放下一個 free block 的位置</li></ul></li></ul><hr><h3 id="靜態"><a href="#靜態" class="headerlink" title="靜態"></a>靜態</h3><ul><li>多傳了兩個參數 <code>size</code> 與 <code>*start</code></li></ul><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立 mempool</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*mp</code></th><th><code>*name</code></th><th><code>*start</code></th></tr></thead><tbody><tr><td>結構位址</td><td>名字</td><td>所要使用的記憶體位址</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>size</code></th><th><code>block_size</code></th></tr></thead><tbody><tr><td>mempool 大小</td><td>一塊 free block 的大小</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will initialize a memory pool object, normally which is used</span></span><br><span class="line"><span class="comment"> * for static object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mp the memory pool object</span></span><br><span class="line"><span class="comment"> * @param name the name of memory pool</span></span><br><span class="line"><span class="comment"> * @param start the star address of memory pool</span></span><br><span class="line"><span class="comment"> * @param size the total size of memory pool</span></span><br><span class="line"><span class="comment"> * @param block_size the size for each block</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return RT_EOK</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mp_init(struct rt_mempool *mp,</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">char</span>        *name,</span><br><span class="line">                    <span class="keyword">void</span>              *start,</span><br><span class="line">                    <span class="keyword">rt_size_t</span>          size,</span><br><span class="line">                    <span class="keyword">rt_size_t</span>          block_size)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_uint8_t</span> *block_ptr;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_size_t</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mp != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize object */</span></span><br><span class="line">    rt_object_init(&amp;(mp-&gt;parent), RT_Object_Class_MemPool, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize memory pool */</span></span><br><span class="line">    mp-&gt;start_address = start;</span><br><span class="line">    mp-&gt;size = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* align the block size */</span></span><br><span class="line">    block_size = RT_ALIGN(block_size, RT_ALIGN_SIZE);</span><br><span class="line">    mp-&gt;block_size = block_size;</span><br></pre></td></tr></tbody></table></figure><ul><li>可直接用 <code>rt_object_init</code> 初始化物件</li><li>同時用 <code>RT_ALIGN_DOWN</code> 對齊 size </li><li>填入 <code>block_size</code></li></ul><p><code>RT_ALIGN_DOWN</code> v.s. <code>RT_ALIGN</code></p><ul><li>當傳入 (13,4) 時：</li><li><code>RT_ALIGN_DOWN</code> 回傳 12，也就是在不超過 13 中，4 的倍數中最大的</li><li><code>RT_ALIGN</code> 回傳 16，也就是在大於等於 13 中，4 的倍數中最小的</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* align to align size byte */</span></span><br><span class="line">mp-&gt;block_total_count = mp-&gt;size / (mp-&gt;block_size + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *));</span><br><span class="line">mp-&gt;block_free_count  = mp-&gt;block_total_count;</span><br></pre></td></tr></tbody></table></figure><ul><li>接著手動算出 block 的總數</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* initialize suspended thread list */</span></span><br><span class="line">    rt_list_init(&amp;(mp-&gt;suspend_thread));</span><br><span class="line">    mp-&gt;suspend_thread_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize free block list */</span></span><br><span class="line">    block_ptr = (<span class="keyword">rt_uint8_t</span> *)mp-&gt;start_address;</span><br><span class="line">    <span class="keyword">for</span> (offset = <span class="number">0</span>; offset &lt; mp-&gt;block_total_count; offset ++)</span><br><span class="line">    {</span><br><span class="line">        *(<span class="keyword">rt_uint8_t</span> **)(block_ptr + offset * (block_size + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *))) =</span><br><span class="line">            (<span class="keyword">rt_uint8_t</span> *)(block_ptr + (offset + <span class="number">1</span>) * (block_size + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *)));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">rt_uint8_t</span> **)(block_ptr + (offset - <span class="number">1</span>) * (block_size + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *))) =</span><br><span class="line">        RT_NULL;</span><br><span class="line"></span><br><span class="line">    mp-&gt;block_list = block_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mp_init);</span><br></pre></td></tr></tbody></table></figure><ul><li>其他的動作皆相同</li></ul><hr><h2 id="刪除-memory-pool"><a href="#刪除-memory-pool" class="headerlink" title="刪除 memory pool"></a>刪除 memory pool</h2><h3 id="動態-1"><a href="#動態-1" class="headerlink" title="動態"></a>動態</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>mp</code></th></tr></thead><tbody><tr><td>刪除 mempool（使用 heap）</td><td><code>RT_EOK</code></td><td>欲刪除的 mempool</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will delete a memory pool and release the object memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mp the memory pool object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return RT_EOK</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mp_delete(<span class="keyword">rt_mp_t</span> mp)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> temp;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mp != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mp-&gt;parent) == RT_Object_Class_MemPool);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;mp-&gt;parent) == RT_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wake up all suspended threads */</span></span><br><span class="line">    <span class="keyword">while</span> (!rt_list_isempty(&amp;(mp-&gt;suspend_thread)))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* disable interrupt */</span></span><br><span class="line">        temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get next suspend thread */</span></span><br><span class="line">        thread = rt_list_entry(mp-&gt;suspend_thread.next, struct rt_thread, tlist);</span><br><span class="line">        <span class="comment">/* set error code to RT_ERROR */</span></span><br><span class="line">        thread-&gt;error = -RT_ERROR;</span><br></pre></td></tr></tbody></table></figure><ul><li>當要把 mempool 刪除前，先將正在等待分配記憶體的 thread 一個一個叫醒</li><li>叫醒前，先將錯誤碼改成 <code>ERROR</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * resume thread</span></span><br><span class="line"><span class="comment"> * In rt_thread_resume function, it will remove current thread from</span></span><br><span class="line"><span class="comment"> * suspend list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">rt_thread_resume(thread);</span><br></pre></td></tr></tbody></table></figure><ul><li>接著透過 <code>rt_thread_resume</code> 叫醒 thread</li></ul><p>從等待鏈上移出的動作，在 <code>rt_thread_resume</code> 中會實現。<br>（code in <a href="/2018/11/19/rt-thread-thread#暫停、復原-thread">RT-Thread Thread</a>）</p><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* decrease suspended thread count */</span></span><br><span class="line">    mp-&gt;suspend_thread_count --;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最後更新 <code>suspend_thread_count</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* release allocated room */</span></span><br><span class="line">    rt_free(mp-&gt;start_address);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* detach object */</span></span><br><span class="line">    rt_object_delete(&amp;(mp-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mp_delete);</span><br></pre></td></tr></tbody></table></figure><ul><li>叫醒完，free 掉建立 mempool 時所要的記憶體</li><li>再透過 <code>rt_object_delete</code> 刪除</li></ul><hr><h3 id="靜態-1"><a href="#靜態-1" class="headerlink" title="靜態"></a>靜態</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*mp</code></th></tr></thead><tbody><tr><td>刪除 mempool</td><td><code>RT_EOK</code></td><td>欲刪除的 mempool</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will detach a memory pool from system object management.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mp the memory pool object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return RT_EOK</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mp_detach(struct rt_mempool *mp)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mp != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mp-&gt;parent) == RT_Object_Class_MemPool);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;mp-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wake up all suspended threads */</span></span><br><span class="line">    <span class="keyword">while</span> (!rt_list_isempty(&amp;(mp-&gt;suspend_thread)))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* disable interrupt */</span></span><br><span class="line">        temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get next suspend thread */</span></span><br><span class="line">        thread = rt_list_entry(mp-&gt;suspend_thread.next, struct rt_thread, tlist);</span><br><span class="line">        <span class="comment">/* set error code to RT_ERROR */</span></span><br><span class="line">        thread-&gt;error = -RT_ERROR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * resume thread</span></span><br><span class="line"><span class="comment">         * In rt_thread_resume function, it will remove current thread from</span></span><br><span class="line"><span class="comment">         * suspend list</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rt_thread_resume(thread);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* decrease suspended thread count */</span></span><br><span class="line">        mp-&gt;suspend_thread_count --;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* detach object */</span></span><br><span class="line">    rt_object_detach(&amp;(mp-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mp_detach);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果是靜態的，就不需要 free</li></ul><hr><h2 id="Code-allocate"><a href="#Code-allocate" class="headerlink" title="Code: allocate"></a>Code: allocate</h2><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>分配記憶體</td><td>一塊 free block</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>mp</code></th><th><code>time</code></th></tr></thead><tbody><tr><td>mempool</td><td>等待時間</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will allocate a block from memory pool</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mp the memory pool object</span></span><br><span class="line"><span class="comment"> * @param time the waiting time</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the allocated memory block or RT_NULL on allocated failed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_mp_alloc</span><span class="params">(<span class="keyword">rt_mp_t</span> mp, <span class="keyword">rt_int32_t</span> time)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_uint8_t</span> *block_ptr;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> level;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> before_sleep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get current thread */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (mp-&gt;block_free_count == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* memory block is unavailable. */</span></span><br><span class="line">        <span class="keyword">if</span> (time == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* enable interrupt */</span></span><br><span class="line">            rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line">            rt_set_errno(-RT_ETIMEOUT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> RT_NULL;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果目前無法取得記憶體，且等待時間為 0，回傳 NULL，並設置錯誤碼為 TIMEOUT</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">thread-&gt;error = RT_EOK;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* need suspend thread */</span></span><br><span class="line">rt_thread_suspend(thread);</span><br><span class="line">rt_list_insert_after(&amp;(mp-&gt;suspend_thread), &amp;(thread-&gt;tlist));</span><br><span class="line">mp-&gt;suspend_thread_count++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* get the start tick of timer */</span></span><br><span class="line">    before_sleep = rt_tick_get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init thread timer and start it */</span></span><br><span class="line">    rt_timer_control(&amp;(thread-&gt;thread_timer),</span><br><span class="line">                     RT_TIMER_CTRL_SET_TIME,</span><br><span class="line">                     &amp;time);</span><br><span class="line">    rt_timer_start(&amp;(thread-&gt;thread_timer));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果需要等待，啟動一個 timer</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* enable interrupt */</span></span><br><span class="line">rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* do a schedule */</span></span><br><span class="line">rt_schedule();</span><br></pre></td></tr></tbody></table></figure><ul><li>並做一次調度</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (thread-&gt;error != RT_EOK)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        time -= rt_tick_get() - before_sleep;</span><br><span class="line">        <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</span><br><span class="line">            time = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最後更新 time 值</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">366</span><br><span class="line">367</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* memory block is available. decrease the free block counter */</span></span><br><span class="line">mp-&gt;block_free_count--;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果可以要記憶體，更新 <code>block_free_count</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get block from block list */</span></span><br><span class="line">block_ptr = mp-&gt;block_list;</span><br><span class="line">RT_ASSERT(block_ptr != RT_NULL);</span><br></pre></td></tr></tbody></table></figure><ul><li>取得第一顆</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">371</span><br><span class="line">372</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Setup the next free node. */</span></span><br><span class="line">mp-&gt;block_list = *(<span class="keyword">rt_uint8_t</span> **)block_ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>並將 free list 往後一顆</li><li><code>block_list</code> 是使用間接定址，前 8-bit 是下一顆的位置</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">373</span><br><span class="line">374</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* point to memory pool */</span></span><br><span class="line">*(<span class="keyword">rt_uint8_t</span> **)block_ptr = (<span class="keyword">rt_uint8_t</span> *)mp;</span><br></pre></td></tr></tbody></table></figure><ul><li>接著將前 8-bit 指向原來的 mempool</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_mp_alloc_hook,</span><br><span class="line">                        (mp, (<span class="keyword">rt_uint8_t</span> *)(block_ptr + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *))));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">rt_uint8_t</span> *)(block_ptr + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *));</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mp_alloc);</span><br></pre></td></tr></tbody></table></figure><ul><li><p>最後回傳取得的 free block</p></li><li><p>注意這裡回傳的是 <code>block_ptr + 8</code>，也就是真正可以使用的位址</p></li><li><p>如果要尋找這個 block 所屬的 mempool 則需要 -8。</p></li></ul><hr><h2 id="Code-free"><a href="#Code-free" class="headerlink" title="Code: free"></a>Code: free</h2><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>*block</code></th></tr></thead><tbody><tr><td>釋放記憶體</td><td>void</td><td>所要釋放的記憶體塊</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will release a memory block</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param block the address of memory block to be released</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_mp_free</span><span class="params">(<span class="keyword">void</span> *block)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_uint8_t</span> **block_ptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mempool</span> *<span class="title">mp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get the control block of pool which the block belongs to */</span></span><br><span class="line">    block_ptr = (<span class="keyword">rt_uint8_t</span> **)((<span class="keyword">rt_uint8_t</span> *)block - <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *));</span><br><span class="line">    mp        = (struct rt_mempool *)*block_ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>首先取得所屬的 mempool（-8）</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br></pre></td><td class="code"><pre><span class="line">RT_OBJECT_HOOK_CALL(rt_mp_free_hook, (mp, block));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* disable interrupt */</span></span><br><span class="line">level = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* increase the free block count */</span></span><br><span class="line">mp-&gt;block_free_count ++;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* link the block into the block list */</span></span><br><span class="line">*block_ptr = mp-&gt;block_list;</span><br><span class="line">mp-&gt;block_list = (<span class="keyword">rt_uint8_t</span> *)block_ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>更新 <code>block_free_count</code></li><li>接著定址到 free list，重新指定 block list</li><li>也就是將此 block 插到第一顆</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (mp-&gt;suspend_thread_count &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* get the suspended thread */</span></span><br><span class="line">        thread = rt_list_entry(mp-&gt;suspend_thread.next,</span><br><span class="line">                               struct rt_thread,</span><br><span class="line">                               tlist);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* set error */</span></span><br><span class="line">        thread-&gt;error = RT_EOK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* resume thread */</span></span><br><span class="line">        rt_thread_resume(thread);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* decrease suspended thread count */</span></span><br><span class="line">        mp-&gt;suspend_thread_count --;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* do a schedule */</span></span><br><span class="line">        rt_schedule();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(level);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mp_free);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果有人在等資源，叫醒他，並做一次調度</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;使用此管理方式： &lt;code&gt;#define RT
      
    
    </summary>
    
    
      <category term="RT-Thread" scheme="http://blog.lusw.dev/categories/RT-Thread/"/>
    
    
      <category term="kernel" scheme="http://blog.lusw.dev/tags/kernel/"/>
    
      <category term="RT-Thread" scheme="http://blog.lusw.dev/tags/RT-Thread/"/>
    
      <category term="記憶體管理" scheme="http://blog.lusw.dev/tags/%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86/"/>
    
      <category term="Memory Pool" scheme="http://blog.lusw.dev/tags/Memory-Pool/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread IPC 通信</title>
    <link href="http://blog.lusw.dev/rt-ipc-2/"/>
    <id>http://blog.lusw.dev/rt-ipc-2/</id>
    <published>2018-11-28T13:11:09.000Z</published>
    <updated>2020-04-23T05:01:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Mail-Box"><a href="#Mail-Box" class="headerlink" title="Mail Box"></a>Mail Box</h2><ul><li>類似於 pipe，主要用來傳輸資料</li><li>每一封郵件大小為 4 bytes（即 32 位元）</li></ul><h3 id="結構"><a href="#結構" class="headerlink" title="結構"></a>結構</h3><div class="alert alert-success"><p><strong>File:</strong> rtdef.h</p></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MAILBOX</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mailbox structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_mailbox</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_ipc_object</span> <span class="title">parent</span>;</span>                        <span class="comment">/**&lt; inherit from ipc_object */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint32_t</span>         *msg_pool;                      <span class="comment">/**&lt; start address of message buffer */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint16_t</span>          size;                          <span class="comment">/**&lt; size of message pool */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint16_t</span>          entry;                         <span class="comment">/**&lt; index of messages in msg_pool */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span>          in_offset;                     <span class="comment">/**&lt; input offset of the message buffer */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span>          out_offset;                    <span class="comment">/**&lt; output offset of the message buffer */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_list_t</span>            suspend_sender_thread;         <span class="comment">/**&lt; sender thread suspended on this mailbox */</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_mailbox</span> *<span class="title">rt_mailbox_t</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>msg_pool</code> 指向郵件堆的起點，<code>entry</code> 紀錄總郵件的數量</li></ul><hr><div class="alert alert-success"><p><strong>File:</strong> ipc.c</p></div><h3 id="建立-mail-box"><a href="#建立-mail-box" class="headerlink" title="建立 mail box"></a>建立 mail box</h3><h4 id="動態記憶體管理"><a href="#動態記憶體管理" class="headerlink" title="動態記憶體管理"></a>動態記憶體管理</h4><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立 mail box</td><td>mail box</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*name</code></th><th><code>size</code></th><th><code>flag</code></th></tr></thead><tbody><tr><td>名字</td><td>mail box 大小</td><td>FIFO / PRIO</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will create a mailbox object from system resource</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name the name of mailbox</span></span><br><span class="line"><span class="comment"> * @param size the size of mailbox</span></span><br><span class="line"><span class="comment"> * @param flag the flag of mailbox</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the created mailbox, RT_NULL on error happen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_mailbox_t</span> rt_mb_create(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">rt_size_t</span> size, <span class="keyword">rt_uint8_t</span> flag)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_mailbox_t</span> mb;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate object */</span></span><br><span class="line">    mb = (<span class="keyword">rt_mailbox_t</span>)rt_object_allocate(RT_Object_Class_MailBox, name);</span><br><span class="line">    <span class="keyword">if</span> (mb == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> mb;</span><br></pre></td></tr></tbody></table></figure><ul><li>首先 allocate 一塊給 mailbox</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set parent */</span></span><br><span class="line">mb-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* init ipc object */</span></span><br><span class="line">rt_ipc_object_init(&amp;(mb-&gt;parent));</span><br></pre></td></tr></tbody></table></figure><ul><li>填入 flag 及初始化</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* init mailbox */</span></span><br><span class="line">mb-&gt;size     = size;</span><br><span class="line">mb-&gt;msg_pool = RT_KERNEL_MALLOC(mb-&gt;size * <span class="keyword">sizeof</span>(<span class="keyword">rt_uint32_t</span>));</span><br><span class="line"><span class="keyword">if</span> (mb-&gt;msg_pool == RT_NULL)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* delete mailbox object */</span></span><br><span class="line">    rt_object_delete(&amp;(mb-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>因使用動態記憶體的緣故，需 allocate 一塊給郵件堆</li><li>大小為一封一件的大小 * size</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br></pre></td><td class="code"><pre><span class="line">    mb-&gt;entry      = <span class="number">0</span>;</span><br><span class="line">    mb-&gt;in_offset  = <span class="number">0</span>;</span><br><span class="line">    mb-&gt;out_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init an additional list of sender suspend thread */</span></span><br><span class="line">    rt_list_init(&amp;(mb-&gt;suspend_sender_thread));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mb;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mb_create);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後初始化值及等待鏈</li></ul><hr><h4 id="靜態記憶體管理"><a href="#靜態記憶體管理" class="headerlink" title="靜態記憶體管理"></a>靜態記憶體管理</h4><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 mail box</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>mb</code></th><th><code>*name</code></th><th><code>*msgpool</code></th><th><code>size</code></th><th><code>flag</code></th></tr></thead><tbody><tr><td>mail box 本體</td><td>名字</td><td>存放郵件的地方</td><td>mail box 大小</td><td>FIFO / PRIO</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will initialize a mailbox and put it under control of resource</span></span><br><span class="line"><span class="comment"> * management.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mb the mailbox object</span></span><br><span class="line"><span class="comment"> * @param name the name of mailbox</span></span><br><span class="line"><span class="comment"> * @param msgpool the begin address of buffer to save received mail</span></span><br><span class="line"><span class="comment"> * @param size the size of mailbox</span></span><br><span class="line"><span class="comment"> * @param flag the flag of mailbox</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mb_init(<span class="keyword">rt_mailbox_t</span> mb,</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">char</span>  *name,</span><br><span class="line">                    <span class="keyword">void</span>        *msgpool,</span><br><span class="line">                    <span class="keyword">rt_size_t</span>    size,</span><br><span class="line">                    <span class="keyword">rt_uint8_t</span>   flag)</span><br><span class="line">{</span><br><span class="line">    RT_ASSERT(mb != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init object */</span></span><br><span class="line">    rt_object_init(&amp;(mb-&gt;parent.parent), RT_Object_Class_MailBox, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set parent flag */</span></span><br><span class="line">    mb-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init ipc object */</span></span><br><span class="line">    rt_ipc_object_init(&amp;(mb-&gt;parent));</span><br></pre></td></tr></tbody></table></figure><ul><li>這裡就不需要 allocate，可直接初始化來使用</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* init mailbox */</span></span><br><span class="line">    mb-&gt;msg_pool   = msgpool;</span><br><span class="line">    mb-&gt;size       = size;</span><br><span class="line">    mb-&gt;entry      = <span class="number">0</span>;</span><br><span class="line">    mb-&gt;in_offset  = <span class="number">0</span>;</span><br><span class="line">    mb-&gt;out_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init an additional list of sender suspend thread */</span></span><br><span class="line">    rt_list_init(&amp;(mb-&gt;suspend_sender_thread));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mb_init);</span><br></pre></td></tr></tbody></table></figure><ul><li>一樣，郵件堆可直接拿來用，初始化值及等待鏈</li></ul><hr><h3 id="刪除-mail-box"><a href="#刪除-mail-box" class="headerlink" title="刪除 mail box"></a>刪除 mail box</h3><h4 id="動態記憶體管理-1"><a href="#動態記憶體管理-1" class="headerlink" title="動態記憶體管理"></a>動態記憶體管理</h4><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>mb</code></th></tr></thead><tbody><tr><td>刪除 mail box</td><td><code>RT_EOK</code></td><td>欲刪除的 mail box</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will delete a mailbox object and release the memory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mb the mailbox object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mb_delete(<span class="keyword">rt_mailbox_t</span> mb)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mb != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mb-&gt;parent.parent) == RT_Object_Class_MailBox);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;mb-&gt;parent.parent) == RT_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resume all suspended thread */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(mb-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* also resume all mailbox private suspended thread */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(mb-&gt;suspend_sender_thread));</span><br></pre></td></tr></tbody></table></figure><ul><li>首先將正在等待郵件的，與正在等待傳送的 thread 叫醒</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* free mailbox pool */</span></span><br><span class="line">    RT_KERNEL_FREE(mb-&gt;msg_pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* delete mailbox object */</span></span><br><span class="line">    rt_object_delete(&amp;(mb-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mb_delete);</span><br></pre></td></tr></tbody></table></figure><ul><li>歸還郵件堆，最後刪除 mail box</li></ul><hr><h4 id="靜態記憶體管理-1"><a href="#靜態記憶體管理-1" class="headerlink" title="靜態記憶體管理"></a>靜態記憶體管理</h4><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>mb</code></th></tr></thead><tbody><tr><td>刪除 mail box</td><td><code>RT_EOK</code></td><td>欲刪除的 mail box</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will detach a mailbox from resource management</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mb the mailbox object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mb_detach(<span class="keyword">rt_mailbox_t</span> mb)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mb != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mb-&gt;parent.parent) == RT_Object_Class_MailBox);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;mb-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resume all suspended thread */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(mb-&gt;parent.suspend_thread));</span><br><span class="line">    <span class="comment">/* also resume all mailbox private suspended thread */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(mb-&gt;suspend_sender_thread));</span><br></pre></td></tr></tbody></table></figure><ul><li>首先將正在等待郵件的，與正在等待傳送的 thread 叫醒</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* detach mailbox object */</span></span><br><span class="line">    rt_object_detach(&amp;(mb-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mb_detach);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後刪除 mail box（使用 <code>detach</code>）</li></ul><hr><h3 id="傳送郵件"><a href="#傳送郵件" class="headerlink" title="傳送郵件"></a>傳送郵件</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>傳送郵件</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>mb</code></th><th><code>value</code></th><th><code>timeout</code></th></tr></thead><tbody><tr><td>欲傳送的 mailbox</td><td>郵件內容</td><td>等待時間（如果需要）</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will send a mail to mailbox object. If the mailbox is full,</span></span><br><span class="line"><span class="comment"> * current thread will be suspended until timeout.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mb the mailbox object</span></span><br><span class="line"><span class="comment"> * @param value the mail</span></span><br><span class="line"><span class="comment"> * @param timeout the waiting time</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mb_send_wait(<span class="keyword">rt_mailbox_t</span> mb,</span><br><span class="line">                         <span class="keyword">rt_uint32_t</span>  value,</span><br><span class="line">                         <span class="keyword">rt_int32_t</span>   timeout)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> temp;</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> tick_delta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mb != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mb-&gt;parent.parent) == RT_Object_Class_MailBox);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize delta tick */</span></span><br><span class="line">    tick_delta = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* get current thread */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&amp;(mb-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* for non-blocking call */</span></span><br><span class="line">    <span class="keyword">if</span> (mb-&gt;entry == mb-&gt;size &amp;&amp; timeout == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -RT_EFULL;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* mailbox is full */</span></span><br><span class="line">    <span class="keyword">while</span> (mb-&gt;entry == mb-&gt;size)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* reset error number in thread */</span></span><br><span class="line">        thread-&gt;error = RT_EOK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* no waiting, return timeout */</span></span><br><span class="line">        <span class="keyword">if</span> (timeout == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* enable interrupt */</span></span><br><span class="line">            rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> -RT_EFULL;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 mail box 滿了，且不等待 (<code>timeout==0</code>)，回傳 <code>FULL</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_IN_THREAD_CONTEXT;</span><br><span class="line"><span class="comment">/* suspend current thread */</span></span><br><span class="line">rt_ipc_list_suspend(&amp;(mb-&gt;suspend_sender_thread),</span><br><span class="line">                    thread,</span><br><span class="line">                    mb-&gt;parent.parent.flag);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* has waiting time, start thread timer */</span></span><br><span class="line"><span class="keyword">if</span> (timeout &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* get the start tick of timer */</span></span><br><span class="line">    tick_delta = rt_tick_get();</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_IPC, (<span class="string">"mb_send_wait: start timer of thread:%s\n"</span>,</span><br><span class="line">                                thread-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset the timeout of thread timer and start it */</span></span><br><span class="line">    rt_timer_control(&amp;(thread-&gt;thread_timer),</span><br><span class="line">                     RT_TIMER_CTRL_SET_TIME,</span><br><span class="line">                     &amp;timeout);</span><br><span class="line">    rt_timer_start(&amp;(thread-&gt;thread_timer));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>若要等待，將 thread 掛上等待鏈，啟動一個 timer</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* enable interrupt */</span></span><br><span class="line">rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* re-schedule */</span></span><br><span class="line">rt_schedule();</span><br></pre></td></tr></tbody></table></figure><ul><li>再做一次調度</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* resume from suspend state */</span></span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;error != RT_EOK)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* return error */</span></span><br><span class="line">        <span class="keyword">return</span> thread-&gt;error;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if it's not waiting forever and then re-calculate timeout tick */</span></span><br><span class="line">    <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        tick_delta = rt_tick_get() - tick_delta;</span><br><span class="line">        timeout -= tick_delta;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">            timeout = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如跳回來，重新計算 <code>timeout</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set ptr */</span></span><br><span class="line">mb-&gt;msg_pool[mb-&gt;in_offset] = value;</span><br><span class="line"><span class="comment">/* increase input offset */</span></span><br><span class="line">++ mb-&gt;in_offset;</span><br><span class="line"><span class="keyword">if</span> (mb-&gt;in_offset &gt;= mb-&gt;size)</span><br><span class="line">    mb-&gt;in_offset = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* increase message entry */</span></span><br><span class="line">mb-&gt;entry ++;</span><br></pre></td></tr></tbody></table></figure><ul><li>若可以寫入，將資料寫入，同時更新 <code>offset</code> 及 <code>entry</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* resume suspended thread */</span></span><br><span class="line">    <span class="keyword">if</span> (!rt_list_isempty(&amp;mb-&gt;parent.suspend_thread))</span><br><span class="line">    {</span><br><span class="line">        rt_ipc_list_resume(&amp;(mb-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        rt_schedule();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_EOK;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mb_send_wait);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果有人在等待寄信，叫醒他，做一次調度</li></ul><hr><ul><li>若是不想等待，可以使用 <code>rt_mb_send</code></li></ul><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>傳送郵件（不等待）</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>mb</code></th><th><code>value</code></th></tr></thead><tbody><tr><td>欲傳送的 mailbox</td><td>郵件內容</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will send a mail to mailbox object, if there are threads</span></span><br><span class="line"><span class="comment"> * suspended on mailbox object, it will be waked up. This function will return</span></span><br><span class="line"><span class="comment"> * immediately, if you want blocking send, use rt_mb_send_wait instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mb the mailbox object</span></span><br><span class="line"><span class="comment"> * @param value the mail</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mb_send(<span class="keyword">rt_mailbox_t</span> mb, <span class="keyword">rt_uint32_t</span> value)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> rt_mb_send_wait(mb, value, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mb_send);</span><br></pre></td></tr></tbody></table></figure><ul><li>即 <code>timeout == 0</code></li></ul><hr><h3 id="接受郵件"><a href="#接受郵件" class="headerlink" title="接受郵件"></a>接受郵件</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>接受郵件</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>mb</code></th><th><code>*value</code></th><th><code>timeout</code></th></tr></thead><tbody><tr><td>欲收信的 mailbox</td><td>郵件內容</td><td>等待時間（如果需要）</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will receive a mail from mailbox object, if there is no mail</span></span><br><span class="line"><span class="comment"> * in mailbox object, the thread shall wait for a specified time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mb the mailbox object</span></span><br><span class="line"><span class="comment"> * @param value the received mail will be saved in</span></span><br><span class="line"><span class="comment"> * @param timeout the waiting time</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mb_recv(<span class="keyword">rt_mailbox_t</span> mb, <span class="keyword">rt_uint32_t</span> *value, <span class="keyword">rt_int32_t</span> timeout)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> temp;</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> tick_delta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mb != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mb-&gt;parent.parent) == RT_Object_Class_MailBox);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize delta tick */</span></span><br><span class="line">    tick_delta = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* get current thread */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&amp;(mb-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* for non-blocking call */</span></span><br><span class="line">    <span class="keyword">if</span> (mb-&gt;entry == <span class="number">0</span> &amp;&amp; timeout == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -RT_ETIMEOUT;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* mailbox is empty */</span></span><br><span class="line">    <span class="keyword">while</span> (mb-&gt;entry == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* reset error number in thread */</span></span><br><span class="line">        thread-&gt;error = RT_EOK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* no waiting, return timeout */</span></span><br><span class="line">        <span class="keyword">if</span> (timeout == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* enable interrupt */</span></span><br><span class="line">            rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">            thread-&gt;error = -RT_ETIMEOUT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> -RT_ETIMEOUT;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 mail box 沒東西，且不等待，回傳 <code>TIMEOUT</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_IN_THREAD_CONTEXT;</span><br><span class="line"><span class="comment">/* suspend current thread */</span></span><br><span class="line">rt_ipc_list_suspend(&amp;(mb-&gt;parent.suspend_thread),</span><br><span class="line">                    thread,</span><br><span class="line">                    mb-&gt;parent.parent.flag);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* has waiting time, start thread timer */</span></span><br><span class="line"><span class="keyword">if</span> (timeout &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* get the start tick of timer */</span></span><br><span class="line">    tick_delta = rt_tick_get();</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_IPC, (<span class="string">"mb_recv: start timer of thread:%s\n"</span>,</span><br><span class="line">                                thread-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset the timeout of thread timer and start it */</span></span><br><span class="line">    rt_timer_control(&amp;(thread-&gt;thread_timer),</span><br><span class="line">                     RT_TIMER_CTRL_SET_TIME,</span><br><span class="line">                     &amp;timeout);</span><br><span class="line">    rt_timer_start(&amp;(thread-&gt;thread_timer));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>若要等待，將 thread 掛上等待鏈，啟動一個 timer</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* enable interrupt */</span></span><br><span class="line">rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* re-schedule */</span></span><br><span class="line">rt_schedule();</span><br></pre></td></tr></tbody></table></figure><ul><li>再做一次調度</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* resume from suspend state */</span></span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;error != RT_EOK)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* return error */</span></span><br><span class="line">        <span class="keyword">return</span> thread-&gt;error;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if it's not waiting forever and then re-calculate timeout tick */</span></span><br><span class="line">    <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        tick_delta = rt_tick_get() - tick_delta;</span><br><span class="line">        timeout -= tick_delta;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">            timeout = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如跳回來，重新計算 <code>timeout</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fill ptr */</span></span><br><span class="line">*value = mb-&gt;msg_pool[mb-&gt;out_offset];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* increase output offset */</span></span><br><span class="line">++ mb-&gt;out_offset;</span><br><span class="line"><span class="keyword">if</span> (mb-&gt;out_offset &gt;= mb-&gt;size)</span><br><span class="line">    mb-&gt;out_offset = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* decrease message entry */</span></span><br><span class="line">mb-&gt;entry --;</span><br></pre></td></tr></tbody></table></figure><ul><li>若可以讀取，將資料寫入，同時更新 <code>offset</code> 及 <code>entry</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* resume suspended thread */</span></span><br><span class="line">    <span class="keyword">if</span> (!rt_list_isempty(&amp;(mb-&gt;suspend_sender_thread)))</span><br><span class="line">    {</span><br><span class="line">        rt_ipc_list_resume(&amp;(mb-&gt;suspend_sender_thread));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&amp;(mb-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">        rt_schedule();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_EOK;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&amp;(mb-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mb_recv);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果有人在等待收信，叫醒他，做一次調度</li></ul><hr><h2 id="Message-Queue"><a href="#Message-Queue" class="headerlink" title="Message Queue"></a>Message Queue</h2><ul><li>特性：可接受不固定長度的訊息</li></ul><h3 id="結構-1"><a href="#結構-1" class="headerlink" title="結構"></a>結構</h3><div class="alert alert-success"><p><strong>File:</strong> rtdef.h</p></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MESSAGEQUEUE</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * message queue structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_messagequeue</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_ipc_object</span> <span class="title">parent</span>;</span>                        <span class="comment">/**&lt; inherit from ipc_object */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>                *msg_pool;                      <span class="comment">/**&lt; start address of message queue */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint16_t</span>          msg_size;                      <span class="comment">/**&lt; message size of each message */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span>          max_msgs;                      <span class="comment">/**&lt; max number of messages */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint16_t</span>          entry;                         <span class="comment">/**&lt; index of messages in the queue */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>                *msg_queue_head;                <span class="comment">/**&lt; list head */</span></span><br><span class="line">    <span class="keyword">void</span>                *msg_queue_tail;                <span class="comment">/**&lt; list tail */</span></span><br><span class="line">    <span class="keyword">void</span>                *msg_queue_free;                <span class="comment">/**&lt; pointer indicated the free node of queue */</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_messagequeue</span> *<span class="title">rt_mq_t</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><hr><div class="alert alert-success"><p><strong>File:</strong> ipc.c</p></div><h3 id="建立-message-queue"><a href="#建立-message-queue" class="headerlink" title="建立 message queue"></a>建立 message queue</h3><h4 id="動態記憶體管理-2"><a href="#動態記憶體管理-2" class="headerlink" title="動態記憶體管理"></a>動態記憶體管理</h4><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立 message queue</td><td>message queue</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>*name</code></th><th><code>msg_size</code></th><th><code>max_msgs</code></th><th><code>flag</code></th></tr></thead><tbody><tr><td>名字</td><td>一封訊息的大小</td><td>訊息數上限</td><td>FIFO / PRIO</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1852</span><br><span class="line">1853</span><br><span class="line">1854</span><br><span class="line">1855</span><br><span class="line">1856</span><br><span class="line">1857</span><br><span class="line">1858</span><br><span class="line">1859</span><br><span class="line">1860</span><br><span class="line">1861</span><br><span class="line">1862</span><br><span class="line">1863</span><br><span class="line">1864</span><br><span class="line">1865</span><br><span class="line">1866</span><br><span class="line">1867</span><br><span class="line">1868</span><br><span class="line">1869</span><br><span class="line">1870</span><br><span class="line">1871</span><br><span class="line">1872</span><br><span class="line">1873</span><br><span class="line">1874</span><br><span class="line">1875</span><br><span class="line">1876</span><br><span class="line">1877</span><br><span class="line">1878</span><br><span class="line">1879</span><br><span class="line">1880</span><br><span class="line">1881</span><br><span class="line">1882</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will create a message queue object from system resource</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name the name of message queue</span></span><br><span class="line"><span class="comment"> * @param msg_size the size of message</span></span><br><span class="line"><span class="comment"> * @param max_msgs the maximum number of message in queue</span></span><br><span class="line"><span class="comment"> * @param flag the flag of message queue</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the created message queue, RT_NULL on error happen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_mq_t</span> rt_mq_create(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">                     <span class="keyword">rt_size_t</span>   msg_size,</span><br><span class="line">                     <span class="keyword">rt_size_t</span>   max_msgs,</span><br><span class="line">                     <span class="keyword">rt_uint8_t</span>  flag)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_messagequeue</span> *<span class="title">mq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mq_message</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate object */</span></span><br><span class="line">    mq = (<span class="keyword">rt_mq_t</span>)rt_object_allocate(RT_Object_Class_MessageQueue, name);</span><br><span class="line">    <span class="keyword">if</span> (mq == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> mq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set parent */</span></span><br><span class="line">    mq-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init ipc object */</span></span><br><span class="line">    rt_ipc_object_init(&amp;(mq-&gt;parent));</span><br></pre></td></tr></tbody></table></figure><ul><li>首先要一塊物件給 message queue，並同時填入 flag 及初始化</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1883</span><br><span class="line">1884</span><br><span class="line">1885</span><br><span class="line">1886</span><br><span class="line">1887</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* init message queue */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* get correct message size */</span></span><br><span class="line">mq-&gt;msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);</span><br><span class="line">mq-&gt;max_msgs = max_msgs;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定訊息的大小，與訊息數量的上限</li></ul><div class="alert alert-info"><p><code>RT_ALGIN</code> 目的在對齊訊息的大小，根據不同板子所定義不同的 <code>RT_ALIGN_SIZE</code> 會有所差別<br><br><code>#define RT_ALIGN(size, align)           (((size) + (align) - 1) &amp; ~((align) - 1))</code></p><ul><li>如傳進來的是 <code>RT_ALGIN(7,8)</code> 則結果是 8</li><li>如傳進來的是 <code>RT_ALGIN(13,4)</code> 則結果是 16</li><li>即結果為大於後值的<strong>最小倍數</strong></li></ul></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1888</span><br><span class="line">1889</span><br><span class="line">1890</span><br><span class="line">1891</span><br><span class="line">1892</span><br><span class="line">1893</span><br><span class="line">1894</span><br><span class="line">1895</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* allocate message pool */</span></span><br><span class="line">mq-&gt;msg_pool = RT_KERNEL_MALLOC((mq-&gt;msg_size + <span class="keyword">sizeof</span>(struct rt_mq_message)) * mq-&gt;max_msgs);</span><br><span class="line"><span class="keyword">if</span> (mq-&gt;msg_pool == RT_NULL)</span><br><span class="line">{</span><br><span class="line">    rt_mq_delete(mq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著需 allocate 適當的記憶體存放訊息</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1896</span><br><span class="line">1897</span><br><span class="line">1898</span><br><span class="line">1899</span><br><span class="line">1900</span><br><span class="line">1901</span><br><span class="line">1902</span><br><span class="line">1903</span><br><span class="line">1904</span><br><span class="line">1905</span><br><span class="line">1906</span><br><span class="line">1907</span><br><span class="line">1908</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* init message list */</span></span><br><span class="line">mq-&gt;msg_queue_head = RT_NULL;</span><br><span class="line">mq-&gt;msg_queue_tail = RT_NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* init message empty list */</span></span><br><span class="line">mq-&gt;msg_queue_free = RT_NULL;</span><br><span class="line"><span class="keyword">for</span> (temp = <span class="number">0</span>; temp &lt; mq-&gt;max_msgs; temp ++)</span><br><span class="line">{</span><br><span class="line">    head = (struct rt_mq_message *)((<span class="keyword">rt_uint8_t</span> *)mq-&gt;msg_pool +</span><br><span class="line">                                    temp * (mq-&gt;msg_size + <span class="keyword">sizeof</span>(struct rt_mq_message)));</span><br><span class="line">    head-&gt;next = mq-&gt;msg_queue_free;</span><br><span class="line">    mq-&gt;msg_queue_free = head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>先將頭尾設為空，再一塊一塊的將 <code>msg_pool</code> 插在 free list 的第一顆</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1909</span><br><span class="line">1910</span><br><span class="line">1911</span><br><span class="line">1912</span><br><span class="line">1913</span><br><span class="line">1914</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* the initial entry is zero */</span></span><br><span class="line">    mq-&gt;entry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mq;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mq_create);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後設定 <code>entry</code> 為 0</li></ul><hr><h4 id="靜態記憶體管理-2"><a href="#靜態記憶體管理-2" class="headerlink" title="靜態記憶體管理"></a>靜態記憶體管理</h4><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 message queue</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>mq</code></th><th><code>*name</code></th><th><code>*msgpool</code></th></tr></thead><tbody><tr><td>message queue 本體</td><td>名字</td><td>存放訊息的位址</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>msg_size</code></th><th><code>pool_size</code></th><th><code>flag</code></th></tr></thead><tbody><tr><td>一封訊息的大小</td><td>存放訊息的大小</td><td>FIFO / PRIO</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br><span class="line">1786</span><br><span class="line">1787</span><br><span class="line">1788</span><br><span class="line">1789</span><br><span class="line">1790</span><br><span class="line">1791</span><br><span class="line">1792</span><br><span class="line">1793</span><br><span class="line">1794</span><br><span class="line">1795</span><br><span class="line">1796</span><br><span class="line">1797</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will initialize a message queue and put it under control of</span></span><br><span class="line"><span class="comment"> * resource management.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mq the message object</span></span><br><span class="line"><span class="comment"> * @param name the name of message queue</span></span><br><span class="line"><span class="comment"> * @param msgpool the beginning address of buffer to save messages</span></span><br><span class="line"><span class="comment"> * @param msg_size the maximum size of message</span></span><br><span class="line"><span class="comment"> * @param pool_size the size of buffer to save messages</span></span><br><span class="line"><span class="comment"> * @param flag the flag of message queue</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mq_init(<span class="keyword">rt_mq_t</span>     mq,</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">                    <span class="keyword">void</span>       *msgpool,</span><br><span class="line">                    <span class="keyword">rt_size_t</span>   msg_size,</span><br><span class="line">                    <span class="keyword">rt_size_t</span>   pool_size,</span><br><span class="line">                    <span class="keyword">rt_uint8_t</span>  flag)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mq_message</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mq != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init object */</span></span><br><span class="line">    rt_object_init(&amp;(mq-&gt;parent.parent), RT_Object_Class_MessageQueue, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set parent flag */</span></span><br><span class="line">    mq-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init ipc object */</span></span><br><span class="line">    rt_ipc_object_init(&amp;(mq-&gt;parent));</span><br></pre></td></tr></tbody></table></figure><ul><li>這裡就不需要去要一塊物件，直接拿來用即可</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1798</span><br><span class="line">1799</span><br><span class="line">1800</span><br><span class="line">1801</span><br><span class="line">1802</span><br><span class="line">1803</span><br><span class="line">1804</span><br><span class="line">1805</span><br><span class="line">1806</span><br><span class="line">1807</span><br><span class="line">1808</span><br><span class="line">1809</span><br><span class="line">1810</span><br><span class="line">1811</span><br><span class="line">1812</span><br><span class="line">1813</span><br><span class="line">1814</span><br><span class="line">1815</span><br><span class="line">1816</span><br><span class="line">1817</span><br><span class="line">1818</span><br><span class="line">1819</span><br><span class="line">1820</span><br><span class="line">1821</span><br><span class="line">1822</span><br><span class="line">1823</span><br><span class="line">1824</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* set messasge pool */</span></span><br><span class="line">    mq-&gt;msg_pool = msgpool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get correct message size */</span></span><br><span class="line">    mq-&gt;msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);</span><br><span class="line">    mq-&gt;max_msgs = pool_size / (mq-&gt;msg_size + <span class="keyword">sizeof</span>(struct rt_mq_message));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init message list */</span></span><br><span class="line">    mq-&gt;msg_queue_head = RT_NULL;</span><br><span class="line">    mq-&gt;msg_queue_tail = RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init message empty list */</span></span><br><span class="line">    mq-&gt;msg_queue_free = RT_NULL;</span><br><span class="line">    <span class="keyword">for</span> (temp = <span class="number">0</span>; temp &lt; mq-&gt;max_msgs; temp ++)</span><br><span class="line">    {</span><br><span class="line">        head = (struct rt_mq_message *)((<span class="keyword">rt_uint8_t</span> *)mq-&gt;msg_pool +</span><br><span class="line">                                        temp * (mq-&gt;msg_size + <span class="keyword">sizeof</span>(struct rt_mq_message)));</span><br><span class="line">        head-&gt;next = mq-&gt;msg_queue_free;</span><br><span class="line">        mq-&gt;msg_queue_free = head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the initial entry is zero */</span></span><br><span class="line">    mq-&gt;entry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mq_init);</span><br></pre></td></tr></tbody></table></figure><ul><li>其餘的動作皆與上面相同</li></ul><hr><h3 id="刪除-message-queue"><a href="#刪除-message-queue" class="headerlink" title="刪除 message queue"></a>刪除 message queue</h3><h4 id="動態記憶體管理-3"><a href="#動態記憶體管理-3" class="headerlink" title="動態記憶體管理"></a>動態記憶體管理</h4><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>mq</code></th></tr></thead><tbody><tr><td>刪除 message queue</td><td><code>RT_EOK</code></td><td>欲刪除的 message queue</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1920</span><br><span class="line">1921</span><br><span class="line">1922</span><br><span class="line">1923</span><br><span class="line">1924</span><br><span class="line">1925</span><br><span class="line">1926</span><br><span class="line">1927</span><br><span class="line">1928</span><br><span class="line">1929</span><br><span class="line">1930</span><br><span class="line">1931</span><br><span class="line">1932</span><br><span class="line">1933</span><br><span class="line">1934</span><br><span class="line">1935</span><br><span class="line">1936</span><br><span class="line">1937</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will delete a message queue object and release the memory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mq the message queue object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mq_delete(<span class="keyword">rt_mq_t</span> mq)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mq != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mq-&gt;parent.parent) == RT_Object_Class_MessageQueue);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;mq-&gt;parent.parent) == RT_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resume all suspended thread */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(mq-&gt;parent.suspend_thread));</span><br></pre></td></tr></tbody></table></figure><ul><li>先把正在等待收訊息的 thread 叫醒</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1938</span><br><span class="line">1939</span><br><span class="line">1940</span><br><span class="line">1941</span><br><span class="line">1942</span><br><span class="line">1943</span><br><span class="line">1944</span><br><span class="line">1945</span><br><span class="line">1946</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* free message queue pool */</span></span><br><span class="line">    RT_KERNEL_FREE(mq-&gt;msg_pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* delete message queue object */</span></span><br><span class="line">    rt_object_delete(&amp;(mq-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mq_delete);</span><br></pre></td></tr></tbody></table></figure><ul><li>接著 free <code>msg_pool</code>，並刪除物件</li></ul><hr><h4 id="靜態記憶體管理-3"><a href="#靜態記憶體管理-3" class="headerlink" title="靜態記憶體管理"></a>靜態記憶體管理</h4><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th><th><code>mq</code></th></tr></thead><tbody><tr><td>刪除 message queue</td><td><code>RT_EOK</code></td><td>欲刪除的 message queue</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1827</span><br><span class="line">1828</span><br><span class="line">1829</span><br><span class="line">1830</span><br><span class="line">1831</span><br><span class="line">1832</span><br><span class="line">1833</span><br><span class="line">1834</span><br><span class="line">1835</span><br><span class="line">1836</span><br><span class="line">1837</span><br><span class="line">1838</span><br><span class="line">1839</span><br><span class="line">1840</span><br><span class="line">1841</span><br><span class="line">1842</span><br><span class="line">1843</span><br><span class="line">1844</span><br><span class="line">1845</span><br><span class="line">1846</span><br><span class="line">1847</span><br><span class="line">1848</span><br><span class="line">1849</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will detach a message queue object from resource management</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mq the message queue object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mq_detach(<span class="keyword">rt_mq_t</span> mq)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mq != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mq-&gt;parent.parent) == RT_Object_Class_MessageQueue);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;mq-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resume all suspended thread */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;mq-&gt;parent.suspend_thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* detach message queue object */</span></span><br><span class="line">    rt_object_detach(&amp;(mq-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mq_detach);</span><br></pre></td></tr></tbody></table></figure><ul><li>這裡的 <code>msg_pool</code> 就不需要 free</li></ul><hr><h3 id="傳送訊息"><a href="#傳送訊息" class="headerlink" title="傳送訊息"></a>傳送訊息</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>傳送訊息</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>mq</code></th><th><code>*buffer</code></th><th><code>size</code></th></tr></thead><tbody><tr><td>欲傳送的 message queue</td><td>訊息資料</td><td>訊息大小</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1950</span><br><span class="line">1951</span><br><span class="line">1952</span><br><span class="line">1953</span><br><span class="line">1954</span><br><span class="line">1955</span><br><span class="line">1956</span><br><span class="line">1957</span><br><span class="line">1958</span><br><span class="line">1959</span><br><span class="line">1960</span><br><span class="line">1961</span><br><span class="line">1962</span><br><span class="line">1963</span><br><span class="line">1964</span><br><span class="line">1965</span><br><span class="line">1966</span><br><span class="line">1967</span><br><span class="line">1968</span><br><span class="line">1969</span><br><span class="line">1970</span><br><span class="line">1971</span><br><span class="line">1972</span><br><span class="line">1973</span><br><span class="line">1974</span><br><span class="line">1975</span><br><span class="line">1976</span><br><span class="line">1977</span><br><span class="line">1978</span><br><span class="line">1979</span><br><span class="line">1980</span><br><span class="line">1981</span><br><span class="line">1982</span><br><span class="line">1983</span><br><span class="line">1984</span><br><span class="line">1985</span><br><span class="line">1986</span><br><span class="line">1987</span><br><span class="line">1988</span><br><span class="line">1989</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will send a message to message queue object, if there are</span></span><br><span class="line"><span class="comment"> * threads suspended on message queue object, it will be waked up.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mq the message queue object</span></span><br><span class="line"><span class="comment"> * @param buffer the message</span></span><br><span class="line"><span class="comment"> * @param size the size of buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mq_send(<span class="keyword">rt_mq_t</span> mq, <span class="keyword">void</span> *buffer, <span class="keyword">rt_size_t</span> size)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> temp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mq_message</span> *<span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mq != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mq-&gt;parent.parent) == RT_Object_Class_MessageQueue);</span><br><span class="line">    RT_ASSERT(buffer != RT_NULL);</span><br><span class="line">    RT_ASSERT(size != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* greater than one message size */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; mq-&gt;msg_size)</span><br><span class="line">        <span class="keyword">return</span> -RT_ERROR;</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&amp;(mq-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get a free list, there must be an empty item */</span></span><br><span class="line">    msg = (struct rt_mq_message *)mq-&gt;msg_queue_free;</span><br><span class="line">    <span class="comment">/* message queue is full */</span></span><br><span class="line">    <span class="keyword">if</span> (msg == RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -RT_EFULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>首先確定 message queue 沒滿（即 free list 不為空）</li><li>如果滿了，回傳 <code>FULL</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1990</span><br><span class="line">1991</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* move free list pointer */</span></span><br><span class="line">mq-&gt;msg_queue_free = msg-&gt;next;</span><br></pre></td></tr></tbody></table></figure><ul><li>接著 free list 往下一顆走</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1992</span><br><span class="line">1993</span><br><span class="line">1994</span><br><span class="line">1995</span><br><span class="line">1996</span><br><span class="line">1997</span><br><span class="line">1998</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* enable interrupt */</span></span><br><span class="line">rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the msg is the new tailer of list, the next shall be NULL */</span></span><br><span class="line">msg-&gt;next = RT_NULL;</span><br><span class="line"><span class="comment">/* copy buffer */</span></span><br><span class="line">rt_memcpy(msg + <span class="number">1</span>, buffer, size);</span><br></pre></td></tr></tbody></table></figure><ul><li>將訊息填入從 free list 拿的一顆（<code>msg</code>），這顆待會是新的尾巴（設定 <code>next = NULL</code>）</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1999</span><br><span class="line">2000</span><br><span class="line">2001</span><br><span class="line">2002</span><br><span class="line">2003</span><br><span class="line">2004</span><br><span class="line">2005</span><br><span class="line">2006</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* disable interrupt */</span></span><br><span class="line">temp = rt_hw_interrupt_disable();</span><br><span class="line"><span class="comment">/* link msg to message queue */</span></span><br><span class="line"><span class="keyword">if</span> (mq-&gt;msg_queue_tail != RT_NULL)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* if the tail exists, */</span></span><br><span class="line">    ((struct rt_mq_message *)mq-&gt;msg_queue_tail)-&gt;next = msg;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果尾巴不為空（也就是 message queue 有東西），將原本的尾巴指向 <code>msg</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">2007</span><br><span class="line">2008</span><br><span class="line">2009</span><br><span class="line">2010</span><br><span class="line">2011</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set new tail */</span></span><br><span class="line">mq-&gt;msg_queue_tail = msg;</span><br><span class="line"><span class="comment">/* if the head is empty, set head */</span></span><br><span class="line"><span class="keyword">if</span> (mq-&gt;msg_queue_head == RT_NULL)</span><br><span class="line">    mq-&gt;msg_queue_head = msg;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定新的尾巴</li><li>如果頭為空（也就是 message queue 為空），設定新的頭</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">2012</span><br><span class="line">2013</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* increase message entry */</span></span><br><span class="line">mq-&gt;entry ++;</span><br></pre></td></tr></tbody></table></figure><ul><li>最後更新 <code>entry</code> </li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">2014</span><br><span class="line">2015</span><br><span class="line">2016</span><br><span class="line">2017</span><br><span class="line">2018</span><br><span class="line">2019</span><br><span class="line">2020</span><br><span class="line">2021</span><br><span class="line">2022</span><br><span class="line">2023</span><br><span class="line">2024</span><br><span class="line">2025</span><br><span class="line">2026</span><br><span class="line">2027</span><br><span class="line">2028</span><br><span class="line">2029</span><br><span class="line">2030</span><br><span class="line">2031</span><br><span class="line">2032</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* resume suspended thread */</span></span><br><span class="line">    <span class="keyword">if</span> (!rt_list_isempty(&amp;mq-&gt;parent.suspend_thread))</span><br><span class="line">    {</span><br><span class="line">        rt_ipc_list_resume(&amp;(mq-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        rt_schedule();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_EOK;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mq_send);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果有人在等待接收訊息，叫醒他</li></ul><hr><h4 id="傳送緊急訊息"><a href="#傳送緊急訊息" class="headerlink" title="傳送緊急訊息"></a>傳送緊急訊息</h4><ul><li>與上面不同的是：這裡將新訊息插入<strong>第一顆</strong></li></ul><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>傳送緊急訊息</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>mq</code></th><th><code>*buffer</code></th><th><code>size</code></th></tr></thead><tbody><tr><td>欲傳送的 message queue</td><td>訊息資料</td><td>訊息大小</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">2039</span><br><span class="line">2040</span><br><span class="line">2041</span><br><span class="line">2042</span><br><span class="line">2043</span><br><span class="line">2044</span><br><span class="line">2045</span><br><span class="line">2046</span><br><span class="line">2047</span><br><span class="line">2048</span><br><span class="line">2049</span><br><span class="line">2050</span><br><span class="line">2051</span><br><span class="line">2052</span><br><span class="line">2053</span><br><span class="line">2054</span><br><span class="line">2055</span><br><span class="line">2056</span><br><span class="line">2057</span><br><span class="line">2058</span><br><span class="line">2059</span><br><span class="line">2060</span><br><span class="line">2061</span><br><span class="line">2062</span><br><span class="line">2063</span><br><span class="line">2064</span><br><span class="line">2065</span><br><span class="line">2066</span><br><span class="line">2067</span><br><span class="line">2068</span><br><span class="line">2069</span><br><span class="line">2070</span><br><span class="line">2071</span><br><span class="line">2072</span><br><span class="line">2073</span><br><span class="line">2074</span><br><span class="line">2075</span><br><span class="line">2076</span><br><span class="line">2077</span><br><span class="line">2078</span><br><span class="line">2079</span><br><span class="line">2080</span><br><span class="line">2081</span><br><span class="line">2082</span><br><span class="line">2083</span><br><span class="line">2084</span><br><span class="line">2085</span><br><span class="line">2086</span><br><span class="line">2087</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will send an urgent message to message queue object, which</span></span><br><span class="line"><span class="comment"> * means the message will be inserted to the head of message queue. If there</span></span><br><span class="line"><span class="comment"> * are threads suspended on message queue object, it will be waked up.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mq the message queue object</span></span><br><span class="line"><span class="comment"> * @param buffer the message</span></span><br><span class="line"><span class="comment"> * @param size the size of buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mq_urgent(<span class="keyword">rt_mq_t</span> mq, <span class="keyword">void</span> *buffer, <span class="keyword">rt_size_t</span> size)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> temp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mq_message</span> *<span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mq != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mq-&gt;parent.parent) == RT_Object_Class_MessageQueue);</span><br><span class="line">    RT_ASSERT(buffer != RT_NULL);</span><br><span class="line">    RT_ASSERT(size != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* greater than one message size */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; mq-&gt;msg_size)</span><br><span class="line">        <span class="keyword">return</span> -RT_ERROR;</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&amp;(mq-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get a free list, there must be an empty item */</span></span><br><span class="line">    msg = (struct rt_mq_message *)mq-&gt;msg_queue_free;</span><br><span class="line">    <span class="comment">/* message queue is full */</span></span><br><span class="line">    <span class="keyword">if</span> (msg == RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -RT_EFULL;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* move free list pointer */</span></span><br><span class="line">    mq-&gt;msg_queue_free = msg-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy buffer */</span></span><br><span class="line">    rt_memcpy(msg + <span class="number">1</span>, buffer, size);</span><br></pre></td></tr></tbody></table></figure><ul><li>因為要插在第一顆，<code>next</code> 就不用設定為空了</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">2088</span><br><span class="line">2089</span><br><span class="line">2090</span><br><span class="line">2091</span><br><span class="line">2092</span><br><span class="line">2093</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* disable interrupt */</span></span><br><span class="line">temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* link msg to the beginning of message queue */</span></span><br><span class="line">msg-&gt;next = mq-&gt;msg_queue_head;</span><br><span class="line">mq-&gt;msg_queue_head = msg;</span><br></pre></td></tr></tbody></table></figure><ul><li>這裡就將新訊息插在第一顆</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">2097</span><br><span class="line">2098</span><br><span class="line">2099</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* if there is no tail */</span></span><br><span class="line"><span class="keyword">if</span> (mq-&gt;msg_queue_tail == RT_NULL)</span><br><span class="line">    mq-&gt;msg_queue_tail = msg;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果原本的 message queue 為空，設定新的尾巴</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">2100</span><br><span class="line">2101</span><br><span class="line">2102</span><br><span class="line">2103</span><br><span class="line">2104</span><br><span class="line">2105</span><br><span class="line">2106</span><br><span class="line">2107</span><br><span class="line">2108</span><br><span class="line">2109</span><br><span class="line">2110</span><br><span class="line">2111</span><br><span class="line">2112</span><br><span class="line">2113</span><br><span class="line">2114</span><br><span class="line">2115</span><br><span class="line">2116</span><br><span class="line">2117</span><br><span class="line">2118</span><br><span class="line">2119</span><br><span class="line">2120</span><br><span class="line">2121</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* increase message entry */</span></span><br><span class="line">    mq-&gt;entry ++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resume suspended thread */</span></span><br><span class="line">    <span class="keyword">if</span> (!rt_list_isempty(&amp;mq-&gt;parent.suspend_thread))</span><br><span class="line">    {</span><br><span class="line">        rt_ipc_list_resume(&amp;(mq-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        rt_schedule();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_EOK;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mq_urgent);</span><br></pre></td></tr></tbody></table></figure><ul><li>其他的動作皆相同</li></ul><hr><h3 id="接收訊息"><a href="#接收訊息" class="headerlink" title="接收訊息"></a>接收訊息</h3><div class="table-responsive"><table class="table table-bordered"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>接收訊息</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered"><thead><tr><th><code>mq</code></th><th><code>*buffer</code></th><th><code>size</code></th><th><code>timeout</code></th></tr></thead><tbody><tr><td>欲訊息 message queue</td><td>訊息存放處</td><td>訊息存放處大小</td><td>等待時間（如果需要）</td></tr></tbody></table></div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">2123</span><br><span class="line">2124</span><br><span class="line">2125</span><br><span class="line">2126</span><br><span class="line">2127</span><br><span class="line">2128</span><br><span class="line">2129</span><br><span class="line">2130</span><br><span class="line">2131</span><br><span class="line">2132</span><br><span class="line">2133</span><br><span class="line">2134</span><br><span class="line">2135</span><br><span class="line">2136</span><br><span class="line">2137</span><br><span class="line">2138</span><br><span class="line">2139</span><br><span class="line">2140</span><br><span class="line">2141</span><br><span class="line">2142</span><br><span class="line">2143</span><br><span class="line">2144</span><br><span class="line">2145</span><br><span class="line">2146</span><br><span class="line">2147</span><br><span class="line">2148</span><br><span class="line">2149</span><br><span class="line">2150</span><br><span class="line">2151</span><br><span class="line">2152</span><br><span class="line">2153</span><br><span class="line">2154</span><br><span class="line">2155</span><br><span class="line">2156</span><br><span class="line">2157</span><br><span class="line">2158</span><br><span class="line">2159</span><br><span class="line">2160</span><br><span class="line">2161</span><br><span class="line">2162</span><br><span class="line">2163</span><br><span class="line">2164</span><br><span class="line">2165</span><br><span class="line">2166</span><br><span class="line">2167</span><br><span class="line">2168</span><br><span class="line">2169</span><br><span class="line">2170</span><br><span class="line">2171</span><br><span class="line">2172</span><br><span class="line">2173</span><br><span class="line">2174</span><br><span class="line">2175</span><br><span class="line">2176</span><br><span class="line">2177</span><br><span class="line">2178</span><br><span class="line">2179</span><br><span class="line">2180</span><br><span class="line">2181</span><br><span class="line">2182</span><br><span class="line">2183</span><br><span class="line">2184</span><br><span class="line">2185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will receive a message from message queue object, if there is</span></span><br><span class="line"><span class="comment"> * no message in message queue object, the thread shall wait for a specified</span></span><br><span class="line"><span class="comment"> * time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mq the message queue object</span></span><br><span class="line"><span class="comment"> * @param buffer the received message will be saved in</span></span><br><span class="line"><span class="comment"> * @param size the size of buffer</span></span><br><span class="line"><span class="comment"> * @param timeout the waiting time</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mq_recv(<span class="keyword">rt_mq_t</span>    mq,</span><br><span class="line">                    <span class="keyword">void</span>      *buffer,</span><br><span class="line">                    <span class="keyword">rt_size_t</span>  size,</span><br><span class="line">                    <span class="keyword">rt_int32_t</span> timeout)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> temp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mq_message</span> *<span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> tick_delta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mq != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mq-&gt;parent.parent) == RT_Object_Class_MessageQueue);</span><br><span class="line">    RT_ASSERT(buffer != RT_NULL);</span><br><span class="line">    RT_ASSERT(size != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize delta tick */</span></span><br><span class="line">    tick_delta = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* get current thread */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&amp;(mq-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* for non-blocking call */</span></span><br><span class="line">    <span class="keyword">if</span> (mq-&gt;entry == <span class="number">0</span> &amp;&amp; timeout == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -RT_ETIMEOUT;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* message queue is empty */</span></span><br><span class="line">    <span class="keyword">while</span> (mq-&gt;entry == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        RT_DEBUG_IN_THREAD_CONTEXT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* reset error number in thread */</span></span><br><span class="line">        thread-&gt;error = RT_EOK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* no waiting, return timeout */</span></span><br><span class="line">        <span class="keyword">if</span> (timeout == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* enable interrupt */</span></span><br><span class="line">            rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">            thread-&gt;error = -RT_ETIMEOUT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> -RT_ETIMEOUT;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 message queue 為空，且不等待，回傳 <code>TIMEOUT</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">2186</span><br><span class="line">2187</span><br><span class="line">2188</span><br><span class="line">2189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* suspend current thread */</span></span><br><span class="line">rt_ipc_list_suspend(&amp;(mq-&gt;parent.suspend_thread),</span><br><span class="line">                    thread,</span><br><span class="line">                    mq-&gt;parent.parent.flag);</span><br></pre></td></tr></tbody></table></figure><ul><li>如要等待，將 thread 掛在等待鏈上</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">2190</span><br><span class="line">2191</span><br><span class="line">2192</span><br><span class="line">2193</span><br><span class="line">2194</span><br><span class="line">2195</span><br><span class="line">2196</span><br><span class="line">2197</span><br><span class="line">2198</span><br><span class="line">2199</span><br><span class="line">2200</span><br><span class="line">2201</span><br><span class="line">2202</span><br><span class="line">2203</span><br><span class="line">2204</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* has waiting time, start thread timer */</span></span><br><span class="line"><span class="keyword">if</span> (timeout &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* get the start tick of timer */</span></span><br><span class="line">    tick_delta = rt_tick_get();</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_IPC, (<span class="string">"set thread:%s to timer list\n"</span>,</span><br><span class="line">                                thread-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset the timeout of thread timer and start it */</span></span><br><span class="line">    rt_timer_control(&amp;(thread-&gt;thread_timer),</span><br><span class="line">                     RT_TIMER_CTRL_SET_TIME,</span><br><span class="line">                     &amp;timeout);</span><br><span class="line">    rt_timer_start(&amp;(thread-&gt;thread_timer));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>並啟動一個 timer</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">2205</span><br><span class="line">2206</span><br><span class="line">2207</span><br><span class="line">2208</span><br><span class="line">2209</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* enable interrupt */</span></span><br><span class="line">rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* re-schedule */</span></span><br><span class="line">rt_schedule();</span><br></pre></td></tr></tbody></table></figure><ul><li>開始等待，做一次調度</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">2210</span><br><span class="line">2211</span><br><span class="line">2212</span><br><span class="line">2213</span><br><span class="line">2214</span><br><span class="line">2215</span><br><span class="line">2216</span><br><span class="line">2217</span><br><span class="line">2218</span><br><span class="line">2219</span><br><span class="line">2220</span><br><span class="line">2221</span><br><span class="line">2222</span><br><span class="line">2223</span><br><span class="line">2224</span><br><span class="line">2225</span><br><span class="line">2226</span><br><span class="line">2227</span><br><span class="line">2228</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* recv message */</span></span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;error != RT_EOK)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* return error */</span></span><br><span class="line">        <span class="keyword">return</span> thread-&gt;error;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if it's not waiting forever and then re-calculate timeout tick */</span></span><br><span class="line">    <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        tick_delta = rt_tick_get() - tick_delta;</span><br><span class="line">        timeout -= tick_delta;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">            timeout = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如跳回來，重新計算 <code>timeout</code></li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">2229</span><br><span class="line">2230</span><br><span class="line">2231</span><br><span class="line">2232</span><br><span class="line">2233</span><br><span class="line">2234</span><br><span class="line">2235</span><br><span class="line">2236</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get message from queue */</span></span><br><span class="line">msg = (struct rt_mq_message *)mq-&gt;msg_queue_head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* move message queue head */</span></span><br><span class="line">mq-&gt;msg_queue_head = msg-&gt;next;</span><br><span class="line"><span class="comment">/* reach queue tail, set to NULL */</span></span><br><span class="line"><span class="keyword">if</span> (mq-&gt;msg_queue_tail == msg)</span><br><span class="line">    mq-&gt;msg_queue_tail = RT_NULL;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 message queue 有資料，拿第一顆，同時更新 head（tail，如果需要）</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">2237</span><br><span class="line">2238</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* decrease message entry */</span></span><br><span class="line">mq-&gt;entry --;</span><br></pre></td></tr></tbody></table></figure><ul><li>更新 entry</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">2239</span><br><span class="line">2240</span><br><span class="line">2241</span><br><span class="line">2242</span><br><span class="line">2243</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* enable interrupt */</span></span><br><span class="line">rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* copy message */</span></span><br><span class="line">rt_memcpy(buffer, msg + <span class="number">1</span>, size &gt; mq-&gt;msg_size ? mq-&gt;msg_size : size);</span><br></pre></td></tr></tbody></table></figure><ul><li>接著複製找到的訊息</li></ul><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">2244</span><br><span class="line">2245</span><br><span class="line">2246</span><br><span class="line">2247</span><br><span class="line">2248</span><br><span class="line">2249</span><br><span class="line">2250</span><br><span class="line">2251</span><br><span class="line">2252</span><br><span class="line">2253</span><br><span class="line">2254</span><br><span class="line">2255</span><br><span class="line">2256</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line">    <span class="comment">/* put message to free list */</span></span><br><span class="line">    msg-&gt;next = (struct rt_mq_message *)mq-&gt;msg_queue_free;</span><br><span class="line">    mq-&gt;msg_queue_free = msg;</span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&amp;(mq-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mq_recv);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後將 <code>msg</code> 插入 free list 的頭</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;Mail-Box&quot;&gt;&lt;a href=&quot;#Mail-Box&quot; cla
      
    
    </summary>
    
    
      <category term="RT-Thread" scheme="http://blog.lusw.dev/categories/RT-Thread/"/>
    
    
      <category term="kernel" scheme="http://blog.lusw.dev/tags/kernel/"/>
    
      <category term="RT-Thread" scheme="http://blog.lusw.dev/tags/RT-Thread/"/>
    
      <category term="event" scheme="http://blog.lusw.dev/tags/event/"/>
    
      <category term="message" scheme="http://blog.lusw.dev/tags/message/"/>
    
      <category term="mailbox" scheme="http://blog.lusw.dev/tags/mailbox/"/>
    
  </entry>
  
</feed>
