<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技術筆記</title>
  
  <subtitle>單晶片、即時作業系統與韌體相關之技術筆記</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.lusw.dev/"/>
  <updated>2020-04-25T14:23:21.000Z</updated>
  <id>https://blog.lusw.dev/</id>
  
  <author>
    <name>LuSkywalker</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Add Bootstrap label Tags into Hexo</title>
    <link href="https://blog.lusw.dev/add-bs-label-for-hexo.html"/>
    <id>https://blog.lusw.dev/add-bs-label-for-hexo.html</id>
    <published>2020-04-25T13:35:18.000Z</published>
    <updated>2020-04-25T14:23:21.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Boostrap-Label"><a class="header-anchor" href="#Boostrap-Label">#</a>Boostrap Label</h2><span class="label label-default">label content</span><p>So this is a label given by <a href="https://getbootstrap.com/docs/3.3/components/#labels" target="_blank" rel="noopener">bootstrap</a>, we can add this into hexo just simply write some <span class="label label-warning">HTML</span> like this.</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"label label-default"</span>&gt;</span>label content<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>And yes, this is not like <ins><em>Hexo</em></ins> style, and hardly to modify.<br>So as <a href="%22/add-bs-panel-for-hexo.html%22">last post</a>, let build a tags to insert a label.</p><hr><h2 id="Label-Tags"><a class="header-anchor" href="#Label-Tags">#</a>Label Tags</h2><h3 id="label-js"><a class="header-anchor" href="#label-js">#</a>label.js</h3><p>First things to do, new a file call <em>label.js</em> and put into <code>scripts</code> directory in current theme’s directory:</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch /path/to/your/current/theme/dir/script/panel.js</span></span><br></pre></td></tr></tbody></table></figure><div class="alert alert-warning"><p>if <code>scripts</code> directory is not existed, first new a directory.</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir /path/to/your/current/theme/dir/script</span></span><br></pre></td></tr></tbody></table></figure></div><p>Then, write down this into lastest javascript file (label.js).</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * label.js | global hexo script.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Usage:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * {% label [class]@Text %}</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [class] : default | primary | success | info | warning | danger.</span></span><br><span class="line"><span class="comment"> *           If not defined, default class will be selected.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postLabel</span> (<span class="params">args</span>) </span>{</span><br><span class="line">    args = args.join(<span class="string">' '</span>).split(<span class="string">'@'</span>);</span><br><span class="line">    <span class="keyword">var</span> classes = args[<span class="number">0</span>] || <span class="string">'default'</span>;</span><br><span class="line">    <span class="keyword">var</span> text = args[<span class="number">1</span>] || <span class="string">''</span>;</span><br><span class="line">  </span><br><span class="line">    classes = classes.trim();</span><br><span class="line">    !text &amp;&amp; hexo.log.warn(<span class="string">'Label text must be defined!'</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;span class="label label-'</span> + classes + <span class="string">'"&gt;'</span> + text + <span class="string">'&lt;/span&gt;'</span>;</span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line">hexo.extend.tag.register(<span class="string">'label'</span>, postLabel, { <span class="attr">ends</span>: <span class="literal">false</span> });</span><br></pre></td></tr></tbody></table></figure><p>In line 23, we registed a tag name label, and next time we write something like below , it will show like bs label.</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">label</span> @blah %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><h3 id="Different"><a class="header-anchor" href="#Different">#</a>Different</h3><p>Here is a trivial different point with panel we wrote in <code>register</code>.</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">hexo.extend.tag.register(<span class="string">'label'</span>, postLabel, { <span class="attr">ends</span>: <span class="literal">false</span> });</span><br></pre></td></tr></tbody></table></figure><p>In the third parameter, we write down <code>{ ends: false }</code>, this will tell hexo that this tag has no end tag. So our label tag should write like this:</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">label</span> @blah %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><p>And carefully don’t write something like this:</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">{% label @blah %}</span><br><span class="line">{% endlabel %}</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-danger"><p>Line 2 should not be write down in post markdown file.</p></div><hr><h3 id="Classes"><a class="header-anchor" href="#Classes">#</a>Classes</h3><p>Label has some <a href="https://getbootstrap.com/docs/3.3/components/#available-variations" target="_blank" rel="noopener">different styles</a>, we can use args to implement it.</p><div class="panel panel-default"><div class="panel-body"><p>Args is given by hexo tag api, we can pass argument to tag.<br>so we combine style name into bs classes, this is the code.</p></div><div class="panel-footer"><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postLabel</span> (<span class="params">args</span>) </span>{</span><br><span class="line">    args = args.join(<span class="string">' '</span>).split(<span class="string">'@'</span>);</span><br><span class="line">    <span class="keyword">var</span> classes = args[<span class="number">0</span>] || <span class="string">'default'</span>;</span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;span class="label label-'</span> + classes + <span class="string">'"&gt;'</span> + text + <span class="string">'&lt;/span&gt;'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="panel panel-default"><div class="panel-body"><p><span class="label label-default">Default</span> <span class="label label-primary">Primary</span> <span class="label label-success">Success</span> <span class="label label-info">Info</span> <span class="label label-warning">Warning</span> <span class="label label-danger">Danger</span></p></div><div class="panel-footer"><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">{% label default @Default %}</span><br><span class="line">{% label primary @Primary %}</span><br><span class="line">{% label success @Success %}</span><br><span class="line">{% label info @Info %}</span><br><span class="line">{% label warning @Warning %}</span><br><span class="line">{% label danger @Danger %}</span><br></pre></td></tr></tbody></table></figure></div></div><hr><h3 id="Content"><a class="header-anchor" href="#Content">#</a>Content</h3><p>This is how content show.</p><div class="panel panel-default"><div class="panel-body"><p>Content is given by hexo tag api, this is a string inside tag (of course markdown). We can use hexo render engine to show it.</p></div><div class="panel-footer"><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postLabel</span> (<span class="params">args</span>) </span>{</span><br><span class="line">    args = args.join(<span class="string">' '</span>).split(<span class="string">'@'</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> text = args[<span class="number">1</span>] || <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;span class="label label-'</span> + classes + <span class="string">'"&gt;'</span> + text + <span class="string">'&lt;/span&gt;'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><hr><h3 id="Remind"><a class="header-anchor" href="#Remind">#</a>Remind</h3><p>This label styling is using <a href="https://getbootstrap.com/docs/3.3/" target="_blank" rel="noopener">Bootstrap</a> v3.3, so you need to include bs stylesheet in <code>&lt;head&gt;</code>.</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Latest compiled and minified CSS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>Of course you can use newest libary like v4.0, all version are <a href="https://getbootstrap.com/docs/versions/" target="_blank" rel="noopener">here</a>.</p><div class="alert alert-danger"><p>In newer version like v4.x, <code>.label</code> is merge into <code>.badge</code>, so you need to replace all <code>.label</code> classes into <code>.badge</code> classes.</p></div><hr><h2 id="Example"><a class="header-anchor" href="#Example">#</a>Example</h2><figure class="highlight md"><table><tbody><tr><td class="code"><pre><span class="line">{% label @label content %}</span><br></pre></td></tr></tbody></table></figure><p>So this is the correct code I wrote in the top. Label class should given by first argument</p><figure class="highlight mel"><table><tbody><tr><td class="code"><pre><span class="line">{% label <span class="keyword">default</span> @Stuff %}</span><br><span class="line">{% label primary @Stuff %} </span><br><span class="line">{% label success @Stuff %} </span><br><span class="line">{% label info @Stuff %} </span><br><span class="line">{% label <span class="keyword">warning</span> @Stuff %} </span><br><span class="line">{% label danger @Stuff %}</span><br></pre></td></tr></tbody></table></figure><p>If not given classes, it will also show default classes. So this two are equal.</p><figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">{% label @Stuff %}</span><br><span class="line">{% label<span class="built_in"> default </span>@Stuff %}</span><br></pre></td></tr></tbody></table></figure><p>And content should put after a <code>@</code></p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">label</span> @Content here %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><hr><p>That is, how does a panel work on hexo by using tag plugins. You can find source code about this website in <a href="https://github.com/luswdev/luswdev.github.io/tree/auto_bk_matery" target="_blank" rel="noopener">github</a> if you want to learn more.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;Boostrap-Label&quot;&gt;&lt;a class=&quot;header-
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://blog.lusw.dev/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://blog.lusw.dev/tags/Hexo/"/>
    
      <category term="label" scheme="https://blog.lusw.dev/tags/label/"/>
    
      <category term="bootstrap" scheme="https://blog.lusw.dev/tags/bootstrap/"/>
    
      <category term="tags" scheme="https://blog.lusw.dev/tags/tags/"/>
    
  </entry>
  
  <entry>
    <title>Add Bootstrap Panel Tags into Hexo</title>
    <link href="https://blog.lusw.dev/add-bs-panel-for-hexo.html"/>
    <id>https://blog.lusw.dev/add-bs-panel-for-hexo.html</id>
    <published>2020-04-23T13:11:09.000Z</published>
    <updated>2020-04-25T14:18:13.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Bootstrap-Panel"><a class="header-anchor" href="#Bootstrap-Panel">#</a>Bootstrap Panel</h2><div class="panel panel-default"><div class="panel-heading"><h3 class="panel-title">panel title</h3><p>panel heading content</p></div><div class="panel-body"><p>panel content</p></div><div class="panel-footer"><p>panel footer</p></div></div><p>So this is a panel given by <a href="https://getbootstrap.com/docs/3.3/components/#panels" target="_blank" rel="noopener">bootstrap</a>, we can add this into hexo just simply write some <span class="label label-warning">HTML</span> like this.</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel panel-default"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel-heading"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">"panel-title"</span>&gt;</span>panel title<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>panel heading content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel-body"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>panel content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel-footer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>panel footer<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>But this kind of things is not like <ins><em>Hexo</em></ins> style, and hardly to modify.<br>Luckly, Hexo is giving us some api call <a href="https://hexo.io/api/tag" target="_blank" rel="noopener"><strong>tag plugin</strong></a>, so let made a tag to insert a panel!</p><hr><h2 id="Tag-Plugin"><a class="header-anchor" href="#Tag-Plugin">#</a>Tag Plugin</h2><p>So what is actually tag plugin is? This is the answer of Hexo doc.</p><div class="alert alert-default"><p>A tag allows users to quickly and easily insert snippets into their posts.</p></div><p>As you see, we can simply build a tag and it will render a block our want. A example is above. This <strong>Bs Alert</strong> block is write down in <code>.md</code> like this:</p><figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">{%<span class="built_in"> note </span>%}</span><br><span class="line">blah blah</span><br><span class="line">blah more</span><br><span class="line">{% endnote %}</span><br></pre></td></tr></tbody></table></figure><p>And this tag is named by <em>note</em>. OK, let we get started to build panel tag.</p><hr><h2 id="Panel-Tag"><a class="header-anchor" href="#Panel-Tag">#</a>Panel Tag</h2><h3 id="panel-js"><a class="header-anchor" href="#panel-js">#</a>panel.js</h3><p>First things to do, new a file call <em>panel.js</em> and put into <code>scripts</code> directory in current theme’s directory:</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch /path/to/your/current/theme/dir/script/panel.js</span></span><br></pre></td></tr></tbody></table></figure><div class="alert alert-warning"><p>if <code>scripts</code> directory is not existed, first new a directory.</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir /path/to/your/current/theme/dir/script</span></span><br></pre></td></tr></tbody></table></figure></div><p>Then, write down this into lastest javascript file (panel.js).</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * panel.js | global hexo script.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Usage:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * {% panel class %}</span></span><br><span class="line"><span class="comment"> * &lt;!-- heading --&gt;</span></span><br><span class="line"><span class="comment"> * Any content (support inline tags too).</span></span><br><span class="line"><span class="comment"> *  &lt;!-- endheading --&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Any content (support inline tags too).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;!-- footer --&gt;</span></span><br><span class="line"><span class="comment"> * Any content (support inline tags too).</span></span><br><span class="line"><span class="comment"> *  &lt;!-- endfooter --&gt;</span></span><br><span class="line"><span class="comment"> * {% endpanel %}</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">panelContent</span> (<span class="params">args, content</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> classes = args[<span class="number">0</span>] || <span class="string">'default'</span>;</span><br><span class="line">    <span class="keyword">var</span> rHeading = <span class="regexp">/&lt;!--\s*heading\s*--&gt;\n([\w\W\s\S]*?)&lt;!--\s*endheading\s*--&gt;/g</span>;</span><br><span class="line">    <span class="keyword">var</span> rTitle = <span class="regexp">/#+\s([a-zA-Z ]+)/g</span>;</span><br><span class="line">    <span class="keyword">var</span> rFooter = <span class="regexp">/&lt;!--\s*footer\s*--&gt;\n([\w\W\s\S]*?)&lt;!--\s*endfooter\s*--&gt;/g</span>;</span><br><span class="line">    <span class="keyword">var</span> heading = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">var</span> footer = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> returnVal = <span class="string">'&lt;div class="panel panel-'</span> + classes + <span class="string">'"&gt;'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heading = rHeading.exec(content)) {</span><br><span class="line">        content = content.replace(rHeading, <span class="string">''</span>);</span><br><span class="line">        returnVal += <span class="string">'&lt;div class="panel-heading"&gt;'</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> title = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">if</span> (title = rTitle.exec(heading[<span class="number">1</span>])) {</span><br><span class="line">            returnVal += <span class="string">'&lt;h3 class="panel-title"&gt;'</span> + title[<span class="number">1</span>] + <span class="string">'&lt;/h3&gt;'</span> ;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        heading[<span class="number">1</span>] = heading[<span class="number">1</span>].replace(rTitle, <span class="string">''</span>);</span><br><span class="line">        returnVal += hexo.render.renderSync({<span class="attr">text</span>: heading[<span class="number">1</span>], <span class="attr">engine</span>: <span class="string">'markdown'</span>}).trim() + <span class="string">'&lt;/div&gt;'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (footer = rFooter.exec(content)) {</span><br><span class="line">        content = content.replace(rFooter, <span class="string">''</span>);</span><br><span class="line">        returnVal += <span class="string">'&lt;div class="panel-body"&gt;'</span> + hexo.render.renderSync({<span class="attr">text</span>: content, <span class="attr">engine</span>: <span class="string">'markdown'</span>}).trim() + <span class="string">'&lt;/div&gt;'</span>;</span><br><span class="line">        returnVal += <span class="string">'&lt;div class="panel-footer"&gt;'</span> + hexo.render.renderSync({<span class="attr">text</span>: footer[<span class="number">1</span>], <span class="attr">engine</span>: <span class="string">'markdown'</span>}).trim() + <span class="string">'&lt;/div&gt;&lt;/div&gt;'</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        returnVal += <span class="string">'&lt;div class="panel-body"&gt;'</span> + hexo.render.renderSync({<span class="attr">text</span>: content, <span class="attr">engine</span>: <span class="string">'markdown'</span>}).trim() + <span class="string">'&lt;/div&gt;&lt;/div&gt;'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnVal;</span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line">hexo.extend.tag.register(<span class="string">'panel'</span>, panelContent, { <span class="attr">ends</span>: <span class="literal">true</span> });</span><br></pre></td></tr></tbody></table></figure><p>In line 55, we registed a tag name panel, and next time we write something like below , it will show like bs panel.</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">panel</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml">panel stuff</span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">endpanel</span> %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Classes"><a class="header-anchor" href="#Classes">#</a>Classes</h3><p>Panel has some <a href="https://getbootstrap.com/docs/3.3/components/#panels-alternatives" target="_blank" rel="noopener">different styles</a>, we can use args to implement it.</p><div class="panel panel-default"><div class="panel-body"><p>Args is given by hexo tag api, we can pass argument to tag.<br>so we combine style name into bs classes, this is the code.</p></div><div class="panel-footer"><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">panelContent</span> (<span class="params">args, content</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> classes = args[<span class="number">0</span>] || <span class="string">'default'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> returnVal = <span class="string">'&lt;div class="panel panel-'</span> + classes + <span class="string">'"&gt;'</span>;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="panel panel-default"><div class="panel-body"><div class="panel panel-default"><div class="panel-heading"><h3 class="panel-title">Default Panel</h3></div><div class="panel-body"><p>Panel content</p></div></div><div class="panel panel-primary"><div class="panel-heading"><h3 class="panel-title">Primary Panel</h3></div><div class="panel-body"><p>Panel content</p></div></div><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title">Success Panel</h3></div><div class="panel-body"><p>Panel content</p></div></div><div class="panel panel-info"><div class="panel-heading"><h3 class="panel-title">Info Panel</h3></div><div class="panel-body"><p>Panel content</p></div></div><div class="panel panel-warning"><div class="panel-heading"><h3 class="panel-title">Warning Panel</h3></div><div class="panel-body"><p>Panel content</p></div></div><div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title">Danger Panel</h3></div><div class="panel-body"><p>Panel content</p></div></div></div><div class="panel-footer"><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">{% panel default %}...{% endpanel %}</span><br><span class="line">{% panel primary %}...{% endpanel %}</span><br><span class="line">{% panel success %}...{% endpanel %}</span><br><span class="line">{% panel info %}...{% endpanel %}</span><br><span class="line">{% panel warning %}...{% endpanel %}</span><br><span class="line">{% panel danger %}...{% endpanel %}</span><br></pre></td></tr></tbody></table></figure></div></div><hr><h3 id="Content"><a class="header-anchor" href="#Content">#</a>Content</h3><p>This is how content show.</p><div class="panel panel-default"><div class="panel-body"><p>Content is given by hexo tag api, this is a string inside tag (of course markdown). We can use hexo render engine to show it.</p></div><div class="panel-footer"><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">panelContent</span> (<span class="params">args, content</span>) </span>{</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> returnVal = <span class="string">'&lt;div class="panel panel-'</span> + classes + <span class="string">'"&gt;'</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    returnVal += <span class="string">'&lt;div class="panel-body"&gt;'</span> + hexo.render.renderSync({<span class="attr">text</span>: content, <span class="attr">engine</span>: <span class="string">'markdown'</span>}).trim() + <span class="string">'&lt;/div&gt;&lt;/div&gt;'</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnVal;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><hr><h3 id="Heading-and-Footer"><a class="header-anchor" href="#Heading-and-Footer">#</a>Heading and Footer</h3><p>Panel heading and footer is also given in bs, so we can implement it.</p><div class="panel panel-default"><div class="panel-heading"><h3 class="panel-title">panel heading</h3></div><div class="panel-body"><p>This is how heading work.</p><ol><li>First, you must put your heading content between <code>&lt;!-- heading --&gt;</code> and <code>&lt;!-- endheading --&gt;</code>.</li><li>In <em>panel.js</em>, we use RegExp to find correct heading content, and let first title (write as markdown <code>#</code>) be panel title.</li><li>RegExp for heading is line 1, and first title will find in line 9.</li><li>After finding, we render this stuff by using hexo render engine.</li></ol></div><div class="panel-footer"><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rHeading = <span class="regexp">/&lt;!--\s*heading\s*--&gt;\n([\w\W\s\S]*?)&lt;!--\s*endheading\s*--&gt;/g</span>;</span><br><span class="line"><span class="keyword">var</span> rTitle = <span class="regexp">/#+\s([a-zA-Z ]+)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (heading = rHeading.exec(content)) {</span><br><span class="line">    content = content.replace(rHeading, <span class="string">''</span>);</span><br><span class="line">    returnVal += <span class="string">'&lt;div class="panel-heading"&gt;'</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">if</span> (title = rTitle.exec(heading[<span class="number">1</span>])) {</span><br><span class="line">        returnVal += <span class="string">'&lt;h3 class="panel-title"&gt;'</span> + title[<span class="number">1</span>] + <span class="string">'&lt;/h3&gt;'</span> ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    heading[<span class="number">1</span>] = heading[<span class="number">1</span>].replace(rTitle, <span class="string">''</span>);</span><br><span class="line">    returnVal += hexo.render.renderSync({<span class="attr">text</span>: heading[<span class="number">1</span>], <span class="attr">engine</span>: <span class="string">'markdown'</span>}).trim() + <span class="string">'&lt;/div&gt;'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="panel panel-default"><div class="panel-heading"><h3 class="panel-title">panel footer</h3></div><div class="panel-body"><p>This is how footer work.</p><ol><li>First, you must put your heading content between <code>&lt;!-- footer --&gt;</code> and <code>&lt;!-- endfooter --&gt;</code>.</li><li>In <em>panel.js</em>, we use RegExp to find currect footer content.</li><li>RegExp for footer is line 1.</li><li>After finding, we render this stuff by using hexo render engine.</li></ol></div><div class="panel-footer"><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rFooter = <span class="regexp">/&lt;!--\s*footer\s*--&gt;\n([\w\W\s\S]*?)&lt;!--\s*endfooter\s*--&gt;/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (footer = rFooter.exec(content)) {</span><br><span class="line">    content = content.replace(rFooter, <span class="string">''</span>);</span><br><span class="line">    returnVal += <span class="string">'&lt;div class="panel-body"&gt;'</span> + hexo.render.renderSync({<span class="attr">text</span>: content, <span class="attr">engine</span>: <span class="string">'markdown'</span>}).trim() + <span class="string">'&lt;/div&gt;'</span>;</span><br><span class="line">    returnVal += <span class="string">'&lt;div class="panel-footer"&gt;'</span> + hexo.render.renderSync({<span class="attr">text</span>: footer[<span class="number">1</span>], <span class="attr">engine</span>: <span class="string">'markdown'</span>}).trim() + <span class="string">'&lt;/div&gt;&lt;/div&gt;'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><hr><h3 id="Remind"><a class="header-anchor" href="#Remind">#</a>Remind</h3><p>This panel styling is using <a href="https://getbootstrap.com/docs/3.3/" target="_blank" rel="noopener">Bootstrap</a> v3.3, so you need to include bs stylesheet in <code>&lt;head&gt;</code>.</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Latest compiled and minified CSS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>Of course you can use newest libary like v4.0, all version are <a href="https://getbootstrap.com/docs/versions/" target="_blank" rel="noopener">here</a>.</p><div class="alert alert-danger"><p>In newer version like v4.x, <code>.panel</code> is merge into <code>.card</code>, so you need to replace all <code>.panel</code> classes into <code>.card</code> classes.</p></div><hr><h2 id="Example"><a class="header-anchor" href="#Example">#</a>Example</h2><figure class="highlight md"><table><tbody><tr><td class="code"><pre><span class="line">{% panel %}</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- heading  --&gt;</span></span></span><br><span class="line"><span class="section">### panel title</span></span><br><span class="line">panel heading content</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endheading --&gt;</span></span></span><br><span class="line">panel content</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- footer --&gt;</span></span></span><br><span class="line">panel footer</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endfooter --&gt;</span></span></span><br><span class="line">{% endpanel %}</span><br></pre></td></tr></tbody></table></figure><p>So this is the correct code I wrote in the top. Panel box in the tag of:</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">panel</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml">...</span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">endpanel</span> %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><p>And heading should put in:</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- heading --&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- endheading --&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>If title are wrote in heading, it will show as panel title:</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- heading --&gt;</span></span><br><span class="line">### panel title here</span><br><span class="line"><span class="comment">&lt;!-- endheading --&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>Also footer should put in:</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- footer --&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- endfooter --&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>And this is support classes:</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">panel</span> default %}</span><span class="xml">...</span><span class="template-tag">{% <span class="name">endpanel</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">panel</span> primary %}</span><span class="xml">...</span><span class="template-tag">{% <span class="name">endpanel</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">panel</span> info %}</span><span class="xml">...</span><span class="template-tag">{% <span class="name">endpanel</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">panel</span> warning %}</span><span class="xml">...</span><span class="template-tag">{% <span class="name">endpanel</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">panel</span> success %}</span><span class="xml">...</span><span class="template-tag">{% <span class="name">endpanel</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">panel</span> danger %}</span><span class="xml">...</span><span class="template-tag">{% <span class="name">endpanel</span> %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><p>If not given classes, it will also show default classes. So this two are equal.</p><figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">{% panel<span class="built_in"> default </span>%}<span class="built_in">..</span>.{% endpanel %}</span><br><span class="line">{% panel %}<span class="built_in">..</span>.{% endpanel %}</span><br></pre></td></tr></tbody></table></figure><hr><p>That is, how does a panel work on hexo by using tag plugins. You can find source code about this website in <a href="https://github.com/luswdev/luswdev.github.io/tree/auto_bk_matery" target="_blank" rel="noopener">github</a> if you want to learn more.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;Bootstrap-Panel&quot;&gt;&lt;a class=&quot;header
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://blog.lusw.dev/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://blog.lusw.dev/tags/Hexo/"/>
    
      <category term="bootstrap" scheme="https://blog.lusw.dev/tags/bootstrap/"/>
    
      <category term="tags" scheme="https://blog.lusw.dev/tags/tags/"/>
    
      <category term="panel" scheme="https://blog.lusw.dev/tags/panel/"/>
    
  </entry>
  
  <entry>
    <title>C 語言 - 位元欄位</title>
    <link href="https://blog.lusw.dev/c-bit-operation.html"/>
    <id>https://blog.lusw.dev/c-bit-operation.html</id>
    <published>2020-04-10T09:28:52.000Z</published>
    <updated>2020-04-25T12:44:03.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 C 語言中，如果我們要對特定的 bit(s) 做操作的話，最直覺的方式是用 bit and（<code>&amp;</code>）跟 bit or（<code>|</code>）：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> bit_sample = <span class="number">0x0123</span>; <span class="comment">/* 0000 0001 0010 0011 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 將第 2 個 bit 改成 1 */</span></span><br><span class="line">bit_samplee |= (<span class="number">0x1</span> &lt;&lt; <span class="number">2</span>); <span class="comment">/* 0000 0001 0010 0011 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 將第 5 個 bit 改成 1 */</span></span><br><span class="line">bit_samplee |= ~(<span class="number">0x1</span> &lt;&lt; <span class="number">5</span>); <span class="comment">/* 0000 0001 0010 0011 */</span></span><br></pre></td></tr></tbody></table></figure><p>從上面的例子可以看到如何使用 bit and/or 來操作特定的 bit，這種方式對於單一個 bit 並不會太麻煩，但有以下缺點：</p><ul><li>無法覆用：這種方式不能快速地建立一個方法，也比較不好理解</li><li>對於區間上就不好使了</li></ul><p>如果要解決上述缺點，有一個方式是使用 <code>union</code>，一個在嵌入式、驅動程式裡常常用到的方法。</p><hr><h2 id="Union"><a class="header-anchor" href="#Union">#</a>Union</h2><p><code>union</code> 是 C 語言裡面可以對一個結構裡面的元素，可以有不同的資料型態去理解，如以下例子：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> sample {</span><br><span class="line">    <span class="keyword">int</span> sample_int;</span><br><span class="line">    <span class="keyword">char</span> sample_str[<span class="number">4</span>];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>需要注意的是：同一時間內只能存取一個屬性，準確來說他們是共用一個記憶體區塊，所以改第一個值第二個值會同時更改。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[[C 語言] 程式設計教學：如何使用聯合 (Union)](https://michaelchen.tech/c-programming/union/)">[1]</span></a></sup></p></blockquote><h3 id="struct"><a class="header-anchor" href="#struct">#</a>struct</h3><p>奇怪，不是在講 <code>union</code> 嗎，怎麼會提到 <code>struct</code> 呢？那是因為 C 裡面有一個有趣的東西叫做位元欄位<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[位元欄](https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5)">[2]</span></a></sup>，這個東西必須搭配結構使用；先看例子：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bit_row</span> {</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> row1 : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> row2 : <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> row3 : <span class="number">1</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>乍看之下好像跟一般的結構差不多，可是我們注意到在每個元素宣告的結尾多了一個 <code>: 數字</code>，這是什麼意思？</p><ol><li>首先，<code>unsigned short</code> 在 64 位元裡大小是 4位，<code>unsigned int</code> 則是 8位</li><li>加上 <code>: 數字</code>，這個東西就叫位元欄位，我們可以限制當前元素的大小</li><li>因此，元素 1 的大小就被我們縮至 1 位，依此類推</li></ol><hr><p>有了上述的<strong>工具</strong>就可以建立一個好用而且好理解的位元操作方法！</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> method_ex {</span><br><span class="line">    <span class="keyword">int</span> real_val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bits</span> {</span></span><br><span class="line">        <span class="keyword">short</span> bit0to2 : <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">short</span> bit3and4 : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">short</span> bit5to7 : <span class="number">3</span>;</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>建立好上面這個 union 後，如果要將某一個整數的第 3 到 4 位 的值改掉，可以這樣寫</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> method_ex int_ex;</span><br><span class="line">int_ex.real_val = <span class="number">0x0123</span>; <span class="comment">/* 0000 0001 0010 0011 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* change 3 and 4 bits to 01 */</span></span><br><span class="line">int_ex.bits.bit3and4 = B01; <span class="comment">/* 0000 0001 0010 1011 */</span></span><br></pre></td></tr></tbody></table></figure><p>這樣的寫法，更簡單，更易懂。</p><hr><h3 id="剩下的空間"><a class="header-anchor" href="#剩下的空間">#</a>剩下的空間</h3><p>值得注意的一件事，我們沿用上面的例子；<code>method_ex</code> 有一個元素叫<em>真正的值</em>，他是一個整數（8 位），剛好另外一個元素我們使用位元欄位的技巧也控制在 8 位；但，如果我們沒有這麼做呢？</p><div class="alert alert-warning"><p>答案是：你可以這麼寫，不會有什麼問題，但不建議。</p></div><h4 id="更大"><a class="header-anchor" href="#更大">#</a>更大</h4><p>如果 <code>bits</code> 結構今天大於 8 位，那我們就沒辦法透過更改<em>真正的值</em>來改變到高於 8 位的值，因此這麼做是<strong>沒意義</strong>的。</p><h4 id="更小"><a class="header-anchor" href="#更小">#</a>更小</h4><p>如果 <code>bits</code> 結構今天小於 8 位，這麼做完全不會有任何問題，但習慣上，我們會把它補齊，像是我們在 <a href="/c-attribute">attribute</a> 篇裡提到的 padding。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> method_ex {</span><br><span class="line">    <span class="keyword">int</span> real_val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bits</span> {</span></span><br><span class="line">        <span class="keyword">short</span> bit0to2 : <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">short</span> bit3and4 : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">short</span> bit5and6 : <span class="number">2</span>;</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-info"><p>沒有定義第 7 位</p></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> method_ex {</span><br><span class="line">    <span class="keyword">int</span> real_val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bits</span> {</span></span><br><span class="line">        <span class="keyword">short</span> bit0to2 : <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">short</span> bit3and4 : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">short</span> bit5and6 : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">short</span> notused : <span class="number">1</span>;</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-info"><p>隨便取名，只要有定義就好</p></div><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://michaelchen.tech/c-programming/union/" target="_blank" rel="noopener">[C 語言] 程式設計教學：如何使用聯合 (Union)</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5" target="_blank" rel="noopener">位元欄</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;在 C 語言中，如果我們要對特定的 bit(s) 做操作的話，最直覺的方式是
      
    
    </summary>
    
    
      <category term="C語言" scheme="https://blog.lusw.dev/categories/Clang/"/>
    
    
      <category term="C" scheme="https://blog.lusw.dev/tags/C/"/>
    
      <category term="C語言" scheme="https://blog.lusw.dev/tags/Clang/"/>
    
      <category term="bit" scheme="https://blog.lusw.dev/tags/bit/"/>
    
      <category term="union" scheme="https://blog.lusw.dev/tags/union/"/>
    
  </entry>
  
  <entry>
    <title>如何查看 Linux 被佔用的 port</title>
    <link href="https://blog.lusw.dev/linux-lookup-port.html"/>
    <id>https://blog.lusw.dev/linux-lookup-port.html</id>
    <published>2020-04-08T07:08:31.000Z</published>
    <updated>2020-04-22T06:49:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>當我們下 <code>hexo s</code> 後，預設將會開啟 <code>:4000</code>，但如果 <code>:4000</code> 被佔用就會報錯；為解決此問題，我們必須知道是哪個行程佔用，並 <code>kill</code> 它。<br>以下我們介紹 2 種 Linux 的指令。</p></blockquote><h2 id="lsof"><a class="header-anchor" href="#lsof">#</a>lsof</h2><p>lsof (List Open Files)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Linux 列出行程開啟的檔案，lsof 指令用法教學與範例](https://blog.gtwang.org/linux/linux-lsof-command-list-open-files-tutorial-examples/)">[1]</span></a></sup>，可以列出所有被行程打開的檔案。可以利用 <code>-i</code> 來查找所有網路連線；於是</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lsof -i</span></span><br></pre></td></tr></tbody></table></figure><p>將會列出所有使用 port 的行程。而有時候有些 port 會有別名，為了方便找查，我們加上 <code>-P</code> (列出實際的 port number)；於是</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lsof -i -P</span></span><br></pre></td></tr></tbody></table></figure><p>最後為了簡化結果，我們將原本的結果傳給 <code>grep</code></p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lsof -i -P | grep :4000</span></span><br></pre></td></tr></tbody></table></figure><div class="alert alert-info"><p><code>:4000</code> 可任意改成想要的 port number，如 <code>:1234</code></p></div><h2 id="netstat"><a class="header-anchor" href="#netstat">#</a>netstat</h2><p>netstat 可以用來查看各種網路狀態，一樣可以拿來查找被佔用的 port。</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> netstat -tulpn</span></span><br></pre></td></tr></tbody></table></figure><p>其中：</p><ul><li><code>-t</code> 代表找走 <code>TCP</code> 協定的</li><li><code>-u</code> 代表找走 <code>UDP</code> 協定的</li><li><code>-l</code> 代表找 <code>LISTEN</code> 的 socket</li><li><code>-n</code> 代表顯示硬體名稱，<code>-p</code> 代表顯示 PID。<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[netstat Command Usage on Linux](https://geekflare.com/netstat/)">[2]</span></a></sup></li></ul><p>我們一樣可以用 <code>grep</code> 來協助尋找</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> netstat -tulpn | grep :4000</span></span><br></pre></td></tr></tbody></table></figure><hr><ul><li>Reference<ul><li><a href="https://www.opencli.com/linux/3-way-check-linux-listen-port" target="_blank" rel="noopener">3 種 Linux 查看 port 被程式佔用的方法</a></li></ul></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://blog.gtwang.org/linux/linux-lsof-command-list-open-files-tutorial-examples/" target="_blank" rel="noopener">Linux 列出行程開啟的檔案，lsof 指令用法教學與範例</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://geekflare.com/netstat/" target="_blank" rel="noopener">netstat Command Usage on Linux</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;當我們下 &lt;code&gt;hexo s&lt;/code&gt; 
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.lusw.dev/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blog.lusw.dev/tags/Linux/"/>
    
      <category term="port" scheme="https://blog.lusw.dev/tags/port/"/>
    
      <category term="lsof" scheme="https://blog.lusw.dev/tags/lsof/"/>
    
      <category term="netstat" scheme="https://blog.lusw.dev/tags/netstat/"/>
    
  </entry>
  
  <entry>
    <title>Linux 的 &quot;init&quot; 行程</title>
    <link href="https://blog.lusw.dev/linux-init-number.html"/>
    <id>https://blog.lusw.dev/linux-init-number.html</id>
    <published>2020-04-08T06:18:01.000Z</published>
    <updated>2020-04-22T04:29:36.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="init-行程"><a class="header-anchor" href="#init-行程">#</a>init 行程</h2><p>init 行程（process/tas）是 Linux 內核下的第一個行程，內核會在初始化完硬體後建立該行程。</p><blockquote><p>如<a href="https://blog.lusw.dev/starting-xv6/#toc-heading-3">XV6 啟動流程</a> 中提到的 <code>userinit()</code></p></blockquote><p>正常來說 init 應該被放在 <code>/sbin/init</code> 中，如果內核找不到，會試著在 <code>/bin/sh</code> 中尋找，若都失敗則將導致<strong>啟動失敗</strong>。</p><h2 id="init-等級"><a class="header-anchor" href="#init-等級">#</a>init 等級</h2><table><thead><tr><th>等級</th><th>用途</th></tr></thead><tbody><tr><td>0</td><td>關機</td></tr><tr><td>1</td><td>single user mode</td></tr><tr><td>6</td><td>重新啟動</td></tr></tbody></table><ul><li>對於 2 ~ 5，不同的發行版有不同的解釋，大部分的系統中：<ul><li>3 代表正常啟動 CLI</li><li>5 代表正常啟動 GUI</li></ul></li></ul><hr><ul><li>Reference<ul><li><a href="https://blog.csdn.net/cougar_mountain/article/details/9798191" target="_blank" rel="noopener">linux 下的init 0，1，2，3，4，5，6知识介绍</a></li><li><a href="http://felix-lin.com/linux/init%E6%BC%94%E5%8C%96%E6%AD%B7%E7%A8%8B-%E8%BD%89%E8%B2%BC-%E6%B7%BA%E6%9E%90-linux-%E5%88%9D%E5%A7%8B%E5%8C%96-init-%E7%B3%BB%E7%B5%B1%EF%BC%8C%E7%AC%AC-1-%E9%83%A8%E5%88%86-sysvinit/" target="_blank" rel="noopener">init演化歷程 – [轉貼] 淺析 Linux 初始化 init 系統，第 1 部分: sysvinit</a></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;init-行程&quot;&gt;&lt;a class=&quot;header-anchor&quot;
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.lusw.dev/categories/Linux/"/>
    
    
      <category term="kernel" scheme="https://blog.lusw.dev/tags/kernel/"/>
    
      <category term="Linux" scheme="https://blog.lusw.dev/tags/Linux/"/>
    
      <category term="init" scheme="https://blog.lusw.dev/tags/init/"/>
    
  </entry>
  
  <entry>
    <title>在 Xcode 中為免費開發者帳戶重新建立憑證</title>
    <link href="https://blog.lusw.dev/renew-xcode-profile-free-develope-account.html"/>
    <id>https://blog.lusw.dev/renew-xcode-profile-free-develope-account.html</id>
    <published>2020-03-23T03:54:33.000Z</published>
    <updated>2020-04-19T14:29:53.843Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="免費帳戶憑證"><a class="header-anchor" href="#免費帳戶憑證">#</a>免費帳戶憑證</h2><p>免費版開發者帳戶的憑證有效期限只有 7 天，可以參考此連結。<br><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%85%8D%E8%B2%BB%E9%96%8B%E7%99%BC%E5%B8%B3%E8%99%9F%E7%9A%84-ios-app-%E5%91%BD%E4%B8%AD%E6%B3%A8%E5%AE%9A%E5%8F%AA%E8%83%BD%E6%B4%BB%E4%B8%83%E5%A4%A9-8fd2cc849bfb" target="_blank" rel="noopener">免費開發帳號的 iOS App 命中注定只能活七天 !</a></p><p>理論上來說，超過期限只要重新從 Xcode 安裝 App 就會自動重簽 (renew)，但如果在期限內想要直接延期呢？</p><h2 id="建立新的憑證"><a class="header-anchor" href="#建立新的憑證">#</a>建立新的憑證</h2><p>如果想要直接延期，唯一的方法只有重新建立一個憑證：</p><ul><li><p>從 Preference 中的 Accounts<br><img src="https://i.imgur.com/JfTJGet.png" alt="Preference > Accounts"></p></li><li><p>選擇右下角的 Manage Certificates…<br><img src="https://i.imgur.com/r5PAFur.png" alt="黃框處"></p></li><li><p>按下去，選擇左下角的 <code>+</code><br><img src="https://i.imgur.com/Q59J2Tj.png" alt="黃框處"></p></li><li><p>選擇 Apple Development<br><img src="https://i.imgur.com/bSelwuz.png" alt=""></p></li></ul><p>之後就會新增一個憑證，可以回去 Targets 看憑證的確更新了。<br><img src="https://i.imgur.com/9MsNUqd.png" alt="紅字"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;免費帳戶憑證&quot;&gt;&lt;a class=&quot;header-anchor&quot; 
      
    
    </summary>
    
    
      <category term="Note" scheme="https://blog.lusw.dev/categories/Note/"/>
    
    
      <category term="Xcode" scheme="https://blog.lusw.dev/tags/Xcode/"/>
    
      <category term="ios" scheme="https://blog.lusw.dev/tags/ios/"/>
    
      <category term="renew" scheme="https://blog.lusw.dev/tags/renew/"/>
    
      <category term="certificate" scheme="https://blog.lusw.dev/tags/certificate/"/>
    
  </entry>
  
  <entry>
    <title>CSS3選擇器 :not()</title>
    <link href="https://blog.lusw.dev/css-not-selecter.html"/>
    <id>https://blog.lusw.dev/css-not-selecter.html</id>
    <published>2020-01-29T06:03:34.000Z</published>
    <updated>2020-04-23T13:07:38.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="用途"><a class="header-anchor" href="#用途">#</a>用途</h2><p>假設有多個一樣 <code>label</code> 的元素要套用一種樣式，但又有幾個需要排除在外時使用。</p><h3 id="例子"><a class="header-anchor" href="#例子">#</a>例子</h3><div class="panel panel-default"><div class="panel-body"><style>.ex-box {    text-align: center;}.ex {    color: #f00;    font-style: italic;    font-weight: bold;}</style><div class="ex-box"><span class="ex">1</span>    <span class="ex">2</span>    <span class="ex">3</span>    <span class="ex">4</span></div></div><div class="panel-footer"><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ex-box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"ex"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"ex"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"ex"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"ex"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.ex-box</span> {</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.ex</span> {</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f00</span>;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="alert alert-info"><p>可以看到上面：1~4 都有<em>斜體</em>跟<strong>粗體</strong>，為了方便觀察，這裡讓文字變為紅色</p></div><hr><div class="panel panel-default"><div class="panel-heading"><p>接著將 3 號加上 <code>not-ex-ignored</code> 的 id，並將此 id 略過（使用 <code>:not</code> 選擇器）</p></div><div class="panel-body"><style>.not-ex-box {    text-align: center;}.not-ex:not(#not-ex-ignored) {    color: #f00;    font-style: italic;    font-weight: bold;}</style><div class="not-ex-box"><span class="not-ex">1</span>    <span class="not-ex">2</span>    <span class="not-ex" id="not-ex-ignored">3</span>    <span class="not-ex">4</span></div></div><div class="panel-footer"><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"not-ex-box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"not-ex"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"not-ex"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"not-ex"</span> <span class="attr">id</span>=<span class="string">"not-ex-ignored"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"not-ex"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.not-ex-box</span> {</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.not-ex</span><span class="selector-pseudo">:not(</span><span class="selector-id">#not-ex-ignored</span>) {</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f00</span>;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="alert alert-info"><p>如此一來，就只有三號沒有套用到屬性。</p></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;用途&quot;&gt;&lt;a class=&quot;header-anchor&quot; href
      
    
    </summary>
    
    
      <category term="Note" scheme="https://blog.lusw.dev/categories/Note/"/>
    
    
      <category term="selector" scheme="https://blog.lusw.dev/tags/selector/"/>
    
      <category term="note" scheme="https://blog.lusw.dev/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Perl 模組安裝</title>
    <link href="https://blog.lusw.dev/perl-install-module.html"/>
    <id>https://blog.lusw.dev/perl-install-module.html</id>
    <published>2019-12-27T10:40:13.000Z</published>
    <updated>2020-04-22T04:30:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="使用自動安裝的環境"><a class="header-anchor" href="#使用自動安裝的環境">#</a>使用自動安裝的環境</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> perl -MCPAN -e shell</span></span><br></pre></td></tr></tbody></table></figure><ul><li>類似於 <code>apt</code>、<code>brew</code> 的好用套件，輸入指令會進入此環境中，成功的話終端機會顯示此畫面:</li></ul><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cman&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="安裝"><a class="header-anchor" href="#安裝">#</a>安裝</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cman&gt; install Module::Name</span></span><br></pre></td></tr></tbody></table></figure><ul><li>直接下 install 指令 後面接模組名稱即可。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;使用自動安裝的環境&quot;&gt;&lt;a class=&quot;header-ancho
      
    
    </summary>
    
    
      <category term="Note" scheme="https://blog.lusw.dev/categories/Note/"/>
    
    
      <category term="perl" scheme="https://blog.lusw.dev/tags/perl/"/>
    
  </entry>
  
  <entry>
    <title>在 Arduino 上使用中斷</title>
    <link href="https://blog.lusw.dev/arduino-interrupt.html"/>
    <id>https://blog.lusw.dev/arduino-interrupt.html</id>
    <published>2019-12-26T15:36:34.000Z</published>
    <updated>2020-04-22T06:55:23.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="新增中斷"><a class="header-anchor" href="#新增中斷">#</a>新增中斷</h2><figure class="highlight arduino"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">attachInterrupt</span>(digitalPinToInterrupt(pin), ISR, mode);</span><br><span class="line"><span class="built_in">attachInterrupt</span>(interrupt, ISR, mode);</span><br><span class="line"><span class="built_in">attachInterrupt</span>(pin, ISR, mode);</span><br></pre></td></tr></tbody></table></figure><ul><li>有三種可選：<ul><li>第一個參數代表幾號中斷或是幾號 pin，通常用第一種寫法最保險</li><li>第二個參數放 ISR，當中斷發生時要做的事</li><li>第三個參數為發生中斷的模式，下面有詳細介紹</li></ul></li></ul><h3 id="模式"><a class="header-anchor" href="#模式">#</a>模式</h3><ul><li>LOW：當 pin 處於低電位的時候觸發中斷</li><li>RISING：當 pin 從低電位轉為高電位時觸發中斷</li><li>FALLING：當 pin 從高電位轉為高電位時觸發中斷</li><li>CHANGE：當 pin 的電位發生改變時觸發中斷</li><li>HIGH：當 pin 處於高電位時觸發中斷（只適用 arduino due）</li></ul><h2 id="移除中斷"><a class="header-anchor" href="#移除中斷">#</a>移除中斷</h2><figure class="highlight arduino"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">detachInterrupt</span>(digitalPinToInterrupt(pin));</span><br><span class="line"><span class="built_in">detachInterrupt</span>(interrupt);</span><br><span class="line"><span class="built_in">detachInterrupt</span>(pin);</span><br></pre></td></tr></tbody></table></figure><ul><li>一樣有三個寫法，與新增中斷的第一個參數相同。</li></ul><h2 id="關閉-開啟中斷"><a class="header-anchor" href="#關閉-開啟中斷">#</a>關閉/開啟中斷</h2><figure class="highlight arduino"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">noInterrupts</span>();</span><br><span class="line"><span class="built_in">interrupts</span>();</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-warning"><p><code>noInterrupts</code> 不會將 <code>reset</code> 中斷關閉。</p></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;新增中斷&quot;&gt;&lt;a class=&quot;header-anchor&quot; hr
      
    
    </summary>
    
    
      <category term="Note" scheme="https://blog.lusw.dev/categories/Note/"/>
    
    
      <category term="Arduino" scheme="https://blog.lusw.dev/tags/Arduino/"/>
    
      <category term="interrupt" scheme="https://blog.lusw.dev/tags/interrupt/"/>
    
  </entry>
  
  <entry>
    <title>使用 ANSI 跳脫碼印出有色文字</title>
    <link href="https://blog.lusw.dev/ascii-color.html"/>
    <id>https://blog.lusw.dev/ascii-color.html</id>
    <published>2019-12-26T14:50:57.000Z</published>
    <updated>2020-04-24T08:54:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="ANSI-跳脫碼"><a class="header-anchor" href="#ANSI-跳脫碼">#</a>ANSI 跳脫碼</h2><p>ANSI 跳脫碼，即 ASCII Escape Code，標準 CSI 格式為</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">CSI n1 [;n2 [;...]] m</span><br></pre></td></tr></tbody></table></figure><ul><li><code>n1</code> 通常填入 <code>\x1b</code>，在 ASCII 表中 <code>0x1b</code> 代表著 escape。</li><li><code>n1</code>、<code>n2</code> 為 <strong>SGR (Select Graphic Rendition)</strong>，可參考表格對應相對的值。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[[Linux C] ANSI逃脫碼與printf顏色教學](http://naeilproj.blogspot.com/2015/08/linux-c-c-printf.html)">[1]</span></a></sup></li></ul><h2 id="顏色輸出"><a class="header-anchor" href="#顏色輸出">#</a>顏色輸出</h2><h3 id="範例：粗紅體"><a class="header-anchor" href="#範例：粗紅體">#</a>範例：粗紅體</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">\x1b[;<span class="number">31</span>;<span class="number">1</span>m</span><br></pre></td></tr></tbody></table></figure><ul><li>SGR 30~37 代表著顏色，可參照此表格<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[ANSI跳脫序列](https://zh.wikipedia.org/wiki/ANSI%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97)">[2]</span></a></sup><br><img src="https://i.imgur.com/8HEFwxZ.png" alt=""></li><li>後面的 1 代表粗體，不寫則為一般字型；通常一般的終端機會將粗體顯示成較亮的顏色，而非粗體。</li><li>有些終端機提供用高位的數字指定較亮的顏色，90-97 及 100-107，如下圖<br><img src="https://i.imgur.com/mEP8AjU.png" alt=""></li></ul><h3 id="xterm-256color"><a class="header-anchor" href="#xterm-256color">#</a>xterm-256color</h3><ul><li>使用 8 位元的 SGR，進而提供 256 色的輸出。<br><img src="https://i.imgur.com/hjjHfve.png" alt=""></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="http://naeilproj.blogspot.com/2015/08/linux-c-c-printf.html" target="_blank" rel="noopener">[Linux C] ANSI逃脫碼與printf顏色教學</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/ANSI%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97" target="_blank" rel="noopener">ANSI跳脫序列</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;ANSI-跳脫碼&quot;&gt;&lt;a class=&quot;header-anchor
      
    
    </summary>
    
    
      <category term="C語言" scheme="https://blog.lusw.dev/categories/Clang/"/>
    
    
      <category term="C" scheme="https://blog.lusw.dev/tags/C/"/>
    
      <category term="C語言" scheme="https://blog.lusw.dev/tags/Clang/"/>
    
      <category term="ASCII" scheme="https://blog.lusw.dev/tags/ASCII/"/>
    
      <category term="ANSI" scheme="https://blog.lusw.dev/tags/ANSI/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread GUI 繪圖引擎 - 硬體</title>
    <link href="https://blog.lusw.dev/rtgui-dc-hw.html"/>
    <id>https://blog.lusw.dev/rtgui-dc-hw.html</id>
    <published>2019-03-13T03:27:41.000Z</published>
    <updated>2020-04-23T05:01:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Rtgui 中的 dc（drawable canvas） 也就是繪圖引擎，可以說是 rtgui 中最重要的一個部分，其中分成 3 個部分：給硬體的 dc_hw、給 buffer 的 dc_buffer 以及給 client 的。</p><p>接下來將會追蹤 dc_hw 中的程式碼，分析 rtgui 是如何在螢幕上面描繪點線面。</p><hr><h2 id="結構"><a class="header-anchor" href="#結構">#</a>結構</h2><h3 id="dc"><a class="header-anchor" href="#dc">#</a>dc</h3><div class="alert alert-success"><p><strong>File:</strong> dc.h</p></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The abstract device context</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Normally, a DC is a drawable canvas, user can draw point/line/cycle etc</span></span><br><span class="line"><span class="comment"> * on the DC.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are several kinds of DC:</span></span><br><span class="line"><span class="comment"> * - Hardware DC;</span></span><br><span class="line"><span class="comment"> * - Client DC;</span></span><br><span class="line"><span class="comment"> * - Buffer DC;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* type of device context */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dc engine */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_engine</span> *<span class="title">engine</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="dc-engine"><a class="header-anchor" href="#dc-engine">#</a>dc_engine</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_engine</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* interface */</span></span><br><span class="line">    <span class="keyword">void</span> (*draw_point)(struct rtgui_dc *dc, <span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">    <span class="keyword">void</span> (*draw_color_point)(struct rtgui_dc *dc, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">rtgui_color_t</span> color);</span><br><span class="line">    <span class="keyword">void</span> (*draw_vline)(struct rtgui_dc *dc, <span class="keyword">int</span> x, <span class="keyword">int</span> y1, <span class="keyword">int</span> y2);</span><br><span class="line">    <span class="keyword">void</span> (*draw_hline)(struct rtgui_dc *dc, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y);</span><br><span class="line">    <span class="keyword">void</span> (*fill_rect)(struct rtgui_dc *dc, <span class="keyword">rtgui_rect_t</span> *rect);</span><br><span class="line">    <span class="keyword">void</span> (*blit_line)(struct rtgui_dc *dc, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y, <span class="keyword">rt_uint8_t</span> *line_data);</span><br><span class="line">    <span class="keyword">void</span> (*blit)(struct rtgui_dc *dc, struct rtgui_point *dc_point, struct rtgui_dc *dest, <span class="keyword">rtgui_rect_t</span> *rect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*fini)(struct rtgui_dc *dc);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="dc-hw"><a class="header-anchor" href="#dc-hw">#</a>dc_hw</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The hardware device context</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The hardware DC is a context based on hardware device, for examle the</span></span><br><span class="line"><span class="comment"> * LCD device. The operations on the hardware DC are reflected to the real</span></span><br><span class="line"><span class="comment"> * hardware.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc</span> <span class="title">parent</span>;</span></span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *owner;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_graphic_driver</span> *<span class="title">hw_driver</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="hw-engine"><a class="header-anchor" href="#hw-engine">#</a>hw_engine</h3><div class="alert alert-success"><p><strong>File:</strong> dc_hw.c</p></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_engine</span> <span class="title">dc_hw_engine</span> =</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    rtgui_dc_hw_draw_point,</span><br><span class="line">    rtgui_dc_hw_draw_color_point,</span><br><span class="line">    rtgui_dc_hw_draw_vline,</span><br><span class="line">    rtgui_dc_hw_draw_hline,</span><br><span class="line">    rtgui_dc_hw_fill_rect,</span><br><span class="line">    rtgui_dc_hw_blit_line,</span><br><span class="line">    rtgui_dc_hw_blit,</span><br><span class="line"></span><br><span class="line">    rtgui_dc_hw_fini,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="啟動-dc"><a class="header-anchor" href="#啟動-dc">#</a>啟動 dc</h2><p>我們可以從 rtgui 官方提供的範例發現，在使用 dc 前，需要先利用 <code>rtgui_dc_begin_drawing</code> 來啟動引擎，並在結束時呼叫 <code>rtgui_dc_end_drawing</code>；而啟動時，會判斷要使用哪種 dc，並啟動，如 1866 至 1871 行</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1866</span><br><span class="line">1867</span><br><span class="line">1868</span><br><span class="line">1869</span><br><span class="line">1870</span><br><span class="line">1871</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* create client or hardware DC */</span></span><br><span class="line">    <span class="keyword">if</span> ((rtgui_region_is_flat(&amp;owner-&gt;clip) == RT_EOK) &amp;&amp;</span><br><span class="line">            rtgui_rect_is_equal(&amp;(owner-&gt;extent), &amp;(owner-&gt;clip.extents)) == RT_EOK)</span><br><span class="line">        dc = rtgui_dc_hw_create(owner);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dc = rtgui_dc_client_create(owner);</span><br></pre></td></tr></tbody></table></figure><p>如果判斷為 hw，則進入 <code>rtgui_dc_hw_create</code></p><hr><h2 id="建立-dc"><a class="header-anchor" href="#建立-dc">#</a>建立 dc</h2><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*owner</code></th></tr></thead><tbody><tr><td>建立 dc</td><td>dc 指標</td><td>dc 擁有者</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct rtgui_dc *<span class="title">rtgui_dc_hw_create</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *owner)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* adjudge owner */</span></span><br><span class="line">    <span class="keyword">if</span> (owner == RT_NULL || owner-&gt;toplevel == RT_NULL) <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create DC */</span></span><br><span class="line">    dc = (struct rtgui_dc_hw *) rtgui_malloc(<span class="keyword">sizeof</span>(struct rtgui_dc_hw));</span><br><span class="line">    <span class="keyword">if</span> (dc)</span><br><span class="line">    {</span><br><span class="line">        dc-&gt;parent.type = RTGUI_DC_HW;</span><br><span class="line">        dc-&gt;parent.engine = &amp;dc_hw_engine;</span><br><span class="line">        dc-&gt;owner = owner;</span><br><span class="line">        dc-&gt;hw_driver = rtgui_graphic_driver_get_default();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &amp;(dc-&gt;parent);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="運作-dc-畫圖"><a class="header-anchor" href="#運作-dc-畫圖">#</a>運作 dc (畫圖)</h2><h3 id="點"><a class="header-anchor" href="#點">#</a>點</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>畫點</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*self</code></th><th><code>x</code></th><th><code>y</code></th></tr></thead><tbody><tr><td>dc 本體</td><td>座標 x</td><td>座標 y</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * draw a logic point on device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_draw_point</span><span class="params">(struct rtgui_dc *self, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(self != RT_NULL);</span><br><span class="line">    dc = (struct rtgui_dc_hw *) self;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    x = x + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    y = y + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* draw this point */</span></span><br><span class="line">    dc-&gt;hw_driver-&gt;ops-&gt;set_pixel(&amp;(dc-&gt;owner-&gt;gc.foreground), x, y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>首先傳進去的座標一律為邏輯位置，也就是以此 dc 所屬物件（有可能是視窗、元件等）的 $(x_1,y_1)$ 為原點之座標；由於 $(x_1,y_1)$ 為該物件（通常為矩形）的左下角，所以傳入的座標不會有負號。</p><p>接著將邏輯座標轉為實際座標（也就是螢幕上的真正位置），所以把 $(x,y)$ 轉成 $(x+x_1,y+y_1)$；由於 dc 是跟隨物件的，所以新座標不可超過 $(x_2,y_2)$，也就是右上角。</p><p>最後利用驅動中設定好的 <code>set_pixel</code> 函數來上色，這裡使用預設顏色。</p><hr><h3 id="彩色點"><a class="header-anchor" href="#彩色點">#</a>彩色點</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>畫彩色點</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*self</code></th><th><code>x</code></th><th><code>y</code></th><th><code>color</code></th></tr></thead><tbody><tr><td>dc 本體</td><td>座標 x</td><td>座標 y</td><td>所選的顏色</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_draw_color_point</span><span class="params">(struct rtgui_dc *self, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">rtgui_color_t</span> color)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(self != RT_NULL);</span><br><span class="line">    dc = (struct rtgui_dc_hw *) self;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    x = x + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    y = y + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* draw this point */</span></span><br><span class="line">    dc-&gt;hw_driver-&gt;ops-&gt;set_pixel(&amp;color, x, y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>跟上面最大的不同是可以選顏色 (131)。</p><hr><h3 id="水平線"><a class="header-anchor" href="#水平線">#</a>水平線</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * draw a logic vertical line on device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_draw_vline</span><span class="params">(struct rtgui_dc *self, <span class="keyword">int</span> x, <span class="keyword">int</span> y1, <span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(self != RT_NULL);</span><br><span class="line">    dc = (struct rtgui_dc_hw *) self;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    x = x + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    y1 = y1 + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    y2 = y2 + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y1 &gt; y2)</span><br><span class="line">        _int_swap(y1, y2);</span><br><span class="line">    <span class="keyword">if</span> (y1 &gt; dc-&gt;owner-&gt;extent.y2 || y2 &lt; dc-&gt;owner-&gt;extent.y1)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y1 &lt; dc-&gt;owner-&gt;extent.y1)</span><br><span class="line">        y1 = dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y2 &gt; dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        y2 = dc-&gt;owner-&gt;extent.y2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* draw vline */</span></span><br><span class="line">    dc-&gt;hw_driver-&gt;ops-&gt;draw_vline(&amp;(dc-&gt;owner-&gt;gc.foreground), x, y1, y2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="鉛直線"><a class="header-anchor" href="#鉛直線">#</a>鉛直線</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * draw a logic horizontal line on device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_draw_hline</span><span class="params">(struct rtgui_dc *self, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(self != RT_NULL);</span><br><span class="line">    dc = (struct rtgui_dc_hw *) self;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    y = y + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* convert logic to device */</span></span><br><span class="line">    x1 = x1 + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    x2 = x2 + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; x2)</span><br><span class="line">        _int_swap(x1, x2);</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; dc-&gt;owner-&gt;extent.x2 || x2 &lt; dc-&gt;owner-&gt;extent.x1)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x1 &lt; dc-&gt;owner-&gt;extent.x1)</span><br><span class="line">        x1 = dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x2 &gt; dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        x2 = dc-&gt;owner-&gt;extent.x2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* draw hline */</span></span><br><span class="line">    dc-&gt;hw_driver-&gt;ops-&gt;draw_hline(&amp;(dc-&gt;owner-&gt;gc.foreground), x1, x2, y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="矩形"><a class="header-anchor" href="#矩形">#</a>矩形</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_fill_rect</span><span class="params">(struct rtgui_dc *self, struct rtgui_rect *rect)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rtgui_color_t</span> color;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> y1, y2, x1, x2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(self != RT_NULL);</span><br><span class="line">    RT_ASSERT(rect);</span><br><span class="line">    dc = (struct rtgui_dc_hw *) self;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get background color */</span></span><br><span class="line">    color = dc-&gt;owner-&gt;gc.background;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* convert logic to device */</span></span><br><span class="line">    x1 = rect-&gt;x1 + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x1 &lt; dc-&gt;owner-&gt;extent.x1)</span><br><span class="line">        x1 = dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    x2 = rect-&gt;x2 + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x2 &lt; dc-&gt;owner-&gt;extent.x1)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x2 &gt; dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        x2 = dc-&gt;owner-&gt;extent.x2;</span><br><span class="line"></span><br><span class="line">    y1 = rect-&gt;y1 + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y1 &gt; dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (y1 &lt; dc-&gt;owner-&gt;extent.y1)</span><br><span class="line">        y1 = dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    y2 = rect-&gt;y2 + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y2 &lt; dc-&gt;owner-&gt;extent.y1)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (y2 &gt; dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        y2 = dc-&gt;owner-&gt;extent.y2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fill rect */</span></span><br><span class="line">    <span class="keyword">for</span> (; y1 &lt; y2; y1++)</span><br><span class="line">    {</span><br><span class="line">        dc-&gt;hw_driver-&gt;ops-&gt;draw_hline(&amp;color, x1, x2, y1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="blit"><a class="header-anchor" href="#blit">#</a>blit(?)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_blit_line</span><span class="params">(struct rtgui_dc *self, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y, <span class="keyword">rt_uint8_t</span> *line_data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(self != RT_NULL);</span><br><span class="line">    dc = (struct rtgui_dc_hw *) self;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* convert logic to device */</span></span><br><span class="line">    <span class="keyword">if</span> (y &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    y = y + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y &gt; dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    x1 = x1 + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    x2 = x2 + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; x2)</span><br><span class="line">        _int_swap(x1, x2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; dc-&gt;owner-&gt;extent.x2 || x2 &lt; dc-&gt;owner-&gt;extent.x1)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x1 &lt; dc-&gt;owner-&gt;extent.x1)</span><br><span class="line">        x1 = dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x2 &gt; dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        x2 = dc-&gt;owner-&gt;extent.x2;</span><br><span class="line"></span><br><span class="line">    dc-&gt;hw_driver-&gt;ops-&gt;draw_raw_hline(line_data, x1, x2, y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_blit</span><span class="params">(struct rtgui_dc *dc,</span></span></span><br><span class="line"><span class="function"><span class="params">                             struct rtgui_point *dc_point,</span></span></span><br><span class="line"><span class="function"><span class="params">                             struct rtgui_dc *dest,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">rtgui_rect_t</span> *rect)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* not blit in hardware dc */</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;Rtgui 中的 dc（drawable canvas） 也就是繪圖引擎，可
      
    
    </summary>
    
    
      <category term="RT-Thread GUI" scheme="https://blog.lusw.dev/categories/RT-Thread-GUI/"/>
    
    
      <category term="kernel" scheme="https://blog.lusw.dev/tags/kernel/"/>
    
      <category term="RT-Thread" scheme="https://blog.lusw.dev/tags/RT-Thread/"/>
    
      <category term="GUI" scheme="https://blog.lusw.dev/tags/GUI/"/>
    
      <category term="dc" scheme="https://blog.lusw.dev/tags/dc/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread GUI Server</title>
    <link href="https://blog.lusw.dev/rtgui-server.html"/>
    <id>https://blog.lusw.dev/rtgui-server.html</id>
    <published>2019-02-23T07:08:11.000Z</published>
    <updated>2020-04-23T05:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="基本事件結構"><a class="header-anchor" href="#基本事件結構">#</a>基本事件結構</h2><p>server 掌管整個 GUI system 的所有事件 (event)，而根據不同的事件定義不同的結構；在每個不同的結構中都有基本的欄位 <code>_RTGUI_EVENT_WIN_ELEMENTS</code>：</p><div class="alert alert-success"><p><strong>File:</strong> event.c</p></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RTGUI Window Event</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _RTGUI_EVENT_WIN_ELEMENTS \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event</span> <span class="title">parent</span>;</span> \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_win</span> *<span class="title">wid</span>;</span></span><br></pre></td></tr></tbody></table></figure><p><code>rtgui_event</code> 即為事件的基本結構：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* the event type */</span></span><br><span class="line">    <span class="keyword">enum</span> _rtgui_event_type type;</span><br><span class="line">    <span class="comment">/* user field of event */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span> user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the event sender */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_app</span> *<span class="title">sender</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* mailbox to acknowledge request */</span></span><br><span class="line">    <span class="keyword">rt_mailbox_t</span> ack;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event</span> <span class="title">rtgui_event_t</span>;</span></span><br></pre></td></tr></tbody></table></figure><hr><h3 id="基本結構設定"><a class="header-anchor" href="#基本結構設定">#</a>基本結構設定</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTGUI_EVENT_INIT(e, t)  do      \</span></span><br><span class="line">{                                       \</span><br><span class="line">    (e)-&gt;type = (t);                    \</span><br><span class="line">    (e)-&gt;user = <span class="number">0</span>;                      \</span><br><span class="line">    (e)-&gt;sender = rtgui_app_self();     \</span><br><span class="line">    (e)-&gt;ack = RT_NULL;                 \</span><br><span class="line">} <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="啟動-server"><a class="header-anchor" href="#啟動-server">#</a>啟動 server</h2><div class="alert alert-success"><p><strong>File:</strong> server.c</p></div><p>首先，定義一個 app 名叫 server :</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_app</span> *<span class="title">rtgui_server_app</span> = <span class="title">RT_NULL</span>;</span></span><br></pre></td></tr></tbody></table></figure><p>接著透過 <code>rtgui_server_entry</code> 啟動 app，也就是 server:</p><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*parameter</code></th></tr></thead><tbody><tr><td>啟動 server</td><td>void</td><td>未使用</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rtgui server thread's entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_server_entry</span><span class="params">(<span class="keyword">void</span> *parameter)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32_NATIVE</span></span><br><span class="line">    <span class="comment">/* set the server thread to highest */</span></span><br><span class="line">    HANDLE hCurrentThread = GetCurrentThread();</span><br><span class="line">    SetThreadPriority(hCurrentThread, THREAD_PRIORITY_HIGHEST);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create rtgui server application */</span></span><br><span class="line">    rtgui_server_app = rtgui_app_create(<span class="string">"rtgui"</span>);</span><br><span class="line">    <span class="keyword">if</span> (rtgui_server_app == RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        rt_kprintf(<span class="string">"Create GUI server failed.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    rtgui_object_set_event_handler(RTGUI_OBJECT(rtgui_server_app),</span><br><span class="line">                                   rtgui_server_event_handler);</span><br><span class="line">    <span class="comment">/* init mouse and show */</span></span><br><span class="line">    rtgui_mouse_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTGUI_USING_MOUSE_CURSOR</span></span><br><span class="line">    rtgui_mouse_show_cursor();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    rtgui_app_run(rtgui_server_app);</span><br><span class="line"></span><br><span class="line">    rtgui_app_destroy(rtgui_server_app);</span><br><span class="line">    rtgui_server_app = RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最後會進入 <code>rtgui_app_run</code> 並正式開始執行 server，也就是進入所屬的 event handler</p><hr><h2 id="Event-Handler"><a class="header-anchor" href="#Event-Handler">#</a>Event Handler</h2><p>Event handler 也就是 server 的進入點</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;基本事件結構&quot;&gt;&lt;a class=&quot;header-anchor&quot; 
      
    
    </summary>
    
    
      <category term="RT-Thread GUI" scheme="https://blog.lusw.dev/categories/RT-Thread-GUI/"/>
    
    
      <category term="kernel" scheme="https://blog.lusw.dev/tags/kernel/"/>
    
      <category term="RT-Thread" scheme="https://blog.lusw.dev/tags/RT-Thread/"/>
    
      <category term="GUI" scheme="https://blog.lusw.dev/tags/GUI/"/>
    
      <category term="server" scheme="https://blog.lusw.dev/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread GUI Window</title>
    <link href="https://blog.lusw.dev/rtgui-window.html"/>
    <id>https://blog.lusw.dev/rtgui-window.html</id>
    <published>2019-01-29T12:53:02.000Z</published>
    <updated>2020-04-23T05:02:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="alert alert-success"><p><strong>File:</strong> window.h</p></div><h2 id="結構"><a class="header-anchor" href="#結構">#</a>結構</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_win</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* inherit from container */</span></span><br><span class="line">    <span class="keyword">rtgui_container_t</span> parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* update count */</span></span><br><span class="line">    <span class="keyword">rt_base_t</span> update;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* drawing count */</span></span><br><span class="line">    <span class="keyword">rt_base_t</span> drawing;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span> <span class="title">drawing_rect</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parent window. RT_NULL if the window is a top level window */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_win</span> *<span class="title">parent_window</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_region</span> <span class="title">outer_clip</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span> <span class="title">outer_extent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the widget that will grab the focus in current window */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> *<span class="title">focused_widget</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* which app I belong */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_app</span> *<span class="title">app</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* window style */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span> style;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* window state flag */</span></span><br><span class="line">    <span class="keyword">enum</span> rtgui_win_flag flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rtgui_modal_code_t</span> modal_code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* last mouse event handled widget */</span></span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *last_mevent_widget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* window title */</span></span><br><span class="line">    <span class="keyword">char</span> *title;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_wintitle</span> *_<span class="title">title_wgt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call back */</span></span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*on_activate)(struct rtgui_object *widget, struct rtgui_event *event);</span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*on_deactivate)(struct rtgui_object *widget, struct rtgui_event *event);</span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*on_close)(struct rtgui_object *widget, struct rtgui_event *event);</span><br><span class="line">    <span class="comment">/* the key is sent to the focused widget by default. If the focused widget</span></span><br><span class="line"><span class="comment">     * and all of it's parents didn't handle the key event, it will be handled</span></span><br><span class="line"><span class="comment">     * by @func on_key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If you want to handle key event on your own, it's better to overload</span></span><br><span class="line"><span class="comment">     * this function other than handle EVENT_KBD in event_handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*on_key)(struct rtgui_object *widget, struct rtgui_event *event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reserved user data */</span></span><br><span class="line">    <span class="keyword">void</span> *user_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Private data. */</span></span><br><span class="line">    <span class="keyword">rt_base_t</span> (*_do_show)(struct rtgui_win *win);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* app ref_count */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span> app_ref_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* win magic flag, magic value is 0xA5A55A5A */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span>magic;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="定義物件類型"><a class="header-anchor" href="#定義物件類型">#</a>定義物件類型</h3><div class="alert alert-success"><p><strong>File:</strong> window.c</p></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_CLASS_TYPE(win, <span class="string">"win"</span>,</span><br><span class="line">                  RTGUI_PARENT_TYPE(container),</span><br><span class="line">                  _rtgui_win_constructor,</span><br><span class="line">                  _rtgui_win_destructor,</span><br><span class="line">                  <span class="keyword">sizeof</span>(struct rtgui_win));</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="建立視窗"><a class="header-anchor" href="#建立視窗">#</a>建立視窗</h2><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立視窗</td><td>視窗指標</td></tr></tbody></table><table><thead><tr><th><code>*parent_window</code></th><th><code>*title</code></th><th><code>*rect</code></th><th><code>style</code></th></tr></thead><tbody><tr><td>上層視窗</td><td>視窗標題</td><td>視窗的大小</td><td>一些風格</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_win_t</span> *rtgui_win_create(struct rtgui_win *parent_window,</span><br><span class="line">                              <span class="keyword">const</span> <span class="keyword">char</span> *title,</span><br><span class="line">                              <span class="keyword">rtgui_rect_t</span> *rect,</span><br><span class="line">                              <span class="keyword">rt_uint16_t</span> style)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_win</span> *<span class="title">win</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate win memory */</span></span><br><span class="line">    win = RTGUI_WIN(rtgui_widget_create(RTGUI_WIN_TYPE));</span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rtgui_win_init(win, parent_window, title, rect, style) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rtgui_widget_destroy(RTGUI_WIDGET(win));</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> win;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_create);</span><br></pre></td></tr></tbody></table></figure><p>透過 <code>rtgui_win_init</code> 完成設定</p><hr><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化視窗</td><td>檢查碼</td></tr></tbody></table><table><thead><tr><th><code>*win</code></th><th><code>*parent_window</code></th><th><code>*title</code></th><th><code>*rect</code></th><th><code>style</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>上層視窗</td><td>視窗標題</td><td>視窗的大小</td><td>一些風格</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rtgui_win_init</span><span class="params">(struct rtgui_win *win, struct rtgui_win *parent_window,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">char</span> *title,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">rtgui_rect_t</span> *rect,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">rt_uint16_t</span> style)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set parent window */</span></span><br><span class="line">    win-&gt;parent_window = parent_window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set title, rect and style */</span></span><br><span class="line">    <span class="keyword">if</span> (title != RT_NULL)</span><br><span class="line">        win-&gt;title = rt_strdup(title);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        win-&gt;title = RT_NULL;</span><br><span class="line"></span><br><span class="line">    rtgui_widget_set_rect(RTGUI_WIDGET(win), rect);</span><br><span class="line">    win-&gt;style = style;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!((style &amp; RTGUI_WIN_STYLE_NO_TITLE) &amp;&amp; (style &amp; RTGUI_WIN_STYLE_NO_BORDER)))</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span> <span class="title">trect</span> = *<span class="title">rect</span>;</span></span><br><span class="line"></span><br><span class="line">        win-&gt;_title_wgt = rtgui_wintitle_create(win);</span><br><span class="line">        <span class="keyword">if</span> (!win-&gt;_title_wgt)</span><br><span class="line">            <span class="keyword">goto</span> __on_err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(style &amp; RTGUI_WIN_STYLE_NO_BORDER))</span><br><span class="line">        {</span><br><span class="line">            rtgui_rect_inflate(&amp;trect, WINTITLE_BORDER_SIZE);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!(style &amp; RTGUI_WIN_STYLE_NO_TITLE))</span><br><span class="line">        {</span><br><span class="line">            trect.y1 -= WINTITLE_HEIGHT;</span><br><span class="line">        }</span><br><span class="line">        rtgui_widget_set_rect(RTGUI_WIDGET(win-&gt;_title_wgt), &amp;trect);</span><br><span class="line">        <span class="comment">/* Update the clip of the wintitle manually. */</span></span><br><span class="line">        rtgui_region_subtract_rect(&amp;(RTGUI_WIDGET(win-&gt;_title_wgt)-&gt;clip),</span><br><span class="line">                                   &amp;(RTGUI_WIDGET(win-&gt;_title_wgt)-&gt;clip),</span><br><span class="line">                                   &amp;(RTGUI_WIDGET(win)-&gt;extent));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The window title is always un-hidden for simplicity. */</span></span><br><span class="line">        rtgui_widget_show(RTGUI_WIDGET(win-&gt;_title_wgt));</span><br><span class="line">        rtgui_region_init_with_extents(&amp;win-&gt;outer_clip, &amp;trect);</span><br><span class="line">        win-&gt;outer_extent = trect;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        rtgui_region_init_with_extents(&amp;win-&gt;outer_clip, rect);</span><br><span class="line">        win-&gt;outer_extent = *rect;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_rtgui_win_create_in_server(win) == RT_FALSE)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> __on_err;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    win-&gt;app-&gt;window_cnt++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__on_err:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_init);</span><br></pre></td></tr></tbody></table></figure><h3 id="建立主視窗"><a class="header-anchor" href="#建立主視窗">#</a>建立主視窗</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立主視窗</td><td>視窗指標</td></tr></tbody></table><table><thead><tr><th><code>*parent_window</code></th><th><code>*title</code></th><th><code>style</code></th></tr></thead><tbody><tr><td>上層視窗</td><td>視窗標題</td><td>一些風格</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_win_t</span> *rtgui_mainwin_create(struct rtgui_win *parent_window, <span class="keyword">const</span> <span class="keyword">char</span> *title, <span class="keyword">rt_uint16_t</span> style)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span> <span class="title">rect</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get rect of main window */</span></span><br><span class="line">    rtgui_get_mainwin_rect(&amp;rect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rtgui_win_create(parent_window, title, &amp;rect, style);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_mainwin_create);</span><br></pre></td></tr></tbody></table></figure><p>建立一個固定大小的視窗，這個大小被設定在 <code>_mainwin_rect</code> 這個全域變數裡面，可以透過 <code>rtgui_get_mainwin_rect</code> 來取得這個值。</p><hr><h2 id="刪除視窗"><a class="header-anchor" href="#刪除視窗">#</a>刪除視窗</h2><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>刪除視窗</td><td>void</td><td>目標視窗</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_destroy</span><span class="params">(struct rtgui_win *win)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* close the window first if it's not. */</span></span><br><span class="line">    <span class="keyword">if</span> (!(win-&gt;flag &amp; RTGUI_WIN_FLAG_CLOSED))</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_close</span> <span class="title">eclose</span>;</span></span><br><span class="line"></span><br><span class="line">        RTGUI_EVENT_WIN_CLOSE_INIT(&amp;eclose);</span><br><span class="line">        eclose.wid = win;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (win-&gt;style &amp; RTGUI_WIN_STYLE_DESTROY_ON_CLOSE)</span><br><span class="line">        {</span><br><span class="line">            _rtgui_win_deal_close(win,</span><br><span class="line">                                  (struct rtgui_event *)&amp;eclose,</span><br><span class="line">                                  RT_TRUE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            _rtgui_win_deal_close(win,</span><br><span class="line">                                  (struct rtgui_event *)&amp;eclose,</span><br><span class="line">                                  RT_TRUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_MODAL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* set the RTGUI_WIN_STYLE_DESTROY_ON_CLOSE flag so the window will be</span></span><br><span class="line"><span class="comment">         * destroyed after the event_loop */</span></span><br><span class="line">        win-&gt;style |= RTGUI_WIN_STYLE_DESTROY_ON_CLOSE;</span><br><span class="line">        rtgui_win_end_modal(win, RTGUI_MODAL_CANCEL);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        rtgui_widget_destroy(RTGUI_WIDGET(win));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_destroy);</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="關閉視窗"><a class="header-anchor" href="#關閉視窗">#</a>關閉視窗</h2><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>關閉視窗</td><td>void</td><td>目標視窗</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* send a close event to myself to get a consistent behavior */</span></span><br><span class="line"><span class="keyword">rt_bool_t</span> rtgui_win_close(struct rtgui_win *win)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_close</span> <span class="title">eclose</span>;</span></span><br><span class="line"></span><br><span class="line">    RTGUI_EVENT_WIN_CLOSE_INIT(&amp;eclose);</span><br><span class="line">    eclose.wid = win;</span><br><span class="line">    <span class="keyword">return</span> _rtgui_win_deal_close(win,</span><br><span class="line">                                 (struct rtgui_event *)&amp;eclose,</span><br><span class="line">                                 RT_FALSE);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_close);</span><br></pre></td></tr></tbody></table></figure><p>使用 <code>_rtgui_win_deal_close</code> 完成關閉動作</p><hr><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>刪除視窗</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*win</code></th><th><code>*event</code></th><th><code>force_close</code></th></tr></thead><tbody><tr><td>目標視窗</td><td>關閉事件</td><td>是否要強致關閉</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">rt_bool_t</span> _rtgui_win_deal_close(struct rtgui_win *win,</span><br><span class="line">                                       struct rtgui_event *event,</span><br><span class="line">                                       <span class="keyword">rt_bool_t</span> force_close)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (win-&gt;on_close != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> ((win-&gt;on_close(RTGUI_OBJECT(win), event) == RT_FALSE) &amp;&amp; !force_close)</span><br><span class="line">            <span class="keyword">return</span> RT_FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    rtgui_win_hide(win);</span><br><span class="line"></span><br><span class="line">    win-&gt;flag |= RTGUI_WIN_FLAG_CLOSED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_MODAL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* rtgui_win_end_modal cleared the RTGUI_WIN_FLAG_MODAL in win-&gt;flag so</span></span><br><span class="line"><span class="comment">         * we have to record it. */</span></span><br><span class="line">        rtgui_win_end_modal(win, RTGUI_MODAL_CANCEL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    win-&gt;app-&gt;window_cnt--;</span><br><span class="line">    <span class="keyword">if</span> (win-&gt;app-&gt;window_cnt == <span class="number">0</span> &amp;&amp; !(win-&gt;app-&gt;state_flag &amp; RTGUI_APP_FLAG_KEEP))</span><br><span class="line">    {</span><br><span class="line">        rtgui_app_exit(rtgui_app_self(), <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;style &amp; RTGUI_WIN_STYLE_DESTROY_ON_CLOSE)</span><br><span class="line">    {</span><br><span class="line">        rtgui_win_destroy(win);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="設定視窗"><a class="header-anchor" href="#設定視窗">#</a>設定視窗</h2><h3 id="大小"><a class="header-anchor" href="#大小">#</a>大小</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定視窗大小</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*win</code></th><th><code>*rect</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>新大小</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_set_rect</span><span class="params">(<span class="keyword">rtgui_win_t</span> *win, <span class="keyword">rtgui_rect_t</span> *rect)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_resize</span> <span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL || rect == RT_NULL) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    RTGUI_WIDGET(win)-&gt;extent = *rect;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_CONNECTED)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* set window resize event to server */</span></span><br><span class="line">        RTGUI_EVENT_WIN_RESIZE_INIT(&amp;event);</span><br><span class="line">        event.wid = win;</span><br><span class="line">        event.rect = *rect;</span><br><span class="line"></span><br><span class="line">        rtgui_server_post_event(&amp;(event.parent), <span class="keyword">sizeof</span>(struct rtgui_event_win_resize));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_set_rect);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="OnActive-函式"><a class="header-anchor" href="#OnActive-函式">#</a>OnActive 函式</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 OnActive 函式</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*win</code></th><th><code>handler</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>OnActive 函式</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_set_onactivate</span><span class="params">(<span class="keyword">rtgui_win_t</span> *win, rtgui_event_handler_ptr handler)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (win != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        win-&gt;on_activate = handler;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_set_onactivate);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="OnDeactive-函式"><a class="header-anchor" href="#OnDeactive-函式">#</a>OnDeactive 函式</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 OnDeactive 函式</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*win</code></th><th><code>handler</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>OnDeactive 函式</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_set_ondeactivate</span><span class="params">(<span class="keyword">rtgui_win_t</span> *win, rtgui_event_handler_ptr handler)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (win != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        win-&gt;on_deactivate = handler;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_set_ondeactivate);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="OnClose-函式"><a class="header-anchor" href="#OnClose-函式">#</a>OnClose 函式</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 OnClose 函式</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*win</code></th><th><code>handler</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>OnClose 函式</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_set_onclose</span><span class="params">(<span class="keyword">rtgui_win_t</span> *win, rtgui_event_handler_ptr handler)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (win != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        win-&gt;on_close = handler;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_set_onclose);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="OnKey"><a class="header-anchor" href="#OnKey">#</a>OnKey</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 OnKey 函式</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*win</code></th><th><code>handler</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>OnKey 函式</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_set_onkey</span><span class="params">(<span class="keyword">rtgui_win_t</span> *win, rtgui_event_handler_ptr handler)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (win != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        win-&gt;on_key = handler;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_set_onkey);</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="視窗的行為"><a class="header-anchor" href="#視窗的行為">#</a>視窗的行為</h2><h3 id="動態模式"><a class="header-anchor" href="#動態模式">#</a>動態模式</h3><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>進入動態模式</td><td>檢查碼</td><td>視窗本體</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_base_t</span> rtgui_win_enter_modal(struct rtgui_win *win)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_base_t</span> exit_code = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_modal_enter</span> <span class="title">emodal</span>;</span></span><br><span class="line"></span><br><span class="line">    RTGUI_EVENT_WIN_MODAL_ENTER_INIT(&amp;emodal);</span><br><span class="line">    emodal.wid = win;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rtgui_server_post_event_sync((struct rtgui_event *)&amp;emodal,</span><br><span class="line">                                     <span class="keyword">sizeof</span>(emodal)) != RT_EOK)</span><br><span class="line">        <span class="keyword">return</span> exit_code;</span><br><span class="line"></span><br><span class="line">    win-&gt;flag |= RTGUI_WIN_FLAG_MODAL;</span><br><span class="line">    win-&gt;app_ref_count = win-&gt;app-&gt;ref_count + <span class="number">1</span>;</span><br><span class="line">    exit_code = rtgui_app_run(win-&gt;app);</span><br><span class="line">    win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_MODAL;</span><br><span class="line"></span><br><span class="line">    rtgui_win_hide(win);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exit_code;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_enter_modal);</span><br></pre></td></tr></tbody></table></figure><hr><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>離開動態模式</td><td>檢查碼</td></tr></tbody></table><table><thead><tr><th><code>*win</code></th><th><code>modal_code</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>動態模式編號</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_end_modal</span><span class="params">(struct rtgui_win *win, <span class="keyword">rtgui_modal_code_t</span> modal_code)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL || !(win-&gt;flag &amp; RTGUI_WIN_FLAG_MODAL))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (win-&gt;app_ref_count &lt; win-&gt;app-&gt;ref_count)</span><br><span class="line">    {</span><br><span class="line">        rtgui_app_exit(win-&gt;app, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        i ++;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">1000</span>)</span><br><span class="line">        {</span><br><span class="line">            rt_kprintf(<span class="string">" =*=&gt; rtgui_win_end_modal while (win-&gt;app_ref_count &lt; win-&gt;app-&gt;ref_count) \n"</span>);</span><br><span class="line">            RT_ASSERT(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    rtgui_app_exit(win-&gt;app, modal_code);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remove modal mode */</span></span><br><span class="line">    win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_MODAL;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_end_modal);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="現身"><a class="header-anchor" href="#現身">#</a>現身</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>現身該視窗</td><td>檢查碼</td></tr></tbody></table><table><thead><tr><th><code>*win</code></th><th><code>is_modal</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>是否為動態模式</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_base_t</span> rtgui_win_show(struct rtgui_win *win, <span class="keyword">rt_bool_t</span> is_modal)</span><br><span class="line">{</span><br><span class="line">    RTGUI_WIDGET_UNHIDE(win);</span><br><span class="line"></span><br><span class="line">    win-&gt;magic = RTGUI_WIN_MAGIC;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_modal)</span><br><span class="line">        win-&gt;flag |= RTGUI_WIN_FLAG_MODAL;</span><br><span class="line">    <span class="keyword">if</span> (win-&gt;_do_show)</span><br><span class="line">        <span class="keyword">return</span> win-&gt;_do_show(win);</span><br><span class="line">    <span class="keyword">return</span> rtgui_win_do_show(win);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_show);</span><br></pre></td></tr></tbody></table></figure><p>如果視窗本身有設定 <code>_do_show</code> 函式的話，則呼叫本身的；否則呼叫 <code>rtgui_win_do_show</code></p><hr><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>視窗現身</td><td>檢查碼</td><td>視窗本體</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_base_t</span> rtgui_win_do_show(struct rtgui_win *win)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_base_t</span> exit_code = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_app</span> *<span class="title">app</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_show</span> <span class="title">eshow</span>;</span></span><br><span class="line"></span><br><span class="line">    RTGUI_EVENT_WIN_SHOW_INIT(&amp;eshow);</span><br><span class="line">    eshow.wid = win;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> exit_code;</span><br><span class="line"></span><br><span class="line">    win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_CLOSED;</span><br><span class="line">    win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_CB_PRESSED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if it does not register into server, create it in server */</span></span><br><span class="line">    <span class="keyword">if</span> (!(win-&gt;flag &amp; RTGUI_WIN_FLAG_CONNECTED))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (_rtgui_win_create_in_server(win) == RT_FALSE)</span><br><span class="line">            <span class="keyword">return</span> exit_code;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set window unhidden before notify the server */</span></span><br><span class="line">    rtgui_widget_show(RTGUI_WIDGET(win));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rtgui_server_post_event_sync(RTGUI_EVENT(&amp;eshow),</span><br><span class="line">                                     <span class="keyword">sizeof</span>(struct rtgui_event_win_show)) != RT_EOK)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* It could not be shown if a parent window is hidden. */</span></span><br><span class="line">        rtgui_widget_hide(RTGUI_WIDGET(win));</span><br><span class="line">        <span class="keyword">return</span> exit_code;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;focused_widget == RT_NULL)</span><br><span class="line">        rtgui_widget_focus(RTGUI_WIDGET(win));</span><br><span class="line"></span><br><span class="line">    app = win-&gt;app;</span><br><span class="line">    RT_ASSERT(app != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set main window */</span></span><br><span class="line">    <span class="keyword">if</span> (app-&gt;main_object == RT_NULL)</span><br><span class="line">        rtgui_app_set_main_win(app, win);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_MODAL)</span><br><span class="line">    {</span><br><span class="line">        exit_code = rtgui_win_enter_modal(win);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exit_code;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_do_show);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="隱藏"><a class="header-anchor" href="#隱藏">#</a>隱藏</h3><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>隱藏視窗</td><td>檢查碼</td><td>視窗本體</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_hide</span><span class="params">(struct rtgui_win *win)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(win != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RTGUI_WIDGET_IS_HIDE(win) &amp;&amp;</span><br><span class="line">            win-&gt;flag &amp; RTGUI_WIN_FLAG_CONNECTED)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* send hidden message to server */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_hide</span> <span class="title">ehide</span>;</span></span><br><span class="line">        RTGUI_EVENT_WIN_HIDE_INIT(&amp;ehide);</span><br><span class="line">        ehide.wid = win;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rtgui_server_post_event_sync(RTGUI_EVENT(&amp;ehide),</span><br><span class="line">                                         <span class="keyword">sizeof</span>(struct rtgui_event_win_hide)) != RT_EOK)</span><br><span class="line">        {</span><br><span class="line">            rt_kprintf(<span class="string">"hide win: %s failed\n"</span>, win-&gt;title);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        rtgui_widget_hide(RTGUI_WIDGET(win));</span><br><span class="line">        win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_ACTIVATE;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_hide);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="啟動"><a class="header-anchor" href="#啟動">#</a>啟動</h3><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>啟動視窗</td><td>檢查碼</td><td>視窗本體</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rtgui_win_activate(struct rtgui_win *win)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_activate</span> <span class="title">eact</span>;</span></span><br><span class="line">    RTGUI_EVENT_WIN_ACTIVATE_INIT(&amp;eact);</span><br><span class="line">    eact.wid = win;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rtgui_server_post_event_sync(RTGUI_EVENT(&amp;eact),</span><br><span class="line">                                        <span class="keyword">sizeof</span>(eact));</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_activate);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="移動"><a class="header-anchor" href="#移動">#</a>移動</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>進入動態模式</td><td>檢查碼</td></tr></tbody></table><table><thead><tr><th><code>*win</code></th><th><code>x</code></th><th><code>y</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>目標 x</td><td>目標 y</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_move</span><span class="params">(struct rtgui_win *win, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> *<span class="title">wgt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_move</span> <span class="title">emove</span>;</span></span><br><span class="line">    <span class="keyword">int</span> dx, dy;</span><br><span class="line">    RTGUI_EVENT_WIN_MOVE_INIT(&amp;emove);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;_title_wgt)</span><br><span class="line">    {</span><br><span class="line">        wgt = RTGUI_WIDGET(win-&gt;_title_wgt);</span><br><span class="line">        dx = x - wgt-&gt;extent.x1;</span><br><span class="line">        dy = y - wgt-&gt;extent.y1;</span><br><span class="line">        rtgui_widget_move_to_logic(wgt, dx, dy);</span><br><span class="line"></span><br><span class="line">        wgt = RTGUI_WIDGET(win);</span><br><span class="line">        rtgui_widget_move_to_logic(wgt, dx, dy);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        wgt = RTGUI_WIDGET(win);</span><br><span class="line">        dx = x - wgt-&gt;extent.x1;</span><br><span class="line">        dy = y - wgt-&gt;extent.y1;</span><br><span class="line">        rtgui_widget_move_to_logic(wgt, dx, dy);</span><br><span class="line">    }</span><br><span class="line">    rtgui_rect_move(&amp;win-&gt;outer_extent, dx, dy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_CONNECTED)</span><br><span class="line">    {</span><br><span class="line">        rtgui_widget_hide(RTGUI_WIDGET(win));</span><br><span class="line"></span><br><span class="line">        emove.wid   = win;</span><br><span class="line">        emove.x     = x;</span><br><span class="line">        emove.y     = y;</span><br><span class="line">        <span class="keyword">if</span> (rtgui_server_post_event_sync(RTGUI_EVENT(&amp;emove),</span><br><span class="line">                                         <span class="keyword">sizeof</span>(struct rtgui_event_win_move)) != RT_EOK)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    rtgui_widget_show(RTGUI_WIDGET(win));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_move);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="OnDraw"><a class="header-anchor" href="#OnDraw">#</a>OnDraw</h3><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>OnDraw</td><td>boolean</td><td>視窗本體</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> rt_bool_t <span class="title">rtgui_win_ondraw</span><span class="params">(struct rtgui_win *win)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc</span> *<span class="title">dc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span> <span class="title">rect</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_paint</span> <span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* begin drawing */</span></span><br><span class="line">    dc = rtgui_dc_begin_drawing(RTGUI_WIDGET(win));</span><br><span class="line">    <span class="keyword">if</span> (dc == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RT_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get window rect */</span></span><br><span class="line">    rtgui_widget_get_rect(RTGUI_WIDGET(win), &amp;rect);</span><br><span class="line">    <span class="comment">/* fill area */</span></span><br><span class="line">    rtgui_dc_fill_rect(dc, &amp;rect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* widget drawing */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* paint each widget */</span></span><br><span class="line">    RTGUI_EVENT_PAINT_INIT(&amp;event);</span><br><span class="line">    event.wid = RT_NULL;</span><br><span class="line"></span><br><span class="line">    rtgui_container_dispatch_event(RTGUI_CONTAINER(win),</span><br><span class="line">                                   (<span class="keyword">rtgui_event_t</span> *)&amp;event);</span><br><span class="line"></span><br><span class="line">    rtgui_dc_end_drawing(dc, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_FALSE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="更新重疊區域"><a class="header-anchor" href="#更新重疊區域">#</a>更新重疊區域</h3><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>更新重疊區域</td><td>void</td><td>視窗本體</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_update_clip</span><span class="params">(struct rtgui_win *win)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_container</span> *<span class="title">cnt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_list_node</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_CLOSED)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;_title_wgt)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* Reset the inner clip of title. */</span></span><br><span class="line">        RTGUI_WIDGET(win-&gt;_title_wgt)-&gt;extent = win-&gt;outer_extent;</span><br><span class="line">        rtgui_region_copy(&amp;RTGUI_WIDGET(win-&gt;_title_wgt)-&gt;clip, &amp;win-&gt;outer_clip);</span><br><span class="line">        rtgui_region_subtract_rect(&amp;RTGUI_WIDGET(win-&gt;_title_wgt)-&gt;clip,</span><br><span class="line">                                   &amp;RTGUI_WIDGET(win-&gt;_title_wgt)-&gt;clip,</span><br><span class="line">                                   &amp;RTGUI_WIDGET(win)-&gt;extent);</span><br><span class="line">        <span class="comment">/* Reset the inner clip of window. */</span></span><br><span class="line">        rtgui_region_intersect_rect(&amp;RTGUI_WIDGET(win)-&gt;clip,</span><br><span class="line">                                    &amp;win-&gt;outer_clip,</span><br><span class="line">                                    &amp;RTGUI_WIDGET(win)-&gt;extent);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        RTGUI_WIDGET(win)-&gt;extent = win-&gt;outer_extent;</span><br><span class="line">        rtgui_region_copy(&amp;RTGUI_WIDGET(win)-&gt;clip, &amp;win-&gt;outer_clip);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* update the clip info of each child */</span></span><br><span class="line">    cnt = RTGUI_CONTAINER(win);</span><br><span class="line">    rtgui_list_foreach(node, &amp;(cnt-&gt;children))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">rtgui_widget_t</span> *child = rtgui_list_entry(node, <span class="keyword">rtgui_widget_t</span>, sibling);</span><br><span class="line"></span><br><span class="line">        rtgui_widget_update_clip(child);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_update_clip);</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="Event-Handler"><a class="header-anchor" href="#Event-Handler">#</a>Event Handler</h2><p>此 event handler 也就是 window 的函式進入點</p><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>window 函式進入點</td><td>boolean</td></tr></tbody></table><table><thead><tr><th><code>*object</code></th><th><code>*event</code></th></tr></thead><tbody><tr><td>物件本體</td><td>行為本體</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_bool_t</span> rtgui_win_event_handler(struct rtgui_object *object, struct rtgui_event *event)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_win</span> *<span class="title">win</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(object != RT_NULL);</span><br><span class="line">    RT_ASSERT(event != RT_NULL);</span><br><span class="line"></span><br><span class="line">    win = RTGUI_WIN(object);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event-&gt;type)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_SHOW:</span><br><span class="line">        rtgui_win_do_show(win);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_HIDE:</span><br><span class="line">        rtgui_win_hide(win);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_CLOSE:</span><br><span class="line">        _rtgui_win_deal_close(win, event, RT_FALSE);</span><br><span class="line">        <span class="comment">/* don't broadcast WIN_CLOSE event to others */</span></span><br><span class="line">        <span class="keyword">return</span> RT_TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_MOVE:</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_move</span> *<span class="title">emove</span> = (<span class="title">struct</span> <span class="title">rtgui_event_win_move</span> *)<span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* move window */</span></span><br><span class="line">        rtgui_win_move(win, emove-&gt;x, emove-&gt;y);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_ACTIVATE:</span><br><span class="line">        <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_UNDER_MODAL ||</span><br><span class="line">                RTGUI_WIDGET_IS_HIDE(win))</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* activate a hide window */</span></span><br><span class="line">            <span class="keyword">return</span> RT_TRUE;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        win-&gt;flag |= RTGUI_WIN_FLAG_ACTIVATE;</span><br><span class="line">        <span class="comment">/* There are many cases where the paint event will follow this activate</span></span><br><span class="line"><span class="comment">         * event and just repaint the title is not a big deal. So just repaint</span></span><br><span class="line"><span class="comment">         * the title if there is one. If you want to update the content of the</span></span><br><span class="line"><span class="comment">         * window, do it in the on_activate callback.*/</span></span><br><span class="line">        <span class="keyword">if</span> (win-&gt;_title_wgt)</span><br><span class="line">            rtgui_widget_update(RTGUI_WIDGET(win-&gt;_title_wgt));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (win-&gt;on_activate != RT_NULL)</span><br><span class="line">        {</span><br><span class="line">            win-&gt;on_activate(RTGUI_OBJECT(object), event);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_DEACTIVATE:</span><br><span class="line">        win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_ACTIVATE;</span><br><span class="line">        <span class="comment">/* No paint event follow the deactive event. So we have to update</span></span><br><span class="line"><span class="comment">         * the title manually to reflect the change. */</span></span><br><span class="line">        <span class="keyword">if</span> (win-&gt;_title_wgt)</span><br><span class="line">            rtgui_widget_update(RTGUI_WIDGET(win-&gt;_title_wgt));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (win-&gt;on_deactivate != RT_NULL)</span><br><span class="line">            win-&gt;on_deactivate(RTGUI_OBJECT(object), event);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_UPDATE_END:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_CLIP_INFO:</span><br><span class="line">        <span class="comment">/* update win clip */</span></span><br><span class="line">        rtgui_win_update_clip(win);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_PAINT:</span><br><span class="line">        <span class="keyword">if</span> (win-&gt;_title_wgt)</span><br><span class="line">            rtgui_widget_update(RTGUI_WIDGET(win-&gt;_title_wgt));</span><br><span class="line">        rtgui_win_ondraw(win);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GUIENGIN_USING_VFRAMEBUFFER</span></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_VPAINT_REQ:</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_vpaint_req</span> *<span class="title">req</span> = (<span class="title">struct</span> <span class="title">rtgui_event_vpaint_req</span> *)<span class="title">event</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get drawing dc */</span></span><br><span class="line">        dc = rtgui_win_get_drawing(win);</span><br><span class="line"></span><br><span class="line">        req-&gt;sender-&gt;buffer = dc;</span><br><span class="line">        rt_completion_done(req-&gt;sender-&gt;cmp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_MOUSE_BUTTON:</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_mouse</span> *<span class="title">emouse</span> = (<span class="title">struct</span> <span class="title">rtgui_event_mouse</span>*)<span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rtgui_rect_contains_point(&amp;RTGUI_WIDGET(win)-&gt;extent,</span><br><span class="line">                                      emouse-&gt;x, emouse-&gt;y) == RT_EOK)</span><br><span class="line">            <span class="keyword">return</span> _win_handle_mouse_btn(win, event);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (win-&gt;_title_wgt)</span><br><span class="line">        {</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_object</span> *<span class="title">tobj</span> = <span class="title">RTGUI_OBJECT</span>(<span class="title">win</span>-&gt;_<span class="title">title_wgt</span>);</span></span><br><span class="line">            <span class="keyword">return</span> tobj-&gt;event_handler(tobj, event);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_MOUSE_MOTION:</span><br><span class="line">        <span class="keyword">return</span> rtgui_container_dispatch_mouse_event(RTGUI_CONTAINER(win),</span><br><span class="line">                (struct rtgui_event_mouse *)event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_KBD:</span><br><span class="line">        <span class="comment">/* we should dispatch key event firstly */</span></span><br><span class="line">        <span class="keyword">if</span> (!(win-&gt;flag &amp; RTGUI_WIN_FLAG_HANDLE_KEY))</span><br><span class="line">        {</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> *<span class="title">widget</span>;</span></span><br><span class="line">            <span class="keyword">rt_bool_t</span> res = RT_FALSE;</span><br><span class="line">            <span class="comment">/* we should dispatch the key event just once. Once entered the</span></span><br><span class="line"><span class="comment">             * dispatch mode, we should swtich to key handling mode. */</span></span><br><span class="line">            win-&gt;flag |= RTGUI_WIN_FLAG_HANDLE_KEY;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* dispatch the key event */</span></span><br><span class="line">            <span class="keyword">for</span> (widget = win-&gt;focused_widget;</span><br><span class="line">                    widget &amp;&amp; !res;</span><br><span class="line">                    widget = widget-&gt;parent)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (RTGUI_OBJECT(widget)-&gt;event_handler != RT_NULL)</span><br><span class="line">                    res = RTGUI_OBJECT(widget)-&gt;event_handler(</span><br><span class="line">                              RTGUI_OBJECT(widget), event);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_HANDLE_KEY;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* in key handling mode(it may reach here in</span></span><br><span class="line"><span class="comment">             * win-&gt;focused_widget-&gt;event_handler call) */</span></span><br><span class="line">            <span class="keyword">if</span> (win-&gt;on_key != RT_NULL)</span><br><span class="line">                <span class="keyword">return</span> win-&gt;on_key(RTGUI_OBJECT(win), event);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_COMMAND:</span><br><span class="line">        <span class="keyword">if</span> (rtgui_container_dispatch_event(RTGUI_CONTAINER(object), event) != RT_TRUE)</span><br><span class="line">        {</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> RT_TRUE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> rtgui_container_event_handler(object, event);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_FALSE;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_event_handler);</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;alert alert-success&quot;&gt;&lt;p&gt;&lt;stro
      
    
    </summary>
    
    
      <category term="RT-Thread GUI" scheme="https://blog.lusw.dev/categories/RT-Thread-GUI/"/>
    
    
      <category term="kernel" scheme="https://blog.lusw.dev/tags/kernel/"/>
    
      <category term="RT-Thread" scheme="https://blog.lusw.dev/tags/RT-Thread/"/>
    
      <category term="GUI" scheme="https://blog.lusw.dev/tags/GUI/"/>
    
      <category term="window" scheme="https://blog.lusw.dev/tags/window/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread GUI Widget</title>
    <link href="https://blog.lusw.dev/rtgui-widget.html"/>
    <id>https://blog.lusw.dev/rtgui-widget.html</id>
    <published>2019-01-01T10:42:37.000Z</published>
    <updated>2020-04-23T05:02:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>上一篇我們說明了 RTGUI 是如何透過 C 實現物件導向的設計邏輯，這篇將會說明在 RTGUI 中的最小物件 “widget” 是如何創建、運行及刪除的。</p><h2 id="結構"><a class="header-anchor" href="#結構">#</a>結構</h2><div class="alert alert-success"><p><strong>File:</strong> widget.h</p></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * the base widget object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* inherit from rtgui_object */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_object</span> <span class="title">object</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the widget that contains this widget */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="comment">/* the window that contains this widget */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_win</span> *<span class="title">toplevel</span>;</span></span><br><span class="line">    <span class="comment">/* the widget children and sibling */</span></span><br><span class="line">    <span class="keyword">rtgui_list_t</span> sibling;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* widget flag */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hardware device context */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> dc_type;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_engine</span> *<span class="title">dc_engine</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the graphic context of widget */</span></span><br><span class="line">    <span class="keyword">rtgui_gc_t</span> gc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the widget extent */</span></span><br><span class="line">    <span class="keyword">rtgui_rect_t</span> extent;</span><br><span class="line">    <span class="comment">/* the visiable extent (includes the rectangles of children) */</span></span><br><span class="line">    <span class="keyword">rtgui_rect_t</span> extent_visiable;</span><br><span class="line">    <span class="comment">/* the rect clip information */</span></span><br><span class="line">    <span class="keyword">rtgui_region_t</span> clip;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* minimal width and height of widget */</span></span><br><span class="line">    <span class="keyword">rt_int16_t</span> min_width, min_height;</span><br><span class="line">    <span class="comment">/* widget align */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span> align;</span><br><span class="line">    <span class="keyword">rt_uint16_t</span> border;</span><br><span class="line">    <span class="keyword">rt_uint16_t</span> border_style;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call back */</span></span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*on_focus_in)(struct rtgui_object *widget, struct rtgui_event *event);</span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*on_focus_out)(struct rtgui_object *widget, struct rtgui_event *event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* user private data */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> user_data;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> <span class="title">rtgui_widget_t</span>;</span></span><br></pre></td></tr></tbody></table></figure><p>記錄包含他的 widget、所在的 window、一些屬性等</p><h3 id="四方形結構體"><a class="header-anchor" href="#四方形結構體">#</a>四方形結構體</h3><div class="alert alert-success"><p><strong>File:</strong> rtgui.h</p></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rectangle structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">rt_int16_t</span> x1, y1, x2, y2;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span> <span class="title">rtgui_rect_t</span>;</span></span><br></pre></td></tr></tbody></table></figure><p>對角線 (x1,y1)、(x2,y2)</p><hr><h3 id="定義物件類型"><a class="header-anchor" href="#定義物件類型">#</a>定義物件類型</h3><div class="alert alert-success"><p><strong>File:</strong> widget.c</p></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_CLASS_TYPE(widget, <span class="string">"widget"</span>,</span><br><span class="line">                  RTGUI_PARENT_TYPE(object),</span><br><span class="line">                  _rtgui_widget_constructor,</span><br><span class="line">                  _rtgui_widget_destructor,</span><br><span class="line">                  <span class="keyword">sizeof</span>(struct rtgui_widget));</span><br><span class="line">RTM_EXPORT(_rtgui_widget);</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="建立-widget"><a class="header-anchor" href="#建立-widget">#</a>建立 widget</h2><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget_type</code></th></tr></thead><tbody><tr><td>建立 widget</td><td>widget 指標</td><td>欲建立的 widget 種類</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_widget_t</span> *rtgui_widget_create(<span class="keyword">const</span> <span class="keyword">rtgui_type_t</span> *widget_type)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> *<span class="title">widget</span>;</span></span><br><span class="line"></span><br><span class="line">    widget = RTGUI_WIDGET(rtgui_object_create(widget_type));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> widget;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_create);</span><br></pre></td></tr></tbody></table></figure><p>呼叫 <code>rtgui_object_create</code>，型態為 widget 完成，並透過 <code>RTGUI_WIDGET</code> 檢查正確性</p><hr><h2 id="刪除-widget"><a class="header-anchor" href="#刪除-widget">#</a>刪除 widget</h2><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>刪除 widget</td><td>void</td><td>欲刪除的 widget</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_destroy</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    rtgui_object_destroy(RTGUI_OBJECT(widget));</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_destroy);</span><br></pre></td></tr></tbody></table></figure><p>一樣透過 <code>rtgui_object_destroy</code> 來完成</p><hr><h2 id="設定-widget"><a class="header-anchor" href="#設定-widget">#</a>設定 widget</h2><p>RTT GUI 提供一些 API 給使用者去設定 widget 的樣式與行為</p><h3 id="大小"><a class="header-anchor" href="#大小">#</a>大小</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的大小</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*widget</code></th><th><code>x</code></th><th><code>y</code></th><th><code>width</code></th><th><code>height</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>起始座標 x</td><td>y</td><td>寬度</td><td>高度</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_rectangle</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rtgui_rect_t</span> rect;</span><br><span class="line"></span><br><span class="line">    rect.x1 = x;</span><br><span class="line">    rect.y1 = y;</span><br><span class="line">    rect.x2 = x + width;</span><br><span class="line">    rect.y2 = y + height;</span><br><span class="line"></span><br><span class="line">    rtgui_widget_set_rect(widget, &amp;rect);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_rectangle);</span><br></pre></td></tr></tbody></table></figure><p>填入正確的 (x1,y1)、(x2,y2)</p><hr><h3 id="Parent"><a class="header-anchor" href="#Parent">#</a>Parent</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的上層元素</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*widget</code></th><th><code>parent</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>上層元素 (widget)</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_parent</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">rtgui_widget_t</span> *parent)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* set parent and toplevel widget */</span></span><br><span class="line">    widget-&gt;parent = parent;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_parent);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="大小下界"><a class="header-anchor" href="#大小下界">#</a>大小下界</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的大小下界</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*widget</code></th><th><code>width</code></th><th><code>height</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>寬度</td><td>高度</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_minsize</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line">    widget-&gt;min_width = width;</span><br><span class="line">    widget-&gt;min_height = height;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_minsize);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="寬度下界"><a class="header-anchor" href="#寬度下界">#</a>寬度下界</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的寬度下界</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*widget</code></th><th><code>width</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>寬度</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_minwidth</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">int</span> width)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    widget-&gt;min_width = width;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_minwidth);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="高度下界"><a class="header-anchor" href="#高度下界">#</a>高度下界</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的高度下界</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*widget</code></th><th><code>height</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>高度</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_minheight</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    widget-&gt;min_height = height;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_minheight);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="邊框風格"><a class="header-anchor" href="#邊框風格">#</a>邊框風格</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的邊框風格</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*widget</code></th><th><code>style</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>風格</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set widget draw style</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_border</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">rt_uint32_t</span> style)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    widget-&gt;border_style = style;</span><br><span class="line">    <span class="keyword">switch</span> (style)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_NONE:</span><br><span class="line">        widget-&gt;border = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_SIMPLE:</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_UP:</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_DOWN:</span><br><span class="line">        widget-&gt;border = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_STATIC:</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_RAISE:</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_SUNKEN:</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_BOX:</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_EXTRA:</span><br><span class="line">        widget-&gt;border = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        widget-&gt;border = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_border);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Focus-函式"><a class="header-anchor" href="#Focus-函式">#</a>Focus 函式</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的 focus func</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*widget</code></th><th><code>handler</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>focus func</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_onfocus</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, rtgui_event_handler_ptr handler)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    widget-&gt;on_focus_in = handler;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_onfocus);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Unfocus-函式"><a class="header-anchor" href="#Unfocus-函式">#</a>Unfocus 函式</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的 unfocus func</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*widget</code></th><th><code>handler</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>focus func</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_onunfocus</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, rtgui_event_handler_ptr handler)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    widget-&gt;on_focus_out = handler;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_onunfocus);</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-info"><p>這裡是用<strong>指標函數</strong>的方式將行為函式填入結構中，要使用時可直接呼叫結構中的元素使用。</p></div><hr><h2 id="Widget-的行為"><a class="header-anchor" href="#Widget-的行為">#</a>Widget 的行為</h2><p>上一節整理了設定 widget 的風格，接下來整理 widget 的行為</p><h3 id="移動到相對位置"><a class="header-anchor" href="#移動到相對位置">#</a>移動到相對位置</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>移動 widget 到相對位置</td><td>void</td></tr></tbody></table><table><thead><tr><th style="text-align:center"><code>*widget</code></th><th style="text-align:center"><code>dx</code></th><th style="text-align:center"><code>dy</code></th></tr></thead><tbody><tr><td style="text-align:center">欲移動的 widget</td><td style="text-align:center">位移量 x</td><td style="text-align:center">y</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function moves widget and its children to a logic point</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_move_to_logic</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rtgui_rect_t</span> rect;</span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* give clip of this widget back to parent */</span></span><br><span class="line">    parent = widget-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (parent != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* get the parent rect, even if it's a transparent parent. */</span></span><br><span class="line">        rect = parent-&gt;extent_visiable;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we should find out the none-transparent parent */</span></span><br><span class="line">    <span class="keyword">while</span> (parent != RT_NULL &amp;&amp; parent-&gt;flag &amp; RTGUI_WIDGET_FLAG_TRANSPARENT) parent = parent-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (parent != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* reset clip info */</span></span><br><span class="line">        rtgui_region_init_with_extents(&amp;(widget-&gt;clip), &amp;(widget-&gt;extent));</span><br><span class="line">        rtgui_region_intersect_rect(&amp;(widget-&gt;clip), &amp;(widget-&gt;clip), &amp;rect);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* give back the extent */</span></span><br><span class="line">        rtgui_region_union(&amp;(parent-&gt;clip), &amp;(parent-&gt;clip), &amp;(widget-&gt;clip));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* move this widget (and its children if it's a container) to destination point */</span></span><br><span class="line">    _widget_move(widget, dx, dy);</span><br><span class="line">    <span class="comment">/* update this widget */</span></span><br><span class="line">    rtgui_widget_update_clip(widget);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_move_to_logic);</span><br></pre></td></tr></tbody></table></figure><hr><h4 id="移動-widget"><a class="header-anchor" href="#移動-widget">#</a>移動 widget</h4><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>移動 widget</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*widget</code></th><th><code>dx</code></th><th><code>dy</code></th></tr></thead><tbody><tr><td>欲移動的 widget</td><td>位移量 x</td><td>y</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _widget_move(struct rtgui_widget* widget, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_list_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *child, *parent;</span><br><span class="line"></span><br><span class="line">rtgui_rect_move(&amp;(widget-&gt;extent), dx, dy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* handle visiable extent */</span></span><br><span class="line">    widget-&gt;extent_visiable = widget-&gt;extent;</span><br><span class="line">    parent = widget-&gt;parent;</span><br><span class="line">    <span class="comment">/* we should find out the none-transparent parent */</span></span><br><span class="line">    <span class="keyword">while</span> (parent != RT_NULL &amp;&amp; parent-&gt;flag &amp; RTGUI_WIDGET_FLAG_TRANSPARENT) parent = parent-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;parent)</span><br><span class="line">        rtgui_rect_intersect(&amp;(widget-&gt;parent-&gt;extent_visiable), &amp;(widget-&gt;extent_visiable));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset clip info */</span></span><br><span class="line">    rtgui_region_init_with_extents(&amp;(widget-&gt;clip), &amp;(widget-&gt;extent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* move each child */</span></span><br><span class="line">    <span class="keyword">if</span> (RTGUI_IS_CONTAINER(widget))</span><br><span class="line">    {</span><br><span class="line">        rtgui_list_foreach(node, &amp;(RTGUI_CONTAINER(widget)-&gt;children))</span><br><span class="line">        {</span><br><span class="line">            child = rtgui_list_entry(node, <span class="keyword">rtgui_widget_t</span>, sibling);</span><br><span class="line"></span><br><span class="line">            _widget_move(child, dx, dy);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Focus-widget"><a class="header-anchor" href="#Focus-widget">#</a>Focus widget</h3><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>focus widget</td><td>void</td><td>欲 focus 的 widget</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Focuses the widget. The focused widget is the widget which can receive the keyboard events</span></span><br><span class="line"><span class="comment"> * @param widget a widget</span></span><br><span class="line"><span class="comment"> * @note The widget has to be attached to a toplevel widget, otherwise it will have no effect</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_focus</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> *<span class="title">old_focus</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line">    RT_ASSERT(widget-&gt;toplevel != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RTGUI_WIDGET_IS_FOCUSABLE(widget) || !RTGUI_WIDGET_IS_ENABLE(widget))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    old_focus = RTGUI_WIN(widget-&gt;toplevel)-&gt;focused_widget;</span><br><span class="line">    <span class="keyword">if</span> (old_focus == widget)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* it's the same focused widget */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unfocused the old widget */</span></span><br><span class="line">    <span class="keyword">if</span> (old_focus != RT_NULL)</span><br><span class="line">        rtgui_widget_unfocus(old_focus);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set widget as focused */</span></span><br><span class="line">    widget-&gt;flag |= RTGUI_WIDGET_FLAG_FOCUS;</span><br><span class="line">    RTGUI_WIN(widget-&gt;toplevel)-&gt;focused_widget = widget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* invoke on focus in call back */</span></span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;on_focus_in != RT_NULL)</span><br><span class="line">        widget-&gt;on_focus_in(RTGUI_OBJECT(widget), RT_NULL);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_focus);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Unfocus-widget"><a class="header-anchor" href="#Unfocus-widget">#</a>Unfocus widget</h3><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>focus widget</td><td>void</td><td>欲 unfocus 的 widget</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Unfocused the widget</span></span><br><span class="line"><span class="comment"> * @param widget a widget</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_unfocus</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!widget-&gt;toplevel || !RTGUI_WIDGET_IS_FOCUSED(widget))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    widget-&gt;flag &amp;= ~RTGUI_WIDGET_FLAG_FOCUS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;on_focus_out != RT_NULL)</span><br><span class="line">        widget-&gt;on_focus_out(RTGUI_OBJECT(widget), RT_NULL);</span><br><span class="line"></span><br><span class="line">    RTGUI_WIN(widget-&gt;toplevel)-&gt;focused_widget = RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ergodic constituent widget, make child loss of focus */</span></span><br><span class="line">    <span class="keyword">if</span> (RTGUI_IS_CONTAINER(widget))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">rtgui_list_t</span> *node;</span><br><span class="line">        rtgui_list_foreach(node, &amp;(RTGUI_CONTAINER(widget)-&gt;children))</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">rtgui_widget_t</span> *child = rtgui_list_entry(node, <span class="keyword">rtgui_widget_t</span>, sibling);</span><br><span class="line">            <span class="keyword">if</span> (RTGUI_WIDGET_IS_HIDE(child)) <span class="keyword">continue</span>;</span><br><span class="line">            rtgui_widget_unfocus(child);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_unfocus);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="位移-widget"><a class="header-anchor" href="#位移-widget">#</a>位移 widget</h3><h4 id="點向上位移"><a class="header-anchor" href="#點向上位移">#</a>點向上位移</h4><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>點向上位移</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*widget</code></th><th><code>*point</code></th></tr></thead><tbody><tr><td>目標 widget</td><td>目標點</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_point_to_device</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">rtgui_point_t</span> *point)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (point != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        point-&gt;x += widget-&gt;extent.x1;</span><br><span class="line">        point-&gt;y += widget-&gt;extent.y1;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_point_to_device);</span><br></pre></td></tr></tbody></table></figure><h4 id="點向下位移"><a class="header-anchor" href="#點向下位移">#</a>點向下位移</h4><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>點向上位移</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*widget</code></th><th><code>*point</code></th></tr></thead><tbody><tr><td>目標 widget</td><td>目標點</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_point_to_logic</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">rtgui_point_t</span> *point)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (point != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        point-&gt;x -= widget-&gt;extent.x1;</span><br><span class="line">        point-&gt;y -= widget-&gt;extent.y1;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_point_to_logic);</span><br></pre></td></tr></tbody></table></figure><h4 id="矩形向上位移"><a class="header-anchor" href="#矩形向上位移">#</a>矩形向上位移</h4><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>點向上位移</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*widget</code></th><th><code>*rect</code></th></tr></thead><tbody><tr><td>目標 widget</td><td>目標矩形</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_rect_to_device</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">rtgui_rect_t</span> *rect)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rect != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        rect-&gt;x1 += widget-&gt;extent.x1;</span><br><span class="line">        rect-&gt;x2 += widget-&gt;extent.x1;</span><br><span class="line"></span><br><span class="line">        rect-&gt;y1 += widget-&gt;extent.y1;</span><br><span class="line">        rect-&gt;y2 += widget-&gt;extent.y1;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_rect_to_device);</span><br></pre></td></tr></tbody></table></figure><h4 id="矩形向下位移"><a class="header-anchor" href="#矩形向下位移">#</a>矩形向下位移</h4><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>點向上位移</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*widget</code></th><th><code>*rect</code></th></tr></thead><tbody><tr><td>目標 widget</td><td>目標矩形</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_rect_to_logic</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">rtgui_rect_t</span> *rect)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rect != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        rect-&gt;x1 -= widget-&gt;extent.x1;</span><br><span class="line">        rect-&gt;x2 -= widget-&gt;extent.x1;</span><br><span class="line"></span><br><span class="line">        rect-&gt;y1 -= widget-&gt;extent.y1;</span><br><span class="line">        rect-&gt;y2 -= widget-&gt;extent.y1;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_rect_to_logic);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="更新重疊區域"><a class="header-anchor" href="#更新重疊區域">#</a>更新重疊區域</h3><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>更新重疊區域</td><td>void</td><td>目標 widget</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function updates the clip info of widget</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_update_clip</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rtgui_rect_t</span> rect;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_list_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* no widget or widget is hide, no update clip */</span></span><br><span class="line">    <span class="keyword">if</span> (widget == RT_NULL || RTGUI_WIDGET_IS_HIDE(widget) || widget-&gt;parent == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    parent = widget-&gt;parent;</span><br><span class="line">    <span class="comment">/* reset visiable extent */</span></span><br><span class="line">    widget-&gt;extent_visiable = widget-&gt;extent;</span><br><span class="line">    rtgui_rect_intersect(&amp;(parent-&gt;extent_visiable), &amp;(widget-&gt;extent_visiable));</span><br><span class="line"></span><br><span class="line">    rect = parent-&gt;extent_visiable;</span><br><span class="line">    <span class="comment">/* reset clip to extent */</span></span><br><span class="line">    rtgui_region_reset(&amp;(widget-&gt;clip), &amp;(widget-&gt;extent));</span><br><span class="line">    <span class="comment">/* limit widget extent in parent extent */</span></span><br><span class="line">    rtgui_region_intersect_rect(&amp;(widget-&gt;clip), &amp;(widget-&gt;clip), &amp;rect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get the no transparent parent */</span></span><br><span class="line">    <span class="keyword">while</span> (parent != RT_NULL &amp;&amp; parent-&gt;flag &amp; RTGUI_WIDGET_FLAG_TRANSPARENT)</span><br><span class="line">    {</span><br><span class="line">        parent = parent-&gt;parent;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (parent != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* give my clip back to parent */</span></span><br><span class="line">        rtgui_region_union(&amp;(parent-&gt;clip), &amp;(parent-&gt;clip), &amp;(widget-&gt;clip));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* subtract widget clip in parent clip */</span></span><br><span class="line">        <span class="keyword">if</span> (!(widget-&gt;flag &amp; RTGUI_WIDGET_FLAG_TRANSPARENT) &amp;&amp; RTGUI_IS_CONTAINER(parent))</span><br><span class="line">        {</span><br><span class="line">            rtgui_region_subtract_rect(&amp;(parent-&gt;clip), &amp;(parent-&gt;clip), &amp;(widget-&gt;extent_visiable));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * note: since the layout widget introduction, the sibling widget should not intersect.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if it's a container object, update the clip info of children */</span></span><br><span class="line">    <span class="keyword">if</span> (RTGUI_IS_CONTAINER(widget))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">rtgui_widget_t</span> *child;</span><br><span class="line">        rtgui_list_foreach(node, &amp;(RTGUI_CONTAINER(widget)-&gt;children))</span><br><span class="line">        {</span><br><span class="line">            child = rtgui_list_entry(node, <span class="keyword">rtgui_widget_t</span>, sibling);</span><br><span class="line"></span><br><span class="line">            rtgui_widget_update_clip(child);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_update_clip);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="顯示-widget"><a class="header-anchor" href="#顯示-widget">#</a>顯示 widget</h3><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>顯示 widget</td><td>void</td><td>目標 widget</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_show</span><span class="params">(struct rtgui_widget *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_show</span> <span class="title">eshow</span>;</span></span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RTGUI_WIDGET_IS_HIDE(widget))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    RTGUI_WIDGET_UNHIDE(widget);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;toplevel != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        RTGUI_EVENT_SHOW_INIT(&amp;eshow);</span><br><span class="line">        <span class="keyword">if</span> (RTGUI_OBJECT(widget)-&gt;event_handler != RT_NULL)</span><br><span class="line">        {</span><br><span class="line">            RTGUI_OBJECT(widget)-&gt;event_handler(</span><br><span class="line">                RTGUI_OBJECT(widget),</span><br><span class="line">                &amp;eshow);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_show);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="隱藏-widget"><a class="header-anchor" href="#隱藏-widget">#</a>隱藏 widget</h3><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>隱藏 widget</td><td>void</td><td>目標 widget</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_hide</span><span class="params">(struct rtgui_widget *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_hide</span> <span class="title">ehide</span>;</span></span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (RTGUI_WIDGET_IS_HIDE(widget))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;toplevel != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        RTGUI_EVENT_HIDE_INIT(&amp;ehide);</span><br><span class="line">        <span class="keyword">if</span> (RTGUI_OBJECT(widget)-&gt;event_handler != RT_NULL)</span><br><span class="line">        {</span><br><span class="line">            RTGUI_OBJECT(widget)-&gt;event_handler(</span><br><span class="line">                RTGUI_OBJECT(widget),</span><br><span class="line">                &amp;ehide);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    RTGUI_WIDGET_HIDE(widget);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_hide);</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="取得-widget-資訊"><a class="header-anchor" href="#取得-widget-資訊">#</a>取得 widget 資訊</h2><p>最後整理一些取得 widget 資訊的 API</p><h3 id="Top-Level"><a class="header-anchor" href="#Top-Level">#</a>Top Level</h3><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>取得 top level</td><td>所在 window</td><td>目標 widget</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct rtgui_win *<span class="title">rtgui_widget_get_toplevel</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *r;</span><br><span class="line"></span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;toplevel)</span><br><span class="line">        <span class="keyword">return</span> widget-&gt;toplevel;</span><br><span class="line"></span><br><span class="line">    rt_kprintf(<span class="string">"widget-&gt;toplevel not properly set\n"</span>);</span><br><span class="line">    r = widget;</span><br><span class="line">    <span class="comment">/* get the toplevel widget */</span></span><br><span class="line">    <span class="keyword">while</span> (r-&gt;parent != RT_NULL)</span><br><span class="line">        r = r-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set toplevel */</span></span><br><span class="line">    widget-&gt;toplevel = RTGUI_WIN(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RTGUI_WIN(r);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_get_toplevel);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="上層前景"><a class="header-anchor" href="#上層前景">#</a>上層前景</h3><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>取得上層前景</td><td>顏色</td><td>目標 widget</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_color_t</span> rtgui_widget_get_parent_foreground(<span class="keyword">rtgui_widget_t</span> *widget)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get parent widget */</span></span><br><span class="line">    parent = widget-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (parent == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RTGUI_WIDGET_FOREGROUND(widget);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (parent-&gt;parent != RT_NULL &amp;&amp; (RTGUI_WIDGET_FLAG(parent) &amp; RTGUI_WIDGET_FLAG_TRANSPARENT))</span><br><span class="line">        parent = parent-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get parent's color */</span></span><br><span class="line">    <span class="keyword">return</span> RTGUI_WIDGET_FOREGROUND(parent);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_get_parent_foreground);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="上層背景"><a class="header-anchor" href="#上層背景">#</a>上層背景</h3><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>取得上層背景</td><td>顏色</td><td>目標 widget</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_color_t</span> rtgui_widget_get_parent_background(<span class="keyword">rtgui_widget_t</span> *widget)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get parent widget */</span></span><br><span class="line">    parent = widget-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (parent == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RTGUI_WIDGET_BACKGROUND(widget);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (parent-&gt;parent != RT_NULL &amp;&amp; (RTGUI_WIDGET_FLAG(parent) &amp; RTGUI_WIDGET_FLAG_TRANSPARENT))</span><br><span class="line">        parent = parent-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get parent's color */</span></span><br><span class="line">    <span class="keyword">return</span> RTGUI_WIDGET_BACKGROUND(parent);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_get_parent_background);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="下一個兄弟"><a class="header-anchor" href="#下一個兄弟">#</a>下一個兄弟</h3><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>取得下一個兄弟</td><td>void</td><td>目標 widget</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_widget_t</span> *rtgui_widget_get_next_sibling(<span class="keyword">rtgui_widget_t</span> *widget)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *sibling = RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;sibling.next != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        sibling = rtgui_list_entry(widget-&gt;sibling.next, <span class="keyword">rtgui_widget_t</span>, sibling);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sibling;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_get_next_sibling);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="上一個兄弟"><a class="header-anchor" href="#上一個兄弟">#</a>上一個兄弟</h3><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>取得上一個兄弟</td><td>void</td><td>目標 widget</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_widget_t</span> *rtgui_widget_get_prev_sibling(<span class="keyword">rtgui_widget_t</span> *widget)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_list_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *sibling, *parent;</span><br><span class="line"></span><br><span class="line">    node = RT_NULL;</span><br><span class="line">    sibling = RT_NULL;</span><br><span class="line">    parent = widget-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (parent != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        rtgui_list_foreach(node, &amp;(RTGUI_CONTAINER(parent)-&gt;children))</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next == &amp;(widget-&gt;sibling))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node != RT_NULL)</span><br><span class="line">        sibling = rtgui_list_entry(node, <span class="keyword">rtgui_widget_t</span>, sibling);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sibling;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;上一篇我們說明了 RTGUI 是如何透過 C 實現物件導向的設計邏輯，這篇將
      
    
    </summary>
    
    
      <category term="RT-Thread GUI" scheme="https://blog.lusw.dev/categories/RT-Thread-GUI/"/>
    
    
      <category term="kernel" scheme="https://blog.lusw.dev/tags/kernel/"/>
    
      <category term="RT-Thread" scheme="https://blog.lusw.dev/tags/RT-Thread/"/>
    
      <category term="GUI" scheme="https://blog.lusw.dev/tags/GUI/"/>
    
      <category term="widget" scheme="https://blog.lusw.dev/tags/widget/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread GUI Object</title>
    <link href="https://blog.lusw.dev/rtgui-object.html"/>
    <id>https://blog.lusw.dev/rtgui-object.html</id>
    <published>2019-01-01T07:08:37.000Z</published>
    <updated>2020-04-23T05:02:31.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="RT-Thread-GUI-物件架構"><a class="header-anchor" href="#RT-Thread-GUI-物件架構">#</a>RT-Thread GUI 物件架構</h2><p>在 RTGUI 中，最小的物件為 widget，再來是 window，window 也是一個 widget；而每個 widget 也是一個 object，這是為了仿造 C++ 的物件導向所設計的，相同的概念我們在 RT-Thread 中已經看過許多次了，在 GUI engine 中也是相同的設計，其中在 object 結構中又串在 type 的結構上，type 中定義了兩個函式：<code>constructor</code> 與 <code>destructor</code>，在 C++ 的 class 中，常使用 <code>init</code> 函式來初始化新建的 class，這裡的 <code>constructor</code> 與 <code>destructor</code> 即用來初始化新建立的物件，及在刪除物件時，釋放該釋放的記憶體。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[RTGUI粗讲（个人见解篇之三、RTGUI WIDGET （2））](https://blog.csdn.net/xuzhenglim/article/details/11883351)">[1]</span></a></sup></p><hr><h2 id="結構"><a class="header-anchor" href="#結構">#</a>結構</h2><div class="alert alert-success"><p><strong>File:</strong> rtgui_object.h</p></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rtgui base object */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_object</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* object type */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">rtgui_type_t</span> *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the event handler */</span></span><br><span class="line">    rtgui_event_handler_ptr event_handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> rtgui_object_flag flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> id;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rtgui type structure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_type</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* type name */</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parent type link */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_type</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* constructor and destructor */</span></span><br><span class="line">    <span class="keyword">rtgui_constructor_t</span> constructor;</span><br><span class="line">    <span class="keyword">rtgui_destructor_t</span> destructor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* size of type */</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="定義物件類型"><a class="header-anchor" href="#定義物件類型">#</a>定義物件類型</h2><p>RTGUI 設計了一個巨集函數來定義不同的物件，如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_CLASS_TYPE(type, name, parent, constructor, destructor, size) \</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_type</span> _<span class="title">rtgui_</span>##<span class="title">type</span> = {</span> \</span><br><span class="line">name, \</span><br><span class="line">parent, \</span><br><span class="line">RTGUI_CONSTRUCTOR(constructor), \</span><br><span class="line">RTGUI_DESTRUCTOR(destructor), \</span><br><span class="line">size }; \</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">rtgui_type_t</span> *_rtgui_#<span class="meta">#type##_get_type(void) { return &amp;_rtgui_##type; } \</span></span><br><span class="line">RTM_EXPORT(_rtgui_##type##_get_type)</span><br></pre></td></tr></tbody></table></figure><p><code>##</code> 為連字符，在<a href="/rt-thread-RTM-EXPORT">RT-Thread 理解 RTM_EXPORT</a>裡有提過了，基本上就是填入值進去結構體</p><hr><h2 id="建立物件"><a class="header-anchor" href="#建立物件">#</a>建立物件</h2><div class="alert alert-success"><p><strong>File:</strong> rtgui_object.c</p></div><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*object_type</code></th></tr></thead><tbody><tr><td>建立物件</td><td>物件指標</td><td>要建立的物件種類</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Creates a new object: it calls the corresponding constructors</span></span><br><span class="line"><span class="comment"> * (from the constructor of the base class to the constructor of the more</span></span><br><span class="line"><span class="comment"> * derived class) and then sets the values of the given properties</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param object_type the type of object to create</span></span><br><span class="line"><span class="comment"> * @return the created object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rtgui_object_t</span> *rtgui_object_create(<span class="keyword">const</span> <span class="keyword">rtgui_type_t</span> *object_type)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rtgui_object_t</span> *new_object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!object_type)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line">    new_object = rtgui_malloc(object_type-&gt;size);</span><br><span class="line">    <span class="keyword">if</span> (new_object == RT_NULL) <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTGUI_OBJECT_TRACE</span></span><br><span class="line">    obj_info.objs_number ++;</span><br><span class="line">    obj_info.allocated_size += object_type-&gt;size;</span><br><span class="line">    <span class="keyword">if</span> (obj_info.allocated_size &gt; obj_info.max_allocated)</span><br><span class="line">        obj_info.max_allocated = obj_info.allocated_size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    new_object-&gt;type = object_type;</span><br><span class="line"></span><br><span class="line">    rtgui_type_object_construct(object_type, new_object);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_object;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_object_create);</span><br></pre></td></tr></tbody></table></figure><p>建立物件相當簡單，透過欲建立的物件類型所定意義的 <code>construct</code> 函數來建立，其中 <code>rtgui_type_object_construct</code> 會呼叫正確的建立函式來初始化資料。</p><hr><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>呼叫正確的 <code>construct</code> 函式來初始化物件</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*type</code></th><th><code>*object</code></th></tr></thead><tbody><tr><td>欲初始化的物件類型</td><td>物件本體</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_type_object_construct</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtgui_type_t</span> *type, <span class="keyword">rtgui_object_t</span> *object)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* construct from parent to children */</span></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;parent != RT_NULL)</span><br><span class="line">        rtgui_type_object_construct(type-&gt;parent, object);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;constructor)</span><br><span class="line">        type-&gt;constructor(object);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果欲建立的物件類型在某一個物件類型的底下，如 window 之於 widget，則先呼叫在上層的 <code>construct</code>；接著呼叫自己的 <code>construct</code> 來完成建立的動作。</p><hr><p>再仔細的看一下 “object” 的 <code>construct</code> 函式，其動作為：填入 vaild 的旗標，並將 id 填入 object 的記憶體指標；以上動作在 <code>_rtgui_object_constructor</code> 完成</p><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*object</code></th></tr></thead><tbody><tr><td>“object” 建立函式</td><td>void</td><td>要建立的物件</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _rtgui_object_constructor(<span class="keyword">rtgui_object_t</span> *object)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!object)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    object-&gt;flag = RTGUI_OBJECT_FLAG_VALID;</span><br><span class="line">    object-&gt;id   = (<span class="keyword">rt_uint32_t</span>)object;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="刪除物件"><a class="header-anchor" href="#刪除物件">#</a>刪除物件</h2><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*object</code></th></tr></thead><tbody><tr><td>刪除物件</td><td>void</td><td>要刪除的物件</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Destroys the object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The object destructors will be called in inherited type order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param object the object to destroy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_object_destroy</span><span class="params">(<span class="keyword">rtgui_object_t</span> *object)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!object || object-&gt;flag &amp; RTGUI_OBJECT_FLAG_STATIC)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTGUI_OBJECT_TRACE</span></span><br><span class="line">    obj_info.objs_number --;</span><br><span class="line">    obj_info.allocated_size -= object-&gt;type-&gt;size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call destructor */</span></span><br><span class="line">    RT_ASSERT(object-&gt;type != RT_NULL);</span><br><span class="line">    rtgui_type_destructors_call(object-&gt;type, object);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* release object */</span></span><br><span class="line">    rtgui_free(object);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_object_destroy);</span><br></pre></td></tr></tbody></table></figure><p>這裡一樣透過 <code>rtgui_type_destructors_call</code> 來呼叫正確的 <code>destruct</code> 函式，<code>destruct</code> 負責釋放該釋放的記憶體；最後透過 <code>rtgui_free</code> 釋放整個物件。<code>regui_free</code> 則簡單的呼叫 <code>rt_free</code> 釋放記憶體，我們在前幾篇文章有討論過了（<a href="/rt-mem#Code-free">mempool</a>、<a href="/rt-memheap#%E9%87%8B%E6%94%BE%E8%A8%98%E6%86%B6%E9%AB%94">memheap</a>、<a href="/rt-small-mem#%E9%87%8B%E6%94%BE%E8%A8%98%E6%86%B6%E9%AB%94">small mem</a>、<a href="/rt-slab#%E9%87%8B%E6%94%BE%E8%A8%98%E6%86%B6%E9%AB%94">slab</a>）</p><hr><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>呼叫正確的 <code>destructor</code> 函式來清除物件</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*type</code></th><th><code>*object</code></th></tr></thead><tbody><tr><td>欲清除的物件類型</td><td>物件本體</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_type_destructors_call</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtgui_type_t</span> *type, <span class="keyword">rtgui_object_t</span> *object)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* destruct from children to parent */</span></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;destructor)</span><br><span class="line">        type-&gt;destructor(object);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;parent)</span><br><span class="line">        rtgui_type_destructors_call(type-&gt;parent, object);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同樣的如果此物件類型是在某個物件類型的底下，先呼叫上層的 <code>destruct</code>；接著呼叫自己的 <code>desturct</code> 完成清除的動作。</p><hr><p>最後來看一下 “object” 的刪除函式：填入 none 的旗標，並將物件種類設為 NULL；動作在 <code>_rtgui_object_destructor</code> 完成</p><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*object</code></th></tr></thead><tbody><tr><td>“object” 的刪除函式</td><td>void</td><td>欲清除的物件</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Destroys the object */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _rtgui_object_destructor(<span class="keyword">rtgui_object_t</span> *object)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* Any valid objest should both have valid flag _and_ valid type. Only use</span></span><br><span class="line"><span class="comment">     * flag is not enough because the chunk of memory may be reallocted to other</span></span><br><span class="line"><span class="comment">     * object and thus the flag will become valid. */</span></span><br><span class="line">    object-&gt;flag = RTGUI_OBJECT_FLAG_NONE;</span><br><span class="line">    object-&gt;type = RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://blog.csdn.net/xuzhenglim/article/details/11883351" target="_blank" rel="noopener">RTGUI粗讲（个人见解篇之三、RTGUI WIDGET （2））</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;RT-Thread-GUI-物件架構&quot;&gt;&lt;a class=&quot;hea
      
    
    </summary>
    
    
      <category term="RT-Thread GUI" scheme="https://blog.lusw.dev/categories/RT-Thread-GUI/"/>
    
    
      <category term="kernel" scheme="https://blog.lusw.dev/tags/kernel/"/>
    
      <category term="RT-Thread" scheme="https://blog.lusw.dev/tags/RT-Thread/"/>
    
      <category term="GUI" scheme="https://blog.lusw.dev/tags/GUI/"/>
    
      <category term="OOP" scheme="https://blog.lusw.dev/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>使用 crontab 自動備份網站原始碼</title>
    <link href="https://blog.lusw.dev/auto-backup-with-crontab.html"/>
    <id>https://blog.lusw.dev/auto-backup-with-crontab.html</id>
    <published>2018-12-26T04:14:07.000Z</published>
    <updated>2020-04-22T08:51:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="shell-script"><a class="header-anchor" href="#shell-script">#</a>shell script</h2><p>透過 git 備份時，一定是使用下列指令</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">'log'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push</span></span><br></pre></td></tr></tbody></table></figure><p>而使用 shell script 可以讓我們一次執行一大串指令，因此我們來寫一個 shell script</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/zsh</span></span><br><span class="line">nowTime="$(date +'%Y-%m-%d %H:%M:%S')"</span><br><span class="line">echo "# Using crontab with auto.sh"</span><br><span class="line">echo "# File in ~/Desktop/auto.sh"</span><br><span class="line">echo "# Log  in ~/Desktop/cront.log"</span><br><span class="line">echo "#"</span><br><span class="line">echo "# Auto backup at ${nowTime}"</span><br><span class="line">echo "# --------------------------------------------------\n"</span><br><span class="line"></span><br><span class="line">cd /Users/username</span><br><span class="line">cd $1</span><br><span class="line">echo "Now at $(pwd)\n"</span><br><span class="line"></span><br><span class="line">log="auto backup at "${nowTime}</span><br><span class="line">git add .</span><br><span class="line">git commit -m "$log"</span><br><span class="line">result=$(git push site hexo_source_new 2&gt;&amp;1)</span><br><span class="line"></span><br><span class="line">case $result in</span><br><span class="line">    "Everything up-to-date")</span><br><span class="line">        osascript -e 'display notification "Everything up-to-date." with title "Automatically backup" sound name "basso"'</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        osascript -e 'display notification "Done!" with title "Automatically backup" sound name "hero"'</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br><span class="line">echo ${result}</span><br><span class="line">echo "Backup complete."</span><br></pre></td></tr></tbody></table></figure><p>其中我們為了方便整理，在提交的紀錄上增加了時間；並且在 push 完根據結果有不同的通知</p><div class="alert alert-danger"><p>此通知是基於 mac 上的 applescript 所寫的，在 linux 上會產生錯誤</p></div><h2 id="建立-crontab"><a class="header-anchor" href="#建立-crontab">#</a>建立 crontab</h2><p>寫好 script shell 後，再來就是要定時的執行它。使用 crontab 可以在指定的時間，或是固定的區間內執行。</p><p>使用方式，輸入指令 <code>crontab -e</code>，接著會跳進 vim，寫入</p><figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line">@hourly chmod +<span class="keyword">x</span> /Users/PATH_TO_YOUR.<span class="keyword">sh</span></span><br><span class="line">@hourly /Users/PATH_TO_YOUR.<span class="keyword">sh</span> PATH_TO_YOUR_SOURCE &gt;&gt; /Users/PATH_TO_YOUR.<span class="built_in">log</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>這裡首先提升一次權限，並設定每一次整點都備份一次 <code>@hourly</code>，並將結果寫入 log 中。我們需要先建立一個 .log 檔：</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch /Users/PATH_TO_YOUR.log</span></span><br></pre></td></tr></tbody></table></figure><p>當然這裡的所有路徑因人而異，檔名也無所謂，最後 <code>:wq</code> 存檔退出，安裝完畢</p><p><img src="https://i.imgur.com/w3qGjus.png" alt="" title="大功告成"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;shell-script&quot;&gt;&lt;a class=&quot;header-an
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.lusw.dev/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blog.lusw.dev/tags/Linux/"/>
    
      <category term="crontab" scheme="https://blog.lusw.dev/tags/crontab/"/>
    
  </entry>
  
  <entry>
    <title>自訂網域名稱：Google Domain</title>
    <link href="https://blog.lusw.dev/custom-domain-by-google-domain.html"/>
    <id>https://blog.lusw.dev/custom-domain-by-google-domain.html</id>
    <published>2018-12-13T03:17:28.000Z</published>
    <updated>2020-04-24T08:51:09.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="購買網域"><a class="header-anchor" href="#購買網域">#</a>購買網域</h2><p>網路上已經有很多如何在 <a href="https://domains.google.com/m/registrar/omuskywalker.com?hl=en#" target="_blank" rel="noopener">Google Domain</a> 上買網域的文章了，在此就不特別贅述，放上我看的幾篇文章：</p><ul><li><a href="https://free.com.tw/google-domains/" target="_blank" rel="noopener">台灣用戶也能在 Google Domains 註冊購買網域名稱，詳細申請設定教學</a></li><li><a href="https://sofree.cc/google-domains/" target="_blank" rel="noopener">[教學]如何用 Google Domains 買網址、註冊網域？ - 香腸炒魷魚</a></li></ul><div class="alert alert-default"><p>比較特別的的地方是，現在只開放部分國家可使用，所以在填地址的時候，可以去 google map 搜尋隨便一個美國的地址，然後使用</p></div><h2 id="設定-DNS"><a class="header-anchor" href="#設定-DNS">#</a>設定 DNS</h2><p>根據 Github 官方的說明，需設定 type <code>A</code> 的 IP 位址為</p><ul><li>185.199.108.153</li><li>185.199.109.153</li><li>185.199.110.153</li><li>185.199.111.153</li></ul><p>以及一個 CNAME，name 可以填任意字串，此字串就是你的 subdomain（像是我填 blog），如果不知道填什麼，可以填 www。最後你的畫面會長這樣：<br><img src="https://i.imgur.com/OTJsgaX.png" alt=""><br>CNAME 的 data 請填 <code>你的 github ID</code>+<code>.github.io.</code>，注意最後有一個點</p><p>這些都設定完，之後你的網址就會變成 <code>subdomain.domain.com</code></p><div class="alert alert-warning"><p>一個很重要的事情是，發布 hexo 的 github repo 須為 <strong><a href="http://github.io" target="_blank" rel="noopener">github.io</a></strong> 類型的，否則設定會有誤</p></div><h2 id="設定-github-CNAME"><a class="header-anchor" href="#設定-github-CNAME">#</a>設定 github CNAME</h2><p>Github 官方有提供 301 轉址功能，只要在網頁的 branch 下建立一個 <code>CNAME</code> 檔案，就會把舊網址轉址到新網址。你的 CNAME 應該要填以下內容：</p><figure class="highlight stylus"><table><tbody><tr><td class="code"><pre><span class="line">subdomain<span class="selector-class">.domain</span><span class="selector-class">.com</span></span><br></pre></td></tr></tbody></table></figure><p>其中 <code>subdomain</code> 與 <code>domain</code> 與自己的有關，像我的就是</p><figure class="highlight stylus"><table><tbody><tr><td class="code"><pre><span class="line">blog<span class="selector-class">.omuskywalker</span><span class="selector-class">.com</span></span><br></pre></td></tr></tbody></table></figure><p>如果你上面的 subdomain 設定為 www，而你的頂級網域（也就是你買的 domain 名字）沒有要給特別的網站用的話，也可以這樣寫：</p><figure class="highlight stylus"><table><tbody><tr><td class="code"><pre><span class="line">domain.com</span><br><span class="line">subdomain<span class="selector-class">.domain</span><span class="selector-class">.com</span></span><br></pre></td></tr></tbody></table></figure><p>這麼一來不管是上面哪兩種，都會連到你的 blog</p><div class="alert alert-info"><p>如果跟我一樣是用 hexo 的人，CNAME 請放在 /source 底下，這樣每次 <code>hexo d</code> 才不會被蓋掉</p></div><p>如果這些都有設定好，你的 github 應該會長這樣：<br><img src="https://i.imgur.com/e5GzzZH.png" alt=""></p><p>大概過幾個小時，你的新網址就可以用了（大功告成）!</p><h2 id="補充：HTTPS"><a class="header-anchor" href="#補充：HTTPS">#</a>補充：HTTPS</h2><p>Github page 有提供內建的 HTTPS，只要你的網站設定好一陣子（不會很久，一天內），會有這個選項可以按：<br><img src="https://i.imgur.com/z9HdVbV.png" alt=""><br>按下去，就會獲得 HTTPS 了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;購買網域&quot;&gt;&lt;a class=&quot;header-anchor&quot; hr
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://blog.lusw.dev/categories/Hexo/"/>
    
    
      <category term="hexo" scheme="https://blog.lusw.dev/tags/hexo/"/>
    
      <category term="github-page" scheme="https://blog.lusw.dev/tags/github-page/"/>
    
      <category term="CNAME" scheme="https://blog.lusw.dev/tags/CNAME/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread SLAB 動態管理</title>
    <link href="https://blog.lusw.dev/rt-slab.html"/>
    <id>https://blog.lusw.dev/rt-slab.html</id>
    <published>2018-12-05T07:42:50.000Z</published>
    <updated>2020-04-23T05:02:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>使用此管理方式： <code>#defined RT_USING_HEAP &amp;&amp; #defined RT_USING_SLAB</code></p></blockquote><p>SLAB 將記憶體根據不同的對象切成不同的區 (zone)，對象通常是大小，也可看成是一個 zone 代表一個 pool，不同的 zone 放在一個 array 管理。</p><p>一個 zone 大小介於 32kB~128kB 之間，最多可以有 72 種 zone；zone 對象大小上上限 16kB，超過由頁分配器分配</p><ul><li>alloc：根據需要的大小，找到對應的 zone 取得記憶體；如假設需要 32kB，我們去尋找對象為 32kB 的 zone。<ul><li>若是該 zone 為空（找不到），直接向頁分配器分配一個新的 zone，取得第一塊 free chunk</li><li>若非空，直接取得第一塊，如果拿完該 zone 已經沒有 free chunk 頁分配器須將此 zone 刪除</li></ul></li><li>free：找到對應的 zone 插入至 free list，如果該 zone 的所有 free chunk 都已經釋放完畢，則須將此 zone 整個釋放到分配器裡</li></ul><p><img src="https://i.imgur.com/GZdBl7V.png" alt="" title="SLAB example"></p><hr><h2 id="結構"><a class="header-anchor" href="#結構">#</a>結構</h2><div class="alert alert-success"><p><strong>File:</strong> slab.c</p></div><h3 id="Zone"><a class="header-anchor" href="#Zone">#</a>Zone</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The IN-BAND zone header is placed at the beginning of each zone.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slab_zone</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span>  z_magic;        <span class="comment">/* magic number for sanity check */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span>  z_nfree;        <span class="comment">/* total free chunks / ualloc space in zone */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span>  z_nmax;         <span class="comment">/* maximum free chunks */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">slab_zone</span> *<span class="title">z_next</span>;</span>   <span class="comment">/* zoneary[] link if z_nfree non-zero */</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span>  *z_baseptr;     <span class="comment">/* pointer to start of chunk array */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span>  z_uindex;       <span class="comment">/* current initial allocation index */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span>  z_chunksize;    <span class="comment">/* chunk size for validation */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span>  z_zoneindex;    <span class="comment">/* zone index */</span></span><br><span class="line">    slab_chunk  *z_freechunk;   <span class="comment">/* free chunk list */</span></span><br><span class="line">} slab_zone;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Chunk structure for free elements</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slab_chunk</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">slab_chunk</span> *<span class="title">c_next</span>;</span></span><br><span class="line">} slab_chunk;</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Page-Allocator"><a class="header-anchor" href="#Page-Allocator">#</a>Page Allocator</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* page allocator */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> *<span class="title">next</span>;</span>      <span class="comment">/* next valid page */</span></span><br><span class="line">    <span class="keyword">rt_size_t</span> page;                 <span class="comment">/* number of page  */</span></span><br><span class="line">    <span class="comment">/* dummy */</span></span><br><span class="line">    <span class="keyword">char</span> dummy[RT_MM_PAGE_SIZE - (<span class="keyword">sizeof</span>(struct rt_page_head *) + <span class="keyword">sizeof</span>(<span class="keyword">rt_size_t</span>))];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Descriptor"><a class="header-anchor" href="#Descriptor">#</a>Descriptor</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Array of descriptors that describe the contents of each page</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_TYPE_FREE      0x00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_TYPE_SMALL     0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_TYPE_LARGE     0x02</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memusage</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> type: <span class="number">2</span> ;       <span class="comment">/* page type */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> size: <span class="number">30</span>;       <span class="comment">/* pages allocated or offset from zone */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="初始化-heap"><a class="header-anchor" href="#初始化-heap">#</a>初始化 heap</h2><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 heap</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*begin_addr</code></th><th><code>*end_addr</code></th></tr></thead><tbody><tr><td>記憶體起始位址</td><td>結束位址</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ingroup SystemInit</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function will init system heap</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param begin_addr the beginning address of system page</span></span><br><span class="line"><span class="comment"> * @param end_addr the end address of system page</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_system_heap_init</span><span class="params">(<span class="keyword">void</span> *begin_addr, <span class="keyword">void</span> *end_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> limsize, npages;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* align begin and end addr to page */</span></span><br><span class="line">    heap_start = RT_ALIGN((<span class="keyword">rt_uint32_t</span>)begin_addr, RT_MM_PAGE_SIZE);</span><br><span class="line">    heap_end   = RT_ALIGN_DOWN((<span class="keyword">rt_uint32_t</span>)end_addr, RT_MM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heap_start &gt;= heap_end)</span><br><span class="line">    {</span><br><span class="line">        rt_kprintf(<span class="string">"rt_system_heap_init, wrong address[0x%x - 0x%x]\n"</span>,</span><br><span class="line">                   (<span class="keyword">rt_uint32_t</span>)begin_addr, (<span class="keyword">rt_uint32_t</span>)end_addr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>向上對齊起始位址，向下對其結束位址</li><li>檢查是否合法</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><span class="line">limsize = heap_end - heap_start;</span><br><span class="line">npages  = limsize / RT_MM_PAGE_SIZE;</span><br></pre></td></tr></tbody></table></figure><ul><li>計算最大的 size，設定頁數量</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* initialize heap semaphore */</span></span><br><span class="line">rt_sem_init(&amp;heap_sem, <span class="string">"heap"</span>, <span class="number">1</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line"></span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"heap[0x%x - 0x%x], size 0x%x, 0x%x pages\n"</span>,</span><br><span class="line">                             heap_start, heap_end, limsize, npages));</span><br></pre></td></tr></tbody></table></figure><ul><li>初始化 semaphore，值為 1</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">369</span><br><span class="line">370</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* init pages */</span></span><br><span class="line">rt_page_init((<span class="keyword">void</span> *)heap_start, npages);</span><br></pre></td></tr></tbody></table></figure><ul><li>初始化 page</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* calculate zone size */</span></span><br><span class="line">zone_size = ZALLOC_MIN_ZONE_SIZE;</span><br><span class="line"><span class="keyword">while</span> (zone_size &lt; ZALLOC_MAX_ZONE_SIZE &amp;&amp; (zone_size &lt;&lt; <span class="number">1</span>) &lt; (limsize / <span class="number">1024</span>))</span><br><span class="line">    zone_size &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">zone_limit = zone_size / <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (zone_limit &gt; ZALLOC_ZONE_LIMIT)</span><br><span class="line">    zone_limit = ZALLOC_ZONE_LIMIT;</span><br><span class="line"></span><br><span class="line">zone_page_cnt = zone_size / RT_MM_PAGE_SIZE;</span><br></pre></td></tr></tbody></table></figure><ul><li>計算 zone 的大小、對象大小的上限及總頁數</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br></pre></td><td class="code"><pre><span class="line">    RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"zone size 0x%x, zone page count 0x%x\n"</span>,</span><br><span class="line">                                 zone_size, zone_page_cnt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate memusage array */</span></span><br><span class="line">    limsize  = npages * <span class="keyword">sizeof</span>(struct memusage);</span><br><span class="line">    limsize  = RT_ALIGN(limsize, RT_MM_PAGE_SIZE);</span><br><span class="line">    memusage = rt_page_alloc(limsize / RT_MM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"memusage 0x%x, size 0x%x\n"</span>,</span><br><span class="line">                                 (<span class="keyword">rt_uint32_t</span>)memusage, limsize));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最後建立一個陣列紀錄頁的資訊</li></ul><hr><h3 id="rt-page-init"><a class="header-anchor" href="#rt-page-init">#</a>rt_page_init</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化頁分配器</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*addr</code></th><th><code>npages</code></th></tr></thead><tbody><tr><td>存放頁的記憶體位址</td><td>頁的總數</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initialize the page allocator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rt_page_init</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">rt_size_t</span> npages)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(addr != RT_NULL);</span><br><span class="line">    RT_ASSERT(npages != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    rt_page_list = RT_NULL;</span><br><span class="line">    rt_page_free(addr, npages);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>將 page list 設為空，釋放所有的 page</li></ul><hr><h2 id="分配記憶體"><a class="header-anchor" href="#分配記憶體">#</a>分配記憶體</h2><h3 id="rt-malloc"><a class="header-anchor" href="#rt-malloc">#</a>rt_malloc</h3><table><thead><tr><th>功能</th><th>回傳值</th><th><code>size</code></th></tr></thead><tbody><tr><td>要求記憶體</td><td>記憶體位址</td><td>欲要求的大小</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will allocate a block from system heap memory.</span></span><br><span class="line"><span class="comment"> * - If the nbytes is less than zero,</span></span><br><span class="line"><span class="comment"> * or</span></span><br><span class="line"><span class="comment"> * - If there is no nbytes sized memory valid in system,</span></span><br><span class="line"><span class="comment"> * the RT_NULL is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param size the size of memory to be allocated</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the allocated memory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_malloc</span><span class="params">(<span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    slab_zone *z;</span><br><span class="line">    <span class="keyword">rt_int32_t</span> zi;</span><br><span class="line">    slab_chunk *chunk;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">memusage</span> *<span class="title">kup</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zero size, return RT_NULL */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 size = 0，回傳 NULL</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Handle large allocations directly.  There should not be very many of</span></span><br><span class="line"><span class="comment"> * these so performance is not a big issue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (size &gt;= zone_limit)</span><br><span class="line">{</span><br><span class="line">    size = RT_ALIGN(size, RT_MM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    chunk = rt_page_alloc(size &gt;&gt; RT_MM_PAGE_BITS);</span><br><span class="line">    <span class="keyword">if</span> (chunk == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 size 超過一個 chunk 的上限，則透過頁分配器來分配</li><li>且如果失敗了，直接回傳 <code>NULL</code></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set kup */</span></span><br><span class="line">kup = btokup(chunk);</span><br><span class="line">kup-&gt;type = PAGE_TYPE_LARGE;</span><br><span class="line">kup-&gt;size = size &gt;&gt; RT_MM_PAGE_BITS;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定頁的資訊：<ul><li>type：<code>PAGE_TYPE_LARGE</code></li><li>size：用了幾頁</li></ul></li><li>btokup：<code>&amp;memusage[((rt_uint32_t)(addr) - heap_start) &gt;&gt; RT_MM_PAGE_BITS]</code><ul><li>找到陣列中與起始位置的差值，位移 12-bit，即除一頁的大小</li></ul></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br></pre></td><td class="code"><pre><span class="line">        RT_DEBUG_LOG(RT_DEBUG_SLAB,</span><br><span class="line">                     (<span class="string">"malloc a large memory 0x%x, page cnt %d, kup %d\n"</span>,</span><br><span class="line">                      size,</span><br><span class="line">                      size &gt;&gt; RT_MM_PAGE_BITS,</span><br><span class="line">                      ((<span class="keyword">rt_uint32_t</span>)chunk - heap_start) &gt;&gt; RT_MM_PAGE_BITS));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* lock heap */</span></span><br><span class="line">        rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem += size;</span><br><span class="line">        <span class="keyword">if</span> (used_mem &gt; max_mem)</span><br><span class="line">            max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>要鎖，更新使用大小，跳到 <code>__done</code></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lock heap */</span></span><br><span class="line">rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to allocate out of an existing zone.  First try the free list,</span></span><br><span class="line"><span class="comment"> * then allocate out of unallocated space.  If we find a good zone move</span></span><br><span class="line"><span class="comment"> * it to the head of the list so later allocations find it quickly</span></span><br><span class="line"><span class="comment"> * (we might have thousands of zones in the list).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: zoneindex() will panic of size is too large.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">zi = zoneindex(&amp;size);</span><br><span class="line">RT_ASSERT(zi &lt; NZONES);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 size 小於一個 chunk 的上限，尋找此大小對應的 zone</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"try to malloc 0x%x on zone: %d\n"</span>, size, zi));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((z = zone_array[zi]) != RT_NULL)</span><br><span class="line">{</span><br><span class="line">    RT_ASSERT(z-&gt;z_nfree &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove us from the zone_array[] when we become empty */</span></span><br><span class="line">    <span class="keyword">if</span> (--z-&gt;z_nfree == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        zone_array[zi] = z-&gt;z_next;</span><br><span class="line">        z-&gt;z_next = RT_NULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果該 zone 不為空，且此 zone 剩最後一顆可用時，將此 zone 刪除</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * No chunks are available but nfree said we had some memory, so</span></span><br><span class="line"><span class="comment">         * it must be available in the never-before-used-memory area</span></span><br><span class="line"><span class="comment">         * governed by uindex.  The consequences are very serious if our zone</span></span><br><span class="line"><span class="comment">         * got corrupted so we use an explicit rt_kprintf rather then a KASSERT.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (z-&gt;z_uindex + <span class="number">1</span> != z-&gt;z_nmax)</span><br><span class="line">        {</span><br><span class="line">            z-&gt;z_uindex = z-&gt;z_uindex + <span class="number">1</span>;</span><br><span class="line">            chunk = (slab_chunk *)(z-&gt;z_baseptr + z-&gt;z_uindex * size);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* find on free chunk list */</span></span><br><span class="line">            chunk = z-&gt;z_freechunk;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* remove this chunk from list */</span></span><br><span class="line">            z-&gt;z_freechunk = z-&gt;z_freechunk-&gt;c_next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem += z-&gt;z_chunksize;</span><br><span class="line">        <span class="keyword">if</span> (used_mem &gt; max_mem)</span><br><span class="line">            max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>取得一塊，跳至 done<ul><li>從 <code>uindex</code> 找，這種方式取得的屬於此 zone 最初的 chunk</li><li>如果不行，從 free list 中取得，並從 free list 移除此 chunk；這種的 chunk 是已經被要過，又還回來的</li></ul></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If all zones are exhausted we need to allocate a new zone for this</span></span><br><span class="line"><span class="comment"> * index.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * At least one subsystem, the tty code (see CROUND) expects power-of-2</span></span><br><span class="line"><span class="comment"> * allocations to be power-of-2 aligned.  We maintain compatibility by</span></span><br><span class="line"><span class="comment"> * adjusting the base offset below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_int32_t</span> off;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z = zone_free) != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* remove zone from free zone list */</span></span><br><span class="line">        zone_free = z-&gt;z_next;</span><br><span class="line">        -- zone_free_cnt;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果找到的 zone 為空，且 <code>zone_free</code> 不為空：代表有可用的空 zone 可以使用</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* unlock heap, since page allocator will think about lock */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate a zone from page */</span></span><br><span class="line">    z = rt_page_alloc(zone_size / RT_MM_PAGE_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (z == RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        chunk = RT_NULL;</span><br><span class="line">        <span class="keyword">goto</span> __exit;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>否則需要重新與頁分配器要一個 zone</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* lock heap */</span></span><br><span class="line">    rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"alloc a new zone: 0x%x\n"</span>,</span><br><span class="line">                                 (<span class="keyword">rt_uint32_t</span>)z));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set message usage */</span></span><br><span class="line">    <span class="keyword">for</span> (off = <span class="number">0</span>, kup = btokup(z); off &lt; zone_page_cnt; off ++)</span><br><span class="line">    {</span><br><span class="line">        kup-&gt;type = PAGE_TYPE_SMALL;</span><br><span class="line">        kup-&gt;size = off;</span><br><span class="line"></span><br><span class="line">        kup ++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著設定每一頁的資訊</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">616</span><br><span class="line">617</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* clear to zero */</span></span><br><span class="line">rt_memset(z, <span class="number">0</span>, <span class="keyword">sizeof</span>(slab_zone));</span><br></pre></td></tr></tbody></table></figure><ul><li>清空整個 zone</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* offset of slab zone struct in zone */</span></span><br><span class="line">off = <span class="keyword">sizeof</span>(slab_zone);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Guarentee power-of-2 alignment for power-of-2-sized chunks.</span></span><br><span class="line"><span class="comment"> * Otherwise just 8-byte align the data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((size | (size - <span class="number">1</span>)) + <span class="number">1</span> == (size &lt;&lt; <span class="number">1</span>))</span><br><span class="line">    off = (off + size - <span class="number">1</span>) &amp; ~(size - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    off = (off + MIN_CHUNK_MASK) &amp; ~MIN_CHUNK_MASK;</span><br></pre></td></tr></tbody></table></figure><ul><li>計算我們要用的對齊法：<ul><li>如果 size 是二的次方，將 off (zone 的頭) 與 size 向上對齊</li><li>否則直接與 8 向上對齊</li></ul></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br></pre></td><td class="code"><pre><span class="line">z-&gt;z_magic     = ZALLOC_SLAB_MAGIC;</span><br><span class="line">z-&gt;z_zoneindex = zi;</span><br><span class="line">z-&gt;z_nmax      = (zone_size - off) / size;</span><br><span class="line">z-&gt;z_nfree     = z-&gt;z_nmax - <span class="number">1</span>;</span><br><span class="line">z-&gt;z_baseptr   = (<span class="keyword">rt_uint8_t</span> *)z + off;</span><br><span class="line">z-&gt;z_uindex    = <span class="number">0</span>;</span><br><span class="line">z-&gt;z_chunksize = size;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定 magic、對應 <code>zone_array</code> 的 index<ul><li>最大數量為 <code>zone_size</code> - off 再除以一個 chunk 的大小</li><li>目前可用的數量則為最大數量減 1，因為待會會拿走一塊</li><li>基址為起始位址加上 <code>off，uindex</code> 為 0，這是之後 alloc 時可直接使用這兩個來找到 free chunk</li><li>最後設定 chunk size</li></ul></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br></pre></td><td class="code"><pre><span class="line">        chunk = (slab_chunk *)(z-&gt;z_baseptr + z-&gt;z_uindex * size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* link to zone array */</span></span><br><span class="line">        z-&gt;z_next = zone_array[zi];</span><br><span class="line">        zone_array[zi] = z;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem += z-&gt;z_chunksize;</span><br><span class="line">        <span class="keyword">if</span> (used_mem &gt; max_mem)</span><br><span class="line">            max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>拿走第一塊，並將這個 zone 插上對應的 zone array entry</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br></pre></td><td class="code"><pre><span class="line">done:</span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_malloc_hook, ((<span class="keyword">char</span> *)chunk, size));</span><br><span class="line"></span><br><span class="line">__exit:</span><br><span class="line">    <span class="keyword">return</span> chunk;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_malloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後回傳找到的 chunk</li></ul><hr><h4 id="zoneindex"><a class="header-anchor" href="#zoneindex">#</a>zoneindex</h4><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*bytes</code></th></tr></thead><tbody><tr><td>尋找傳入的 size 對應 zone array 的 index</td><td>index</td><td>傳入的大小</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Calculate the zone index for the allocation request size and set the</span></span><br><span class="line"><span class="comment"> * allocation request size to that particular zone's chunk size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">rt_inline <span class="keyword">int</span> <span class="title">zoneindex</span><span class="params">(<span class="keyword">rt_uint32_t</span> *bytes)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* unsigned for shift opt */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> n = (<span class="keyword">rt_uint32_t</span>) * bytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">128</span>)</span><br><span class="line">    {</span><br><span class="line">        *bytes = n = (n + <span class="number">7</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 8 byte chunks, 16 zones */</span></span><br><span class="line">        <span class="keyword">return</span> (n / <span class="number">8</span> - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">256</span>)</span><br><span class="line">    {</span><br><span class="line">        *bytes = n = (n + <span class="number">15</span>) &amp; ~<span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (n / <span class="number">16</span> + <span class="number">7</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">8192</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">512</span>)</span><br><span class="line">        {</span><br><span class="line">            *bytes = n = (n + <span class="number">31</span>) &amp; ~<span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (n / <span class="number">32</span> + <span class="number">15</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1024</span>)</span><br><span class="line">        {</span><br><span class="line">            *bytes = n = (n + <span class="number">63</span>) &amp; ~<span class="number">63</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (n / <span class="number">64</span> + <span class="number">23</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2048</span>)</span><br><span class="line">        {</span><br><span class="line">            *bytes = n = (n + <span class="number">127</span>) &amp; ~<span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (n / <span class="number">128</span> + <span class="number">31</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4096</span>)</span><br><span class="line">        {</span><br><span class="line">            *bytes = n = (n + <span class="number">255</span>) &amp; ~<span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (n / <span class="number">256</span> + <span class="number">39</span>);</span><br><span class="line">        }</span><br><span class="line">        *bytes = n = (n + <span class="number">511</span>) &amp; ~<span class="number">511</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (n / <span class="number">512</span> + <span class="number">47</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">16384</span>)</span><br><span class="line">    {</span><br><span class="line">        *bytes = n = (n + <span class="number">1023</span>) &amp; ~<span class="number">1023</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (n / <span class="number">1024</span> + <span class="number">55</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    rt_kprintf(<span class="string">"Unexpected byte count %d"</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>根據不同的 range，將傳入的大小對齊，並平均分配每個 range 有 16 個 zone index</p><hr><h4 id="rt-page-alloc"><a class="header-anchor" href="#rt-page-alloc">#</a>rt_page_alloc</h4><table><thead><tr><th>功能</th><th>回傳值</th><th><code>npages</code></th></tr></thead><tbody><tr><td>要求頁記憶體</td><td>頁</td><td>欲要求的頁數</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_page_alloc</span><span class="params">(<span class="keyword">rt_size_t</span> npages)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> *<span class="title">b</span>, *<span class="title">n</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> **<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (npages == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lock heap */</span></span><br><span class="line">    rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line">    <span class="keyword">for</span> (prev = &amp;rt_page_list; (b = *prev) != RT_NULL; prev = &amp;(b-&gt;next))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (b-&gt;page &gt; npages)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* splite pages */</span></span><br><span class="line">            n       = b + npages;</span><br><span class="line">            n-&gt;next = b-&gt;next;</span><br><span class="line">            n-&gt;page = b-&gt;page - npages;</span><br><span class="line">            *prev   = n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果找到一個頁數大於需求的，選擇此頁，並分割</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (b-&gt;page == npages)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* this node fit, remove this node */</span></span><br><span class="line">            *prev = b-&gt;next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlock heap */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果有一個剛剛好，選擇此頁</li><li>最後回傳選擇的頁</li></ul><hr><h3 id="rt-realloc"><a class="header-anchor" href="#rt-realloc">#</a>rt_realloc</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>增長/縮減記憶體</td><td>記憶體位址</td></tr></tbody></table><table><thead><tr><th><code>*rmem</code></th><th><code>newsize</code></th></tr></thead><tbody><tr><td>欲增長/縮減的記憶體位址</td><td>新的大小</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will change the size of previously allocated memory block.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param ptr the previously allocated memory block</span></span><br><span class="line"><span class="comment"> * @param size the new size of memory block</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the allocated memory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *nptr;</span><br><span class="line">    slab_zone *z;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">memusage</span> *<span class="title">kup</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> rt_malloc(size);</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_free(ptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果傳入的 <code>ptr</code> 為空，<code>malloc(size)</code></li><li>如果傳入的 <code>size</code> 為 0，<code>free(ptr)</code></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the original allocation's zone.  If the new request winds up</span></span><br><span class="line"><span class="comment"> * using the same chunk size we do not have to do anything.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">kup = btokup((<span class="keyword">rt_uint32_t</span>)ptr &amp; ~RT_MM_PAGE_MASK);</span><br><span class="line"><span class="keyword">if</span> (kup-&gt;type == PAGE_TYPE_LARGE)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_size_t</span> osize;</span><br><span class="line"></span><br><span class="line">    osize = kup-&gt;size &lt;&lt; RT_MM_PAGE_BITS;</span><br><span class="line">    <span class="keyword">if</span> ((nptr = rt_malloc(size)) == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    rt_memcpy(nptr, ptr, size &gt; osize ? osize : size);</span><br><span class="line">    rt_free(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nptr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著檢查此 <code>ptr</code> 所在的頁資訊，如果是 LARGE，代表原來的 <code>ptr</code> 是由頁分配器所分配的</li><li>新 <code>malloc(size)</code>，並還原資料，釋放舊的記憶體</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (kup-&gt;type == PAGE_TYPE_SMALL)</span><br><span class="line">{</span><br><span class="line">    z = (slab_zone *)(((<span class="keyword">rt_uint32_t</span>)ptr &amp; ~RT_MM_PAGE_MASK) -</span><br><span class="line">                      kup-&gt;size * RT_MM_PAGE_SIZE);</span><br><span class="line">    RT_ASSERT(z-&gt;z_magic == ZALLOC_SLAB_MAGIC);</span><br><span class="line"></span><br><span class="line">    zoneindex(&amp;size);</span><br><span class="line">    <span class="keyword">if</span> (z-&gt;z_chunksize == size)</span><br><span class="line">        <span class="keyword">return</span> (ptr); <span class="comment">/* same chunk */</span></span><br></pre></td></tr></tbody></table></figure><ul><li>如果是 SMALL，首先找到歸屬得 zone：<ul><li>透過減掉頁資訊上的 size 乘以頁的大小，即可找到zone的初始位址</li><li>在 <code>malloc</code> 中，建立 zone 時 size 是從 0 開始填，一頁一頁加一</li><li>如果新的大小與原本的 chunk 相同，不做事</li></ul></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Allocate memory for the new request size.  Note that zoneindex has</span></span><br><span class="line"><span class="comment">         * already adjusted the request size to the appropriate chunk size, which</span></span><br><span class="line"><span class="comment">         * should optimize our bcopy().  Then copy and return the new pointer.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((nptr = rt_malloc(size)) == RT_NULL)</span><br><span class="line">            <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line">        rt_memcpy(nptr, ptr, size &gt; z-&gt;z_chunksize ? z-&gt;z_chunksize : size);</span><br><span class="line">        rt_free(ptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_realloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果不同，<code>malloc(size)</code>，並還原資料，釋放舊的記憶體</li></ul><hr><h3 id="rt-calloc"><a class="header-anchor" href="#rt-calloc">#</a>rt_calloc</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>要求一段連續的記憶體</td><td>記憶體位址</td></tr></tbody></table><table><thead><tr><th><code>count</code></th><th><code>size</code></th></tr></thead><tbody><tr><td>欲要求的數量</td><td>一塊的大小</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will contiguously allocate enough space for count objects</span></span><br><span class="line"><span class="comment"> * that are size bytes of memory each and returns a pointer to the allocated</span></span><br><span class="line"><span class="comment"> * memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The allocated memory is filled with bytes of value zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param count number of objects to allocate</span></span><br><span class="line"><span class="comment"> * @param size size of the objects to allocate</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return pointer to allocated memory / NULL pointer if there is an error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_calloc</span><span class="params">(<span class="keyword">rt_size_t</span> count, <span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    <span class="comment">/* allocate 'count' objects of size 'size' */</span></span><br><span class="line">    p = rt_malloc(count * size);</span><br><span class="line">    <span class="comment">/* zero the memory */</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        rt_memset(p, <span class="number">0</span>, count * size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_calloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>與 memheap 相同，一次要一塊 <code>count</code> 乘 <code>size</code> 的記憶體</li><li>清 0 並回傳起始位址</li></ul><hr><h2 id="釋放記憶體"><a class="header-anchor" href="#釋放記憶體">#</a>釋放記憶體</h2><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*ptr</code></th></tr></thead><tbody><tr><td>釋放記憶體</td><td>void</td><td>欲釋放的記憶體</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will release the previous allocated memory block by rt_malloc.</span></span><br><span class="line"><span class="comment"> * The released memory block is taken back to system heap.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param ptr the address of memory which will be released</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    slab_zone *z;</span><br><span class="line">    slab_chunk *chunk;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">memusage</span> *<span class="title">kup</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free a RT_NULL pointer */</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_free_hook, (ptr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get memory usage */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RT_DEBUG_SLAB</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">rt_uint32_t</span> addr = ((<span class="keyword">rt_uint32_t</span>)ptr &amp; ~RT_MM_PAGE_MASK);</span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_SLAB,</span><br><span class="line">                     (<span class="string">"free a memory 0x%x and align to 0x%x, kup index %d\n"</span>,</span><br><span class="line">                      (<span class="keyword">rt_uint32_t</span>)ptr,</span><br><span class="line">                      (<span class="keyword">rt_uint32_t</span>)addr,</span><br><span class="line">                      ((<span class="keyword">rt_uint32_t</span>)(addr) - heap_start) &gt;&gt; RT_MM_PAGE_BITS));</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    kup = btokup((<span class="keyword">rt_uint32_t</span>)ptr &amp; ~RT_MM_PAGE_MASK);</span><br><span class="line">    <span class="comment">/* release large allocation */</span></span><br><span class="line">    <span class="keyword">if</span> (kup-&gt;type == PAGE_TYPE_LARGE)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">rt_uint32_t</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* lock heap */</span></span><br><span class="line">        rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line">        <span class="comment">/* clear page counter */</span></span><br><span class="line">        size = kup-&gt;size;</span><br><span class="line">        kup-&gt;size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem -= size * RT_MM_PAGE_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_SLAB,</span><br><span class="line">                     (<span class="string">"free large memory block 0x%x, page count %d\n"</span>,</span><br><span class="line">                      (<span class="keyword">rt_uint32_t</span>)ptr, size));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* free this page */</span></span><br><span class="line">        rt_page_free(ptr, size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果要釋放的記憶體是由頁分配器分配的，根據頁資訊中的 size 來釋放，並清 0</li><li>實際呼叫 <code>rt_page_free(ptr, size)</code> 來完成</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* lock heap */</span></span><br><span class="line">    rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zone case. get out zone. */</span></span><br><span class="line">    z = (slab_zone *)(((<span class="keyword">rt_uint32_t</span>)ptr &amp; ~RT_MM_PAGE_MASK) -</span><br><span class="line">                      kup-&gt;size * RT_MM_PAGE_SIZE);</span><br><span class="line">    RT_ASSERT(z-&gt;z_magic == ZALLOC_SLAB_MAGIC);</span><br><span class="line"></span><br><span class="line">    chunk          = (slab_chunk *)ptr;</span><br><span class="line">    chunk-&gt;c_next  = z-&gt;z_freechunk;</span><br><span class="line">    z-&gt;z_freechunk = chunk;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">    used_mem -= z-&gt;z_chunksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>如果是由 zone 分配，找到歸屬的 zone，並將需要釋放的 chunk 插到 free list 上</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bump the number of free chunks.  If it becomes non-zero the zone</span></span><br><span class="line"><span class="comment"> * must be added back onto the appropriate list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (z-&gt;z_nfree++ == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    z-&gt;z_next = zone_array[z-&gt;z_zoneindex];</span><br><span class="line">    zone_array[z-&gt;z_zoneindex] = z;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>更新 <code>nfree</code>，如果本來為 0 ，則需要將此 zone 插回 zone array</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the zone becomes totally free, and there are other zones we</span></span><br><span class="line"><span class="comment"> * can allocate from, move this zone to the FreeZones list.  Since</span></span><br><span class="line"><span class="comment"> * this code can be called from an IPI callback, do *NOT* try to mess</span></span><br><span class="line"><span class="comment"> * with kernel_map here.  Hysteresis will be performed at malloc() time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (z-&gt;z_nfree == z-&gt;z_nmax &amp;&amp;</span><br><span class="line">    (z-&gt;z_next || zone_array[z-&gt;z_zoneindex] != z))</span><br><span class="line">{</span><br><span class="line">    slab_zone **pz;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"free zone 0x%x\n"</span>,</span><br><span class="line">                                 (<span class="keyword">rt_uint32_t</span>)z, z-&gt;z_zoneindex));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remove zone from zone array list */</span></span><br><span class="line">    <span class="keyword">for</span> (pz = &amp;zone_array[z-&gt;z_zoneindex]; z != *pz; pz = &amp;(*pz)-&gt;z_next)</span><br><span class="line">        ;</span><br><span class="line">    *pz = z-&gt;z_next;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果釋放完這個 chunk 後整個 zone 都釋放完了，我們需要釋放整個 zone</li><li>這裡還同時確保在同一個 zone array entry 中還有其他的 zone 可以分配</li><li>接著我們把這個 zone 從 zone array 移除</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset zone */</span></span><br><span class="line">z-&gt;z_magic = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* insert to free zone list */</span></span><br><span class="line">z-&gt;z_next = zone_free;</span><br><span class="line">zone_free = z;</span><br><span class="line"></span><br><span class="line">++ zone_free_cnt;</span><br></pre></td></tr></tbody></table></figure><ul><li>重設 magic，將這個 zone 插上 free zone，free count 加一</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* release zone to page allocator */</span></span><br><span class="line">        <span class="keyword">if</span> (zone_free_cnt &gt; ZONE_RELEASE_THRESH)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">rt_base_t</span> i;</span><br><span class="line"></span><br><span class="line">            z         = zone_free;</span><br><span class="line">            zone_free = z-&gt;z_next;</span><br><span class="line">            -- zone_free_cnt;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* set message usage */</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>, kup = btokup(z); i &lt; zone_page_cnt; i ++)</span><br><span class="line">            {</span><br><span class="line">                kup-&gt;type = PAGE_TYPE_FREE;</span><br><span class="line">                kup-&gt;size = <span class="number">0</span>;</span><br><span class="line">                kup ++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* unlock heap */</span></span><br><span class="line">            rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* release pages */</span></span><br><span class="line">            rt_page_free(z, zone_size / RT_MM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* unlock heap */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_free);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果已經有 <code>ZONE_RELEASE_THRESH</code> (2) 個以上的 free zone，完全釋放一個 zone 給頁分配器<ul><li>從 free zone 中移除，free count 減一</li><li>重設頁資訊：type free、size 0</li><li>透過 <code>rt_page_free</code> 完成</li></ul></li></ul><hr><h3 id="rt-page-free"><a class="header-anchor" href="#rt-page-free">#</a>rt_page_free</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>釋放頁記憶體</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*addr</code></th><th><code>pages</code></th></tr></thead><tbody><tr><td>欲釋放的頁</td><td>欲釋放的大小</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_page_free</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">rt_size_t</span> npages)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> *<span class="title">b</span>, *<span class="title">n</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> **<span class="title">prev</span>;</span></span><br><span class="line">    RT_ASSERT(addr != RT_NULL);</span><br><span class="line">    RT_ASSERT((<span class="keyword">rt_uint32_t</span>)addr % RT_MM_PAGE_SIZE == <span class="number">0</span>);</span><br><span class="line">    RT_ASSERT(npages != <span class="number">0</span>);</span><br><span class="line">    n = (struct rt_page_head *)addr;</span><br><span class="line">    <span class="comment">/* lock heap */</span></span><br><span class="line">    rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line">    <span class="keyword">for</span> (prev = &amp;rt_page_list; (b = *prev) != RT_NULL; prev = &amp;(b-&gt;next))</span><br><span class="line">    {</span><br><span class="line">        RT_ASSERT(b-&gt;page &gt; <span class="number">0</span>);</span><br><span class="line">        RT_ASSERT(b &gt; n || b + b-&gt;page &lt;= n);</span><br><span class="line">        <span class="keyword">if</span> (b + b-&gt;page == n)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (b + (b-&gt;page += npages) == b-&gt;next)</span><br><span class="line">            {</span><br><span class="line">                b-&gt;page += b-&gt;next-&gt;page;</span><br><span class="line">                b-&gt;next  = b-&gt;next-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">goto</span> _return;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (b == n + npages)</span><br><span class="line">        {</span><br><span class="line">            n-&gt;page = b-&gt;page + npages;</span><br><span class="line">            n-&gt;next = b-&gt;next;</span><br><span class="line">            *prev   = n;</span><br><span class="line">            <span class="keyword">goto</span> _return;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (b &gt; n + npages)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    n-&gt;page = npages;</span><br><span class="line">    n-&gt;next = b;</span><br><span class="line">    *prev   = n;</span><br><span class="line">_return:</span><br><span class="line">    <span class="comment">/* unlock heap */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;使用此管理方式： &lt;code&gt;#defined R
      
    
    </summary>
    
    
      <category term="RT-Thread" scheme="https://blog.lusw.dev/categories/RT-Thread/"/>
    
    
      <category term="kernel" scheme="https://blog.lusw.dev/tags/kernel/"/>
    
      <category term="RT-Thread" scheme="https://blog.lusw.dev/tags/RT-Thread/"/>
    
      <category term="記憶體管理" scheme="https://blog.lusw.dev/tags/MemMan/"/>
    
      <category term="SLAB" scheme="https://blog.lusw.dev/tags/SLAB/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread 小記憶體動態管理</title>
    <link href="https://blog.lusw.dev/rt-small-mem.html"/>
    <id>https://blog.lusw.dev/rt-small-mem.html</id>
    <published>2018-12-05T07:42:44.000Z</published>
    <updated>2020-04-23T05:02:36.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>使用此管理方式： <code>#defined RT_USING_HEAP &amp;&amp; #defined RT_USING_SMALL_MEM</code></p></blockquote><ul><li>與 memory heap 的做法類似，一開始是一塊大的記憶體，包含 header</li><li>分配記憶體時適當的切割</li><li>所有的記憶體塊透過 header 串起來，形成一個雙向鏈結</li></ul><p><img src="https://i.imgur.com/tbptSYO.png" alt="" title="small memory example"></p><hr><h2 id="結構"><a class="header-anchor" href="#結構">#</a>結構</h2><div class="alert alert-success"><p><strong>File:</strong> mem.c</p></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* magic and used flag */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span> magic;</span><br><span class="line">    <span class="keyword">rt_uint16_t</span> used;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_size_t</span> next, prev;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span> thread[<span class="number">4</span>];   <span class="comment">/* thread name */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>此結構即為一個記憶體塊的 header</li><li>包含了<ul><li>magic 碼 <code>0x1ea0</code></li><li>使用中標記</li><li>前一顆與下一顆</li><li>使用此記憶體的 thread 名稱（選）</li></ul></li></ul><hr><h2 id="初始化-heap"><a class="header-anchor" href="#初始化-heap">#</a>初始化 heap</h2><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 heap</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*begin_addr</code></th><th><code>*end_addr</code></th></tr></thead><tbody><tr><td>記憶體起始位址</td><td>結束位址</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ingroup SystemInit</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function will initialize system heap memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param begin_addr the beginning address of system heap memory.</span></span><br><span class="line"><span class="comment"> * @param end_addr the end address of system heap memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_system_heap_init</span><span class="params">(<span class="keyword">void</span> *begin_addr, <span class="keyword">void</span> *end_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">mem</span>;</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> begin_align = RT_ALIGN((<span class="keyword">rt_uint32_t</span>)begin_addr, RT_ALIGN_SIZE);</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> end_align = RT_ALIGN_DOWN((<span class="keyword">rt_uint32_t</span>)end_addr, RT_ALIGN_SIZE);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br></pre></td></tr></tbody></table></figure><ul><li>向上對齊起始位址與向下對齊結束位址</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* alignment addr */</span></span><br><span class="line"><span class="keyword">if</span> ((end_align &gt; (<span class="number">2</span> * SIZEOF_STRUCT_MEM)) &amp;&amp;</span><br><span class="line">    ((end_align - <span class="number">2</span> * SIZEOF_STRUCT_MEM) &gt;= begin_align))</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* calculate the aligned memory size */</span></span><br><span class="line">    mem_size_aligned = end_align - begin_align - <span class="number">2</span> * SIZEOF_STRUCT_MEM;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    rt_kprintf(<span class="string">"mem init, error begin address 0x%x, and end address 0x%x\n"</span>,</span><br><span class="line">               (<span class="keyword">rt_uint32_t</span>)begin_addr, (<span class="keyword">rt_uint32_t</span>)end_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著檢查起始與結束位址是否合法</li><li>如果合法，給定 <code>mem_size</code> 為結束位址 - 起始位址 - 2 倍的 <code>struct mem</code> 大小</li><li>也就是與 <code>mem_heap</code> 相同，一開始的記憶體設定為一大塊，頭與尾都要有一個 header</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* point to begin address of heap */</span></span><br><span class="line">heap_ptr = (<span class="keyword">rt_uint8_t</span> *)begin_align;</span><br><span class="line"></span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"mem init, heap begin address 0x%x, size %d\n"</span>,</span><br><span class="line">                            (<span class="keyword">rt_uint32_t</span>)heap_ptr, mem_size_aligned));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initialize the start of the heap */</span></span><br><span class="line">mem        = (struct heap_mem *)heap_ptr;</span><br><span class="line">mem-&gt;magic = HEAP_MAGIC;</span><br><span class="line">mem-&gt;next  = mem_size_aligned + SIZEOF_STRUCT_MEM;</span><br><span class="line">mem-&gt;prev  = <span class="number">0</span>;</span><br><span class="line">mem-&gt;used  = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>接著設定前面的 header：<ul><li>設定 magic 碼</li><li>下一塊為結尾的 header</li><li>上一塊為自己</li><li>以及沒有使用過</li></ul></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">    rt_mem_setname(mem, <span class="string">"INIT"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize the end of the heap */</span></span><br><span class="line">    heap_end        = (struct heap_mem *)&amp;heap_ptr[mem-&gt;next];</span><br><span class="line">    heap_end-&gt;magic = HEAP_MAGIC;</span><br><span class="line">    heap_end-&gt;used  = <span class="number">1</span>;</span><br><span class="line">    heap_end-&gt;next  = mem_size_aligned + SIZEOF_STRUCT_MEM;</span><br><span class="line">    heap_end-&gt;prev  = mem_size_aligned + SIZEOF_STRUCT_MEM;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">    rt_mem_setname(heap_end, <span class="string">"INIT"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>接著設定結尾的 header<ul><li>magic 碼</li><li>已被使用過</li><li>上一塊與下一塊指向自己</li></ul></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line">    rt_sem_init(&amp;heap_sem, <span class="string">"heap"</span>, <span class="number">1</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize the lowest-free pointer to the start of the heap */</span></span><br><span class="line">    lfree = (struct heap_mem *)heap_ptr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最後初始化 semaphore</li><li>把這一塊掛上 <code>lfree</code></li></ul><hr><h2 id="分配記憶體"><a class="header-anchor" href="#分配記憶體">#</a>分配記憶體</h2><h3 id="Code-rt-malloc"><a class="header-anchor" href="#Code-rt-malloc">#</a>Code: rt_malloc</h3><table><thead><tr><th>功能</th><th>回傳值</th><th><code>size</code></th></tr></thead><tbody><tr><td>要求記憶體</td><td>記憶體位址</td><td>欲要求的大小</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocate a block of memory with a minimum of 'size' bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param size is the minimum size of the requested block in bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return pointer to allocated memory or NULL if no free memory was found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_malloc</span><span class="params">(<span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_size_t</span> ptr, ptr2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">mem</span>, *<span class="title">mem2</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 <code>size</code> 為 0，回傳 NULL</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size != RT_ALIGN(size, RT_ALIGN_SIZE))</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"malloc size %d, but align to %d\n"</span>,</span><br><span class="line">                                size, RT_ALIGN(size, RT_ALIGN_SIZE)));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"malloc size %d\n"</span>, size));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* alignment size */</span></span><br><span class="line">size = RT_ALIGN(size, RT_ALIGN_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &gt; mem_size_aligned)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"no memory\n"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>向上對齊 <code>size</code>，如果超過可用大小，回傳 NULL</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* every data block must be at least MIN_SIZE_ALIGNED long */</span></span><br><span class="line"><span class="keyword">if</span> (size &lt; MIN_SIZE_ALIGNED)</span><br><span class="line">    size = MIN_SIZE_ALIGNED;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果小於 min size，設為 min size</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* take memory semaphore */</span></span><br><span class="line">rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br></pre></td></tr></tbody></table></figure><ul><li>取得 semaphore</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ptr = (<span class="keyword">rt_uint8_t</span> *)lfree - heap_ptr;</span><br><span class="line">     ptr &lt; mem_size_aligned - size;</span><br><span class="line">     ptr = ((struct heap_mem *)&amp;heap_ptr[ptr])-&gt;next)</span><br><span class="line">{</span><br><span class="line">    mem = (struct heap_mem *)&amp;heap_ptr[ptr];</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-info"><p>這裡特別的說明一下 for 迴圈：<br>首先起點是 <code>lfree</code> - <code>heap_ptr</code>，這裡代表最左邊的 free block 與 heap 起點的距離。 我們把 <code>heap_ptr</code> 看成是一個 <code>rt_uint8_t</code> 的陣列，也就是一格一個 byte 的陣列。 再來把 <code>lfree</code> - <code>heap_ptr</code> 看成是差量 (offset)，單位是 byte。 如此一來，<code>&amp;heap_ptr[ptr]</code> 就會是 <code>lfree</code> 的起始位置了。</p><p>再來我們看 <code>next</code>，在初始化的時候，<code>next</code> 是指向 0，這個意思是下一顆在陣列的第 0 個，也就是自己；所以 <code>next</code> 存放的是下一顆的 index，而不是起始位置。</p><p>最後來看上界，理論上我們需要從 lfree 找到最後一顆，實際上如果最後幾顆不夠大的話是不需要檢查的，所以這裡上界設在 <code>mem_size_aligned</code> - <code>size</code> 的意思就是說如果最後幾顆的大小總和不夠大，我們可以略過。</p></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((!mem-&gt;used) &amp;&amp; (mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM)) &gt;= size)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* mem is not used and at least perfect fit is possible:</span></span><br><span class="line"><span class="comment">     * mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */</span></span><br></pre></td></tr></tbody></table></figure><ul><li>first fit，如果找到第一顆可用的就進去</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM) &gt;=</span><br><span class="line">    (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))</span><br><span class="line">{</span><br></pre></td></tr></tbody></table></figure><ul><li>又，如果這顆夠大到可以切割的話</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br></pre></td><td class="code"><pre><span class="line">                <span class="comment">/* (in addition to the above, we test if another struct heap_mem (SIZEOF_STRUCT_MEM) containing</span></span><br><span class="line"><span class="comment">                 * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')</span></span><br><span class="line"><span class="comment">                 * -&gt; split large block, create empty remainder,</span></span><br><span class="line"><span class="comment">                 * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if</span></span><br><span class="line"><span class="comment">                 * mem-&gt;next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,</span></span><br><span class="line"><span class="comment">                 * struct heap_mem would fit in but no data between mem2 and mem2-&gt;next</span></span><br><span class="line"><span class="comment">                 * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty</span></span><br><span class="line"><span class="comment">                 *       region that couldn't hold data, but when mem-&gt;next gets freed,</span></span><br><span class="line"><span class="comment">                 *       the 2 regions would be combined, resulting in more free memory</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                ptr2 = ptr + SIZEOF_STRUCT_MEM + size;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* create mem2 struct */</span></span><br><span class="line">                mem2       = (struct heap_mem *)&amp;heap_ptr[ptr2];</span><br><span class="line">                mem2-&gt;magic = HEAP_MAGIC;</span><br><span class="line">                mem2-&gt;used = <span class="number">0</span>;</span><br><span class="line">                mem2-&gt;next = mem-&gt;next;</span><br><span class="line">                mem2-&gt;prev = ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">                rt_mem_setname(mem2, <span class="string">"    "</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>設定下一顆的資料，同時把 <code>next</code> 與 <code>prev</code> 接到正確位置</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* and insert it between mem and mem-&gt;next */</span></span><br><span class="line">mem-&gt;next = ptr2;</span><br><span class="line">mem-&gt;used = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mem2-&gt;next != mem_size_aligned + SIZEOF_STRUCT_MEM)</span><br><span class="line">{</span><br><span class="line">    ((struct heap_mem *)&amp;heap_ptr[mem2-&gt;next])-&gt;prev = ptr2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著把原本那塊的 <code>next</code> 指向新的那塊，設為使用中</li><li>如果新的那塊 <code>next</code> 不是最後一塊，設定 <code>prev</code></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">                used_mem += (size + SIZEOF_STRUCT_MEM);</span><br><span class="line">                <span class="keyword">if</span> (max_mem &lt; used_mem)</span><br><span class="line">                    max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            }</span><br></pre></td></tr></tbody></table></figure><ul><li>最後更新 <code>used_mem</code> 與 <code>max_mem</code></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="comment">/* (a mem2 struct does no fit into the user data space of mem and mem-&gt;next will always</span></span><br><span class="line"><span class="comment">                 * be used at this point: if not we have 2 unused structs in a row, plug_holes should have</span></span><br><span class="line"><span class="comment">                 * take care of this).</span></span><br><span class="line"><span class="comment">                 * -&gt; near fit or excact fit: do not split, no mem2 creation</span></span><br><span class="line"><span class="comment">                 * also can't move mem-&gt;next directly behind mem, since mem-&gt;next</span></span><br><span class="line"><span class="comment">                 * will always be used at this point!</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                mem-&gt;used = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">                used_mem += mem-&gt;next - ((<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr);</span><br><span class="line">                <span class="keyword">if</span> (max_mem &lt; used_mem)</span><br><span class="line">                    max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果不可切割，只需設定使用中即可</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">/* set memory block magic */</span></span><br><span class="line">            mem-&gt;magic = HEAP_MAGIC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">            <span class="keyword">if</span> (rt_thread_self())</span><br><span class="line">                rt_mem_setname(mem, rt_thread_self()-&gt;name);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rt_mem_setname(mem, <span class="string">"NONE"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mem == lfree)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">/* Find next free block after mem and update lowest free pointer */</span></span><br><span class="line">                <span class="keyword">while</span> (lfree-&gt;used &amp;&amp; lfree != heap_end)</span><br><span class="line">                    lfree = (struct heap_mem *)&amp;heap_ptr[lfree-&gt;next];</span><br><span class="line"></span><br><span class="line">                RT_ASSERT(((lfree == heap_end) || (!lfree-&gt;used)));</span><br><span class="line">            }</span><br></pre></td></tr></tbody></table></figure><ul><li>視情況更新 <code>lfree</code></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br></pre></td><td class="code"><pre><span class="line">        rt_sem_release(&amp;heap_sem);</span><br><span class="line">        RT_ASSERT((<span class="keyword">rt_uint32_t</span>)mem + SIZEOF_STRUCT_MEM + size &lt;= (<span class="keyword">rt_uint32_t</span>)heap_end);</span><br><span class="line">        RT_ASSERT((<span class="keyword">rt_uint32_t</span>)((<span class="keyword">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM) % RT_ALIGN_SIZE == <span class="number">0</span>);</span><br><span class="line">        RT_ASSERT((((<span class="keyword">rt_uint32_t</span>)mem) &amp; (RT_ALIGN_SIZE - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_MEM,</span><br><span class="line">                     (<span class="string">"allocate memory at 0x%x, size: %d\n"</span>,</span><br><span class="line">                      (<span class="keyword">rt_uint32_t</span>)((<span class="keyword">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM),</span><br><span class="line">                      (<span class="keyword">rt_uint32_t</span>)(mem-&gt;next - ((<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr))));</span><br><span class="line"></span><br><span class="line">        RT_OBJECT_HOOK_CALL(rt_malloc_hook,</span><br><span class="line">                            (((<span class="keyword">void</span> *)((<span class="keyword">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM)), size));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* return the memory data except mem struct */</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>還鎖，並回傳找到的記憶體位址</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br></pre></td><td class="code"><pre><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_malloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>沒找到一樣還鎖，並回傳 NULL</li></ul><hr><h3 id="Code-rt-realloc"><a class="header-anchor" href="#Code-rt-realloc">#</a>Code: rt_realloc</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>增長/縮減記憶體</td><td>記憶體位址</td></tr></tbody></table><table><thead><tr><th><code>*rmeme</code></th><th><code>newsize</code></th></tr></thead><tbody><tr><td>欲增長/縮減的記憶體位址</td><td>新的大小</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will change the previously allocated memory block.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rmem pointer to memory allocated by rt_malloc</span></span><br><span class="line"><span class="comment"> * @param newsize the required new size</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the changed memory block address</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_realloc</span><span class="params">(<span class="keyword">void</span> *rmem, <span class="keyword">rt_size_t</span> newsize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_size_t</span> size;</span><br><span class="line">    <span class="keyword">rt_size_t</span> ptr, ptr2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">mem</span>, *<span class="title">mem2</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *nmem;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* alignment size */</span></span><br><span class="line">    newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (newsize &gt; mem_size_aligned)</span><br><span class="line">    {</span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"realloc: out of memory\n"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (newsize == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_free(rmem);</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>向上對齊 size，如果：<ul><li>大於可用大小，回傳 NULL</li><li>等於 0，free 記憶體，回傳 NULL</li></ul></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* allocate a new memory block */</span></span><br><span class="line"><span class="keyword">if</span> (rmem == RT_NULL)</span><br><span class="line">    <span class="keyword">return</span> rt_malloc(newsize);</span><br></pre></td></tr></tbody></table></figure><ul><li>如原來的記憶體為空，直接 <code>malloc</code>，並回傳</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br></pre></td><td class="code"><pre><span class="line">rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">rt_uint8_t</span> *)rmem &lt; (<span class="keyword">rt_uint8_t</span> *)heap_ptr ||</span><br><span class="line">    (<span class="keyword">rt_uint8_t</span> *)rmem &gt;= (<span class="keyword">rt_uint8_t</span> *)heap_end)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* illegal memory */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rmem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著取得鎖，檢查傳入的記憶體是否合法</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br></pre></td><td class="code"><pre><span class="line">mem = (struct heap_mem *)((<span class="keyword">rt_uint8_t</span> *)rmem - SIZEOF_STRUCT_MEM);</span><br><span class="line"></span><br><span class="line">ptr = (<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr;</span><br><span class="line">size = mem-&gt;next - ptr - SIZEOF_STRUCT_MEM;</span><br><span class="line"><span class="keyword">if</span> (size == newsize)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* the size is the same as */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rmem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>找到記憶體塊的起始位址，算出 size，如果記憶體大小不需要變動，不做事，回傳原本的記憶體位址</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE &lt; size)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* split memory block */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem -= (size - newsize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;</span><br><span class="line">        mem2 = (struct heap_mem *)&amp;heap_ptr[ptr2];</span><br><span class="line">        mem2-&gt;magic = HEAP_MAGIC;</span><br><span class="line">        mem2-&gt;used = <span class="number">0</span>;</span><br><span class="line">        mem2-&gt;next = mem-&gt;next;</span><br><span class="line">        mem2-&gt;prev = ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">        rt_mem_setname(mem2, <span class="string">"    "</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        mem-&gt;next = ptr2;</span><br><span class="line">        <span class="keyword">if</span> (mem2-&gt;next != mem_size_aligned + SIZEOF_STRUCT_MEM)</span><br><span class="line">        {</span><br><span class="line">            ((struct heap_mem *)&amp;heap_ptr[mem2-&gt;next])-&gt;prev = ptr2;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果可以切割，與上面的動作相同</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br></pre></td><td class="code"><pre><span class="line">    plug_holes(mem2);</span><br><span class="line"></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rmem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>使用 <code>plug_holes</code> 來合併 free block</li><li>還鎖，回傳更新後的記憶體位置</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br></pre></td><td class="code"><pre><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* expand memory */</span></span><br><span class="line">    nmem = rt_malloc(newsize);</span><br><span class="line">    <span class="keyword">if</span> (nmem != RT_NULL) <span class="comment">/* check memory */</span></span><br><span class="line">    {</span><br><span class="line">        rt_memcpy(nmem, rmem, size &lt; newsize ? size : newsize);</span><br><span class="line">        rt_free(rmem);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nmem;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_realloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果不可切割，或是需要增長，直接要一塊 new size，釋放原本的記憶體</li><li>最後回傳新的記憶體位址</li></ul><hr><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*mem</code></th></tr></thead><tbody><tr><td>合併 free block</td><td>void</td><td>欲合併的記憶體位址</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">plug_holes</span><span class="params">(struct heap_mem *mem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">nmem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">pmem</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT((<span class="keyword">rt_uint8_t</span> *)mem &gt;= heap_ptr);</span><br><span class="line">    RT_ASSERT((<span class="keyword">rt_uint8_t</span> *)mem &lt; (<span class="keyword">rt_uint8_t</span> *)heap_end);</span><br><span class="line">    RT_ASSERT(mem-&gt;used == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* plug hole forward */</span></span><br><span class="line">    nmem = (struct heap_mem *)&amp;heap_ptr[mem-&gt;next];</span><br><span class="line">    <span class="keyword">if</span> (mem != nmem &amp;&amp;</span><br><span class="line">        nmem-&gt;used == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (<span class="keyword">rt_uint8_t</span> *)nmem != (<span class="keyword">rt_uint8_t</span> *)heap_end)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* if mem-&gt;next is unused and not end of heap_ptr,</span></span><br><span class="line"><span class="comment">         * combine mem and mem-&gt;next</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (lfree == nmem)</span><br><span class="line">        {</span><br><span class="line">            lfree = mem;</span><br><span class="line">        }</span><br><span class="line">        mem-&gt;next = nmem-&gt;next;</span><br><span class="line">        ((struct heap_mem *)&amp;heap_ptr[nmem-&gt;next])-&gt;prev = (<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果可以與下一顆合併</li><li>檢查是否需要更新 <code>lfree</code></li><li>重新接上 <code>next</code> 與 <code>prev</code> (<code>next</code> 的 <code>prev</code>)</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* plug hole backward */</span></span><br><span class="line">    pmem = (struct heap_mem *)&amp;heap_ptr[mem-&gt;prev];</span><br><span class="line">    <span class="keyword">if</span> (pmem != mem &amp;&amp; pmem-&gt;used == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* if mem-&gt;prev is unused, combine mem and mem-&gt;prev */</span></span><br><span class="line">        <span class="keyword">if</span> (lfree == mem)</span><br><span class="line">        {</span><br><span class="line">            lfree = pmem;</span><br><span class="line">        }</span><br><span class="line">        pmem-&gt;next = mem-&gt;next;</span><br><span class="line">        ((struct heap_mem *)&amp;heap_ptr[mem-&gt;next])-&gt;prev = (<span class="keyword">rt_uint8_t</span> *)pmem - heap_ptr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果可以與上一顆合併，動作一樣</li></ul><hr><h3 id="Code-rt-calloc"><a class="header-anchor" href="#Code-rt-calloc">#</a>Code: rt_calloc</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>要求一段連續的記憶體</td><td>記憶體位址</td></tr></tbody></table><table><thead><tr><th><code>count</code></th><th><code>size</code></th></tr></thead><tbody><tr><td>欲要求的數量</td><td>一塊的大小</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will contiguously allocate enough space for count objects</span></span><br><span class="line"><span class="comment"> * that are size bytes of memory each and returns a pointer to the allocated</span></span><br><span class="line"><span class="comment"> * memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The allocated memory is filled with bytes of value zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param count number of objects to allocate</span></span><br><span class="line"><span class="comment"> * @param size size of the objects to allocate</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return pointer to allocated memory / NULL pointer if there is an error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_calloc</span><span class="params">(<span class="keyword">rt_size_t</span> count, <span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate 'count' objects of size 'size' */</span></span><br><span class="line">    p = rt_malloc(count * size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zero the memory */</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        rt_memset(p, <span class="number">0</span>, count * size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_calloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>與 memheap 相同，一次要一塊 count 乘 size 的記憶體</li><li>清 0 並回傳起始位址</li></ul><hr><h2 id="釋放記憶體"><a class="header-anchor" href="#釋放記憶體">#</a>釋放記憶體</h2><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*rmem</code></th></tr></thead><tbody><tr><td>釋放記憶體</td><td>void</td><td>欲釋放的記憶體</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will release the previously allocated memory block by</span></span><br><span class="line"><span class="comment"> * rt_malloc. The released memory block is taken back to system heap.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rmem the address of memory which will be released</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_free</span><span class="params">(<span class="keyword">void</span> *rmem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">mem</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rmem == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果需要釋放得記憶體為空，不做事</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">RT_ASSERT((((<span class="keyword">rt_uint32_t</span>)rmem) &amp; (RT_ALIGN_SIZE - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">RT_ASSERT((<span class="keyword">rt_uint8_t</span> *)rmem &gt;= (<span class="keyword">rt_uint8_t</span> *)heap_ptr &amp;&amp;</span><br><span class="line">          (<span class="keyword">rt_uint8_t</span> *)rmem &lt; (<span class="keyword">rt_uint8_t</span> *)heap_end);</span><br><span class="line"></span><br><span class="line">RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">rt_uint8_t</span> *)rmem &lt; (<span class="keyword">rt_uint8_t</span> *)heap_ptr ||</span><br><span class="line">    (<span class="keyword">rt_uint8_t</span> *)rmem &gt;= (<span class="keyword">rt_uint8_t</span> *)heap_end)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"illegal memory\n"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the corresponding struct heap_mem ... */</span></span><br><span class="line">mem = (struct heap_mem *)((<span class="keyword">rt_uint8_t</span> *)rmem - SIZEOF_STRUCT_MEM);</span><br></pre></td></tr></tbody></table></figure><ul><li>檢查記憶體位址是否合法，並找到真正的記憶體區塊位址</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEM,</span><br><span class="line">             (<span class="string">"release memory 0x%x, size: %d\n"</span>,</span><br><span class="line">              (<span class="keyword">rt_uint32_t</span>)rmem,</span><br><span class="line">              (<span class="keyword">rt_uint32_t</span>)(mem-&gt;next - ((<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr))));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* protect the heap from concurrent access */</span></span><br><span class="line">rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... which has to be in a used state ... */</span></span><br><span class="line"><span class="keyword">if</span> (!mem-&gt;used || mem-&gt;magic != HEAP_MAGIC)</span><br><span class="line">{</span><br><span class="line">    rt_kprintf(<span class="string">"to free a bad data block:\n"</span>);</span><br><span class="line">    rt_kprintf(<span class="string">"mem: 0x%08x, used flag: %d, magic code: 0x%04x\n"</span>, mem, mem-&gt;used, mem-&gt;magic);</span><br><span class="line">}</span><br><span class="line">RT_ASSERT(mem-&gt;used);</span><br><span class="line">RT_ASSERT(mem-&gt;magic == HEAP_MAGIC);</span><br></pre></td></tr></tbody></table></figure><ul><li>要鎖，檢查是否是使用中的區塊，及是否屬於 heap</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* ... and is now unused. */</span></span><br><span class="line">    mem-&gt;used  = <span class="number">0</span>;</span><br><span class="line">    mem-&gt;magic = HEAP_MAGIC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">    rt_mem_setname(mem, <span class="string">"    "</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem &lt; lfree)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* the newly freed struct is now the lowest */</span></span><br><span class="line">        lfree = mem;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>接著設為可使用，及更新 <code>lfree</code></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">    used_mem -= (mem-&gt;next - ((<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* finally, see if prev or next are free also */</span></span><br><span class="line">    plug_holes(mem);</span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_free);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後合併記憶體塊，並還鎖</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;使用此管理方式： &lt;code&gt;#defined R
      
    
    </summary>
    
    
      <category term="RT-Thread" scheme="https://blog.lusw.dev/categories/RT-Thread/"/>
    
    
      <category term="kernel" scheme="https://blog.lusw.dev/tags/kernel/"/>
    
      <category term="RT-Thread" scheme="https://blog.lusw.dev/tags/RT-Thread/"/>
    
      <category term="記憶體管理" scheme="https://blog.lusw.dev/tags/MemMan/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread Memory Heap</title>
    <link href="https://blog.lusw.dev/rt-memheap.html"/>
    <id>https://blog.lusw.dev/rt-memheap.html</id>
    <published>2018-12-05T07:42:29.000Z</published>
    <updated>2020-04-23T05:02:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>使用此管理方式： <code>#define RT_USING_MEMHEAP_AS_HEAP</code></p></blockquote><ul><li>memheap 的管理方法（動態管理）:<ul><li>從 RAM 中要一塊記憶體</li><li>根據使用者需要的大小進行切割</li><li>剩下的以雙向鏈結的方式接起來，形成 free list</li></ul></li></ul><h2 id="結構"><a class="header-anchor" href="#結構">#</a>結構</h2><div class="alert alert-success"><p><strong>File:</strong> rtdef.h</p></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMHEAP</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * memory item on the heap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span>             magic;                      <span class="comment">/**&lt; magic number for memheap */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap</span>      *<span class="title">pool_ptr</span>;</span>                   <span class="comment">/**&lt; point of pool */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">next</span>;</span>                       <span class="comment">/**&lt; next memheap item */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">prev</span>;</span>                       <span class="comment">/**&lt; prev memheap item */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">next_free</span>;</span>                  <span class="comment">/**&lt; next free memheap item */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">prev_free</span>;</span>                  <span class="comment">/**&lt; prev free memheap item */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base structure of memory heap object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_object</span>        <span class="title">parent</span>;</span>                     <span class="comment">/**&lt; inherit from rt_object */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>                   *start_addr;                 <span class="comment">/**&lt; pool start address and size */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint32_t</span>             pool_size;                  <span class="comment">/**&lt; pool size */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span>             available_size;             <span class="comment">/**&lt; available size */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span>             max_used_size;              <span class="comment">/**&lt; maximum allocated size */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">block_list</span>;</span>                 <span class="comment">/**&lt; used block list */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">free_list</span>;</span>                  <span class="comment">/**&lt; free block list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span>  <span class="title">free_header</span>;</span>                <span class="comment">/**&lt; free block list header */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_semaphore</span>     <span class="title">lock</span>;</span>                       <span class="comment">/**&lt; semaphore lock */</span></span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>*start_addr</code> 指向可用的記憶體<br><br></li><li><code>pool_size</code> 代表總共可用的大小</li><li><code>available_size</code> 目前可用的大小</li><li><code>max_used_size</code> 已使用的歷史中，最大的使用大小<br><br></li><li><code>*block_list</code> 所有切割過的區塊（包含 header）<br><br></li><li><code>*free_list</code> 目前所有可用的區塊</li><li><code>*free_list</code> 的第一顆<br><br></li><li><code>lock</code> semaphore</li></ul><hr><div class="alert alert-success"><p><strong>File:</strong> memheap.c</p></div><h2 id="建立-memory-heap"><a class="header-anchor" href="#建立-memory-heap">#</a>建立 memory heap</h2><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立 memheap</td><td>void</td></tr></tbody></table><table><thead><tr><th><code>*begin_addr</code></th><th><code>*end_addr</code></th></tr></thead><tbody><tr><td>起始位址（欲分配的）</td><td>結束位址</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_system_heap_init</span><span class="params">(<span class="keyword">void</span> *begin_addr, <span class="keyword">void</span> *end_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* initialize a default heap in the system */</span></span><br><span class="line">    rt_memheap_init(&amp;_heap,</span><br><span class="line">                    <span class="string">"heap"</span>,</span><br><span class="line">                    begin_addr,</span><br><span class="line">                    (<span class="keyword">rt_uint32_t</span>)end_addr - (<span class="keyword">rt_uint32_t</span>)begin_addr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>將起始位置，大小，結構體傳入 <code>rt_memheap_init</code></li></ul><hr><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 memheap</td><td><code>RT_EOK</code></td></tr></tbody></table><table><thead><tr><th><code>*memheap</code></th><th><code>*name</code></th><th><code>*start_addr</code></th><th><code>size</code></th></tr></thead><tbody><tr><td>memheap 結構</td><td>名字</td><td>欲分配的記憶體起始位址</td><td>記憶體大小</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The initialized memory pool will be:</span></span><br><span class="line"><span class="comment"> * +-----------------------------------+--------------------------+</span></span><br><span class="line"><span class="comment"> * | whole freed memory block          | Used Memory Block Tailer |</span></span><br><span class="line"><span class="comment"> * +-----------------------------------+--------------------------+</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * block_list --&gt; whole freed memory block</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The length of Used Memory Block Tailer is 0,</span></span><br><span class="line"><span class="comment"> * which is prevents block merging across list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_memheap_init(struct rt_memheap *memheap,</span><br><span class="line">                         <span class="keyword">const</span> <span class="keyword">char</span>        *name,</span><br><span class="line">                         <span class="keyword">void</span>              *start_addr,</span><br><span class="line">                         <span class="keyword">rt_uint32_t</span>        size)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">item</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(memheap != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize pool object */</span></span><br><span class="line">    rt_object_init(&amp;(memheap-&gt;parent), RT_Object_Class_MemHeap, name);</span><br><span class="line"></span><br><span class="line">    memheap-&gt;start_addr     = start_addr;</span><br><span class="line">    memheap-&gt;pool_size      = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);</span><br><span class="line">    memheap-&gt;available_size = memheap-&gt;pool_size - (<span class="number">2</span> * RT_MEMHEAP_SIZE);</span><br><span class="line">    memheap-&gt;max_used_size  = memheap-&gt;pool_size - memheap-&gt;available_size;</span><br></pre></td></tr></tbody></table></figure><ul><li>首先填入 <code>start_addr</code></li><li>向下對齊 <code>size</code></li><li>設定可用大小為 <code>size</code> 減掉 2 個 header</li><li>設定最大已使用大小為目前已使用的大小（即 2 倍的 header）</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* initialize the free list header */</span></span><br><span class="line">item            = &amp;(memheap-&gt;free_header);</span><br><span class="line">item-&gt;magic     = RT_MEMHEAP_MAGIC;</span><br><span class="line">item-&gt;pool_ptr  = memheap;</span><br><span class="line">item-&gt;next      = RT_NULL;</span><br><span class="line">item-&gt;prev      = RT_NULL;</span><br><span class="line">item-&gt;next_free = item;</span><br><span class="line">item-&gt;prev_free = item;</span><br></pre></td></tr></tbody></table></figure><ul><li>先初始化 free list：<ul><li>讓 item 指向 free list 的 header</li><li>設定 magic 碼</li><li>將 <code>pool_ptr</code> 指向 memheap 結構</li><li><code>next</code>、<code>prev</code> 指向 <code>NULL</code></li><li><code>next_free</code>、<code>prev_free</code> 指向自己</li></ul></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set the free list to free list header */</span></span><br><span class="line">memheap-&gt;free_list = item;</span><br></pre></td></tr></tbody></table></figure><ul><li>給定 free list</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* initialize the first big memory block */</span></span><br><span class="line">item            = (struct rt_memheap_item *)start_addr;</span><br><span class="line">item-&gt;magic     = RT_MEMHEAP_MAGIC;</span><br><span class="line">item-&gt;pool_ptr  = memheap;</span><br><span class="line">item-&gt;next      = RT_NULL;</span><br><span class="line">item-&gt;prev      = RT_NULL;</span><br><span class="line">item-&gt;next_free = item;</span><br><span class="line">item-&gt;prev_free = item;</span><br></pre></td></tr></tbody></table></figure><ul><li>接著將整個 pool 設定為一個可用的 block<ul><li>讓 item 指向 起始位址</li><li>設定 magic 碼</li><li>將 <code>pool_ptr</code> 指向 memheap 結構</li><li><code>next</code>、<code>prev</code> 指向 <code>NULL</code></li><li><code>next_free</code>、<code>prev_free</code> 指向自己</li></ul></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">item-&gt;next = (struct rt_memheap_item *)</span><br><span class="line">             ((<span class="keyword">rt_uint8_t</span> *)item + memheap-&gt;available_size + RT_MEMHEAP_SIZE);</span><br><span class="line">item-&gt;prev = item-&gt;next;</span><br></pre></td></tr></tbody></table></figure><ul><li>讓 next 與 prev 指到結尾的 header</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* block list header */</span></span><br><span class="line">memheap-&gt;block_list = item;</span><br></pre></td></tr></tbody></table></figure><ul><li>給定 block_list</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* place the big memory block to free list */</span></span><br><span class="line">item-&gt;next_free = memheap-&gt;free_list-&gt;next_free;</span><br><span class="line">item-&gt;prev_free = memheap-&gt;free_list;</span><br><span class="line">memheap-&gt;free_list-&gt;next_free-&gt;prev_free = item;</span><br><span class="line">memheap-&gt;free_list-&gt;next_free            = item;</span><br></pre></td></tr></tbody></table></figure><ul><li>將 free list (item) 的 <code>next</code> 指向 <code>memheap-&gt;free_list-&gt;next_free</code>，也就是 free list</li><li><code>prev</code> 同上</li><li>將 free list (heap) 的 <code>next</code> 指向 <code>item</code></li><li><code>prev</code> 同上</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* move to the end of memory pool to build a small tailer block,</span></span><br><span class="line"><span class="comment"> * which prevents block merging</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">item = item-&gt;next;</span><br><span class="line"><span class="comment">/* it's a used memory block */</span></span><br><span class="line">item-&gt;magic     = RT_MEMHEAP_MAGIC | RT_MEMHEAP_USED;</span><br><span class="line">item-&gt;pool_ptr  = memheap;</span><br><span class="line">item-&gt;next      = (struct rt_memheap_item *)start_addr;</span><br><span class="line">item-&gt;prev      = (struct rt_memheap_item *)start_addr;</span><br><span class="line"><span class="comment">/* not in free list */</span></span><br><span class="line">item-&gt;next_free = item-&gt;prev_free = RT_NULL;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定尾巴的 header<ul><li>讓 item 指向 free list 的 header</li><li>設定 magic 碼為<strong>使用過</strong>的</li><li>將 <code>pool_ptr</code> 指向 memheap 結構</li><li><code>next</code>、<code>prev</code> 指向起始位置</li><li><code>next_free</code>、<code>prev_free</code> 指向 <code>NULL</code></li></ul></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* initialize semaphore lock */</span></span><br><span class="line">    rt_sem_init(&amp;(memheap-&gt;lock), name, <span class="number">1</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">                 (<span class="string">"memory heap: start addr 0x%08x, size %d, free list header 0x%08x\n"</span>,</span><br><span class="line">                  start_addr, size, &amp;(memheap-&gt;free_header)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_memheap_init);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後初始化 semaphore 並使用 FIFO</li></ul><hr><h2 id="刪除-memory-heap"><a class="header-anchor" href="#刪除-memory-heap">#</a>刪除 memory heap</h2><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*heap</code></th></tr></thead><tbody><tr><td>刪除 memheap</td><td><code>RT_EOK</code></td><td>欲刪除的 memheap</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_memheap_detach(struct rt_memheap *heap)</span><br><span class="line">{</span><br><span class="line">    RT_ASSERT(heap);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;heap-&gt;parent) == RT_Object_Class_MemHeap);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;heap-&gt;parent));</span><br><span class="line"></span><br><span class="line">    rt_object_detach(&amp;(heap-&gt;lock.parent.parent));</span><br><span class="line">    rt_object_detach(&amp;(heap-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return a successful completion. */</span></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_memheap_detach);</span><br></pre></td></tr></tbody></table></figure><ul><li>使用 <code>rt_object_detach</code> 刪除 semaphore 與 memheap</li></ul><hr><h2 id="分配記憶體"><a class="header-anchor" href="#分配記憶體">#</a>分配記憶體</h2><h3 id="Code-rt-malloc"><a class="header-anchor" href="#Code-rt-malloc">#</a>Code: rt_malloc</h3><table><thead><tr><th>功能</th><th>回傳值</th><th><code>size</code></th></tr></thead><tbody><tr><td>要求一塊記憶體</td><td>取得的記憶體</td><td>欲要求的大小</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_malloc</span><span class="params">(<span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to allocate in system heap */</span></span><br><span class="line">    ptr = rt_memheap_alloc(&amp;_heap, size);</span><br></pre></td></tr></tbody></table></figure><ul><li>首先嘗試從系統的 heap（<code>_heap</code>）要求記憶體（透過 <code>rt_memheap_alloc</code>）</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr == RT_NULL)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_object</span> *<span class="title">object</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_list_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap</span> *<span class="title">heap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_object_information</span> *<span class="title">information</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to allocate on other memory heap */</span></span><br><span class="line">    information = rt_object_get_information(RT_Object_Class_MemHeap);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果失敗，嘗試從其他的 heap 要求</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br></pre></td><td class="code"><pre><span class="line">RT_ASSERT(information != RT_NULL);</span><br><span class="line"><span class="keyword">for</span> (node  = information-&gt;object_list.next;</span><br><span class="line">     node != &amp;(information-&gt;object_list);</span><br><span class="line">     node  = node-&gt;next)</span><br><span class="line">{</span><br><span class="line">    object = rt_list_entry(node, struct rt_object, <span class="built_in">list</span>);</span><br><span class="line">    heap   = (struct rt_memheap *)object;</span><br><span class="line"></span><br><span class="line">    RT_ASSERT(heap);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;heap-&gt;parent) == RT_Object_Class_MemHeap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* not allocate in the default system heap */</span></span><br><span class="line">    <span class="keyword">if</span> (heap == &amp;_heap)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>跳過系統的 heap</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br></pre></td><td class="code"><pre><span class="line">            ptr = rt_memheap_alloc(heap, size);</span><br><span class="line">            <span class="keyword">if</span> (ptr != RT_NULL)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_malloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>一樣透過 <code>rt_memheap_alloc</code> 來完成</li><li>如果成功就跳出迴圈，最後回傳記憶體位址</li></ul><hr><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>要求一塊記憶體</td><td>取得的記憶體</td></tr></tbody></table><table><thead><tr><th><code>*heap</code></th><th><code>size</code></th></tr></thead><tbody><tr><td>目標 heap</td><td>欲要求的大小</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_memheap_alloc</span><span class="params">(struct rt_memheap *heap, <span class="keyword">rt_uint32_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_err_t</span> result;</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> free_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">header_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(heap != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;heap-&gt;parent) == RT_Object_Class_MemHeap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* align allocated size */</span></span><br><span class="line">    size = RT_ALIGN(size, RT_ALIGN_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (size &lt; RT_MEMHEAP_MINIALLOC)</span><br><span class="line">        size = RT_MEMHEAP_MINIALLOC;</span><br></pre></td></tr></tbody></table></figure><ul><li>首先向上對齊 <code>size</code></li><li>如果小於 <code>RT_MEMHEAP_MINIALLOC</code> (12)，設定為 <code>RT_MEMHEAP_MINIALLOC</code></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"allocate %d on heap:%8.*s"</span>,</span><br><span class="line">                                size, RT_NAME_MAX, heap-&gt;parent.name));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &lt; heap-&gt;available_size)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* search on free list */</span></span><br><span class="line">    free_size = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 heap 還夠使用，先將 <code>free_size</code> 設為 0</li><li><code>free_size</code> 代表我們目前找到的可用大小</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lock memheap */</span></span><br><span class="line">result = rt_sem_take(&amp;(heap-&gt;lock), RT_WAITING_FOREVER);</span><br><span class="line"><span class="keyword">if</span> (result != RT_EOK)</span><br><span class="line">{</span><br><span class="line">    rt_set_errno(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著試著索取 semaphore</li><li>如果失敗，設定錯誤碼並回傳 NULL</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get the first free memory block */</span></span><br><span class="line">header_ptr = heap-&gt;free_list-&gt;next_free;</span><br><span class="line"><span class="keyword">while</span> (header_ptr != heap-&gt;free_list &amp;&amp; free_size &lt; size)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* get current freed memory block size */</span></span><br><span class="line">    free_size = MEMITEM_SIZE(header_ptr);</span><br><span class="line">    <span class="keyword">if</span> (free_size &lt; size)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* move to next free memory block */</span></span><br><span class="line">        header_ptr = header_ptr-&gt;next_free;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著從 free list 上一個一個找</li><li>使用 <em>first fit</em>，找到一個大魚的就退出迴圈</li><li><code>MEMITEM_SIZE(item)</code>：<code>((rt_uint32_t)item-&gt;next - (rt_uint32_t)item - RT_MEMHEAP_SIZE)</code></li><li>利用下一顆的位址減掉自己的位址取的總體大小，再減掉 header 的大小</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* determine if the memory is available. */</span></span><br><span class="line"><span class="keyword">if</span> (free_size &gt;= size)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* a block that satisfies the request has been found. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* determine if the block needs to be split. */</span></span><br><span class="line">    <span class="keyword">if</span> (free_size &gt;= (size + RT_MEMHEAP_SIZE + RT_MEMHEAP_MINIALLOC))</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">new_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* split the block. */</span></span><br><span class="line">        new_ptr = (struct rt_memheap_item *)</span><br><span class="line">                  (((<span class="keyword">rt_uint8_t</span> *)header_ptr) + size + RT_MEMHEAP_SIZE);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果有成功找到（不是因為走完迴圈才往下）</li><li>且這塊大到可以再切一塊，切割這塊：<ul><li>從找到的那塊開始往後一個 <code>size</code> 與一個 <code>RT_MEMHEAP_SIZE</code> 作為新的 header</li></ul></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">             (<span class="string">"split: block[0x%08x] nextm[0x%08x] prevm[0x%08x] to new[0x%08x]\n"</span>,</span><br><span class="line">              header_ptr,</span><br><span class="line">              header_ptr-&gt;next,</span><br><span class="line">              header_ptr-&gt;prev,</span><br><span class="line">              new_ptr));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* mark the new block as a memory block and freed. */</span></span><br><span class="line">new_ptr-&gt;magic = RT_MEMHEAP_MAGIC;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* put the pool pointer into the new block. */</span></span><br><span class="line">new_ptr-&gt;pool_ptr = heap;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定 magic 碼</li><li>設定所屬 heap</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* break down the block list */</span></span><br><span class="line">new_ptr-&gt;prev          = header_ptr;</span><br><span class="line">new_ptr-&gt;next          = header_ptr-&gt;next;</span><br><span class="line">header_ptr-&gt;next-&gt;prev = new_ptr;</span><br><span class="line">header_ptr-&gt;next       = new_ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>將此 block 插入 <code>block_list</code></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove header ptr from free list */</span></span><br><span class="line">header_ptr-&gt;next_free-&gt;prev_free = header_ptr-&gt;prev_free;</span><br><span class="line">header_ptr-&gt;prev_free-&gt;next_free = header_ptr-&gt;next_free;</span><br><span class="line">header_ptr-&gt;next_free = RT_NULL;</span><br><span class="line">header_ptr-&gt;prev_free = RT_NULL;</span><br></pre></td></tr></tbody></table></figure><ul><li>從 free list 中移除找到的 block</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* insert new_ptr to free list */</span></span><br><span class="line">new_ptr-&gt;next_free = heap-&gt;free_list-&gt;next_free;</span><br><span class="line">new_ptr-&gt;prev_free = heap-&gt;free_list;</span><br><span class="line">heap-&gt;free_list-&gt;next_free-&gt;prev_free = new_ptr;</span><br><span class="line">heap-&gt;free_list-&gt;next_free            = new_ptr;</span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"new ptr: next_free 0x%08x, prev_free 0x%08x\n"</span>,</span><br><span class="line">                                new_ptr-&gt;next_free,</span><br><span class="line">                                new_ptr-&gt;prev_free));</span><br></pre></td></tr></tbody></table></figure><ul><li>將分割好的 block 插入 free list</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* decrement the available byte count.  */</span></span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size -</span><br><span class="line">                           size -</span><br><span class="line">                           RT_MEMHEAP_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;pool_size - heap-&gt;available_size &gt; heap-&gt;max_used_size)</span><br><span class="line">        heap-&gt;max_used_size = heap-&gt;pool_size - heap-&gt;available_size;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>更新 <code>available_size</code> 與 <code>max_used_size</code> (如果需要)</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* decrement the entire free size from the available bytes count. */</span></span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size - free_size;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;pool_size - heap-&gt;available_size &gt; heap-&gt;max_used_size)</span><br><span class="line">        heap-&gt;max_used_size = heap-&gt;pool_size - heap-&gt;available_size;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果不能切割，一樣更新 <code>available_size</code> 與 <code>max_used_size</code> (如果需要)</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* remove header_ptr from free list */</span></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">                 (<span class="string">"one block: block[0x%08x], next_free 0x%08x, prev_free 0x%08x\n"</span>,</span><br><span class="line">                  header_ptr,</span><br><span class="line">                  header_ptr-&gt;next_free,</span><br><span class="line">                  header_ptr-&gt;prev_free));</span><br><span class="line"></span><br><span class="line">    header_ptr-&gt;next_free-&gt;prev_free = header_ptr-&gt;prev_free;</span><br><span class="line">    header_ptr-&gt;prev_free-&gt;next_free = header_ptr-&gt;next_free;</span><br><span class="line">    header_ptr-&gt;next_free = RT_NULL;</span><br><span class="line">    header_ptr-&gt;prev_free = RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>從 free list 中移除找到的 block</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Mark the allocated block as not available. */</span></span><br><span class="line">header_ptr-&gt;magic |= RT_MEMHEAP_USED;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* release lock */</span></span><br><span class="line">rt_sem_release(&amp;(heap-&gt;lock));</span><br></pre></td></tr></tbody></table></figure><ul><li>標記為使用中，釋放 semaphore</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Return a memory address to the caller.  */</span></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">                 (<span class="string">"alloc mem: memory[0x%08x], heap[0x%08x], size: %d\n"</span>,</span><br><span class="line">                  (<span class="keyword">void</span> *)((<span class="keyword">rt_uint8_t</span> *)header_ptr + RT_MEMHEAP_SIZE),</span><br><span class="line">                  header_ptr,</span><br><span class="line">                  size));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)((<span class="keyword">rt_uint8_t</span> *)header_ptr + RT_MEMHEAP_SIZE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最後回傳 block 記憶體位址 + header</li><li>即回傳可用的區塊</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* release lock */</span></span><br><span class="line">        rt_sem_release(&amp;(heap-&gt;lock));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"allocate memory: failed\n"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return the completion status.  */</span></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_memheap_alloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果找失敗，一樣釋放 semaphore</li><li>不論是找失敗，或是記憶體不足，皆回傳 NULL</li></ul><hr><h3 id="Code-rt-realloc"><a class="header-anchor" href="#Code-rt-realloc">#</a>Code: rt_realloc</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>重新要求記憶體（增長或縮減）</td><td>新分配完的記憶體塊</td></tr></tbody></table><table><thead><tr><th><code>*rmem</code></th><th><code>newsize</code></th></tr></thead><tbody><tr><td>欲重新分配的記憶體</td><td>新的大小</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_realloc</span><span class="params">(<span class="keyword">void</span> *rmem, <span class="keyword">rt_size_t</span> newsize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *new_ptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">header_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rmem == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> rt_malloc(newsize);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果傳入的記憶體位置為空，直接 <code>rt_malloc(newsize)</code> 並回傳</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newsize == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    rt_free(rmem);</span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 <code>newsize</code> 為 0，free 傳入的記憶體位置，回傳 NULL</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get old memory item */</span></span><br><span class="line">header_ptr = (struct rt_memheap_item *)</span><br><span class="line">             ((<span class="keyword">rt_uint8_t</span> *)rmem - RT_MEMHEAP_SIZE);</span><br></pre></td></tr></tbody></table></figure><ul><li>取得傳入的記憶體塊所屬的 header</li><li>malloc 時回傳的是可使用的起始位址，並不會包含 header，因此這裡減掉一個 header 的大小</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">671</span><br></pre></td><td class="code"><pre><span class="line">new_ptr = rt_memheap_realloc(header_ptr-&gt;pool_ptr, rmem, newsize);</span><br></pre></td></tr></tbody></table></figure><ul><li>透過 <code>rt_memheap_realloc</code> 來完成</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (new_ptr == RT_NULL &amp;&amp; newsize != <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* allocate memory block from other memheap */</span></span><br><span class="line">    new_ptr = rt_malloc(newsize);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果無法在原本的 heap 完成增長（或縮減），直接從別的 heap 要一塊 <code>newsize</code> 大的記憶體</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (new_ptr != RT_NULL &amp;&amp; rmem != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">rt_size_t</span> oldsize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get the size of old memory block */</span></span><br><span class="line">        oldsize = MEMITEM_SIZE(header_ptr);</span><br><span class="line">        <span class="keyword">if</span> (newsize &gt; oldsize)</span><br><span class="line">            rt_memcpy(new_ptr, rmem, oldsize);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rt_memcpy(new_ptr, rmem, newsize);</span><br><span class="line"></span><br><span class="line">        rt_free(rmem);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果最後有要成功，復原原本的資料</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> new_ptr;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_realloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後回傳新的記憶體位址</li></ul><hr><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>重新要求記憶體（增長或縮減）</td><td>新分配完的記憶體塊</td></tr></tbody></table><table><thead><tr><th><code>heap</code></th><th><code>*ptr</code></th><th><code>newsize</code></th></tr></thead><tbody><tr><td>目標 heap</td><td>欲重新分配的記憶體</td><td>新的大小</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_memheap_realloc</span><span class="params">(struct rt_memheap *heap, <span class="keyword">void</span> *ptr, <span class="keyword">rt_size_t</span> newsize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_err_t</span> result;</span><br><span class="line">    <span class="keyword">rt_size_t</span> oldsize;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">header_ptr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">new_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(heap);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;heap-&gt;parent) == RT_Object_Class_MemHeap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newsize == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_memheap_free(ptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 <code>newsize</code> 為 0，free 並回傳 NULL</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* align allocated size */</span></span><br><span class="line">newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);</span><br><span class="line"><span class="keyword">if</span> (newsize &lt; RT_MEMHEAP_MINIALLOC)</span><br><span class="line">    newsize = RT_MEMHEAP_MINIALLOC;</span><br></pre></td></tr></tbody></table></figure><ul><li>向上對齊 <code>newsize</code></li><li>如果小於 <code>RT_MEMHEAP_MINIALLOC</code> (12)，設定為 <code>RT_MEMHEAP_MINIALLOC</code></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr == RT_NULL)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> rt_memheap_alloc(heap, newsize);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果傳入的記憶體位置為空，直接 malloc newsize 的大小並回傳</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get memory block header and get the size of memory block */</span></span><br><span class="line">header_ptr = (struct rt_memheap_item *)</span><br><span class="line">             ((<span class="keyword">rt_uint8_t</span> *)ptr - RT_MEMHEAP_SIZE);</span><br><span class="line">oldsize = MEMITEM_SIZE(header_ptr);</span><br></pre></td></tr></tbody></table></figure><ul><li>取得傳入的 block 所屬的 header</li><li>一併計算這塊的大小</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* re-allocate memory */</span></span><br><span class="line"><span class="keyword">if</span> (newsize &gt; oldsize)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">void</span> *new_ptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">next_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lock memheap */</span></span><br><span class="line">    result = rt_sem_take(&amp;(heap-&gt;lock), RT_WAITING_FOREVER);</span><br><span class="line">    <span class="keyword">if</span> (result != RT_EOK)</span><br><span class="line">    {</span><br><span class="line">        rt_set_errno(result);</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果需要增長記憶體，先取得 semaphore</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br></pre></td><td class="code"><pre><span class="line">next_ptr = header_ptr-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* header_ptr should not be the tail */</span></span><br><span class="line">RT_ASSERT(next_ptr &gt; header_ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* check whether the following free space is enough to expand */</span></span><br><span class="line"><span class="keyword">if</span> (!RT_MEMHEAP_IS_USED(next_ptr))</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_int32_t</span> nextsize;</span><br><span class="line"></span><br><span class="line">    nextsize = MEMITEM_SIZE(next_ptr);</span><br><span class="line">    RT_ASSERT(next_ptr &gt; <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>先判斷下一顆可不可用</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Here is the ASCII art of the situation that we can make use of</span></span><br><span class="line"><span class="comment"> * the next free node without alloc/memcpy, |*| is the control</span></span><br><span class="line"><span class="comment"> * block:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      oldsize           free node</span></span><br><span class="line"><span class="comment"> * |*|-----------|*|----------------------|*|</span></span><br><span class="line"><span class="comment"> *         newsize          &gt;= minialloc</span></span><br><span class="line"><span class="comment"> * |*|----------------|*|-----------------|*|</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nextsize + oldsize &gt; newsize + RT_MEMHEAP_MINIALLOC)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* decrement the entire free size from the available bytes count. */</span></span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size - (newsize - oldsize);</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;pool_size - heap-&gt;available_size &gt; heap-&gt;max_used_size)</span><br><span class="line">        heap-&gt;max_used_size = heap-&gt;pool_size - heap-&gt;available_size;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果可用，而且下一顆足夠分割出一塊新的 block</li><li>更新 <code>available_size</code> 與 <code>max_used_size</code> (如果需要)</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove next_ptr from free list */</span></span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">             (<span class="string">"remove block: block[0x%08x], next_free 0x%08x, prev_free 0x%08x"</span>,</span><br><span class="line">              next_ptr,</span><br><span class="line">              next_ptr-&gt;next_free,</span><br><span class="line">              next_ptr-&gt;prev_free));</span><br><span class="line"></span><br><span class="line">next_ptr-&gt;next_free-&gt;prev_free = next_ptr-&gt;prev_free;</span><br><span class="line">next_ptr-&gt;prev_free-&gt;next_free = next_ptr-&gt;next_free;</span><br><span class="line">next_ptr-&gt;next-&gt;prev = next_ptr-&gt;prev;</span><br><span class="line">next_ptr-&gt;prev-&gt;next = next_ptr-&gt;next;</span><br></pre></td></tr></tbody></table></figure><ul><li>從 free list 移除舊的下一顆</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">363</span><br><span class="line">364</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* build a new one on the right place */</span></span><br><span class="line">next_ptr = (struct rt_memheap_item *)((<span class="keyword">char</span> *)ptr + newsize);</span><br></pre></td></tr></tbody></table></figure><ul><li>重新定指新的下一顆（傳入的起始位址加上 <code>newsize</code>）</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">             (<span class="string">"new free block: block[0x%08x] nextm[0x%08x] prevm[0x%08x]"</span>,</span><br><span class="line">              next_ptr,</span><br><span class="line">              next_ptr-&gt;next,</span><br><span class="line">              next_ptr-&gt;prev));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* mark the new block as a memory block and freed. */</span></span><br><span class="line">next_ptr-&gt;magic = RT_MEMHEAP_MAGIC;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* put the pool pointer into the new block. */</span></span><br><span class="line">next_ptr-&gt;pool_ptr = heap;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定 magic 碼</li><li>設定所屬 heap</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br></pre></td><td class="code"><pre><span class="line">next_ptr-&gt;prev          = header_ptr;</span><br><span class="line">next_ptr-&gt;next          = header_ptr-&gt;next;</span><br><span class="line">header_ptr-&gt;next-&gt;prev = next_ptr;</span><br><span class="line">header_ptr-&gt;next       = next_ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>插入 block list</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* insert next_ptr to free list */</span></span><br><span class="line">next_ptr-&gt;next_free = heap-&gt;free_list-&gt;next_free;</span><br><span class="line">next_ptr-&gt;prev_free = heap-&gt;free_list;</span><br><span class="line">heap-&gt;free_list-&gt;next_free-&gt;prev_free = next_ptr;</span><br><span class="line">heap-&gt;free_list-&gt;next_free            = next_ptr;</span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"new ptr: next_free 0x%08x, prev_free 0x%08x"</span>,</span><br><span class="line">                                next_ptr-&gt;next_free,</span><br><span class="line">                                next_ptr-&gt;prev_free));</span><br></pre></td></tr></tbody></table></figure><p>插入 free list</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* release lock */</span></span><br><span class="line">        rt_sem_release(&amp;(heap-&gt;lock));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>釋放 semaphore 並回傳更新後的記憶體位址</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* release lock */</span></span><br><span class="line">    rt_sem_release(&amp;(heap-&gt;lock));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* re-allocate a memory block */</span></span><br><span class="line">    new_ptr = (<span class="keyword">void</span> *)rt_memheap_alloc(heap, newsize);</span><br><span class="line">    <span class="keyword">if</span> (new_ptr != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        rt_memcpy(new_ptr, ptr, oldsize &lt; newsize ? oldsize : newsize);</span><br><span class="line">        rt_memheap_free(ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_ptr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果下一顆不夠大，重新在原本的 heap 上要一塊 <code>newsize</code> 大的記憶體</li><li>成功的話還原資料，並釋放原本的記憶體</li><li>回傳新的記憶體位址</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* don't split when there is less than one node space left */</span></span><br><span class="line"><span class="keyword">if</span> (newsize + RT_MEMHEAP_SIZE + RT_MEMHEAP_MINIALLOC &gt;= oldsize)</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果是需要縮減，且縮減後剩下的大小不足以切成一塊</li><li>什麼事都不做，直接回傳原本的位址</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lock memheap */</span></span><br><span class="line">result = rt_sem_take(&amp;(heap-&gt;lock), RT_WAITING_FOREVER);</span><br><span class="line"><span class="keyword">if</span> (result != RT_EOK)</span><br><span class="line">{</span><br><span class="line">    rt_set_errno(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>可以分割的話先取得 semaphore</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* split the block. */</span></span><br><span class="line">new_ptr = (struct rt_memheap_item *)</span><br><span class="line">          (((<span class="keyword">rt_uint8_t</span> *)header_ptr) + newsize + RT_MEMHEAP_SIZE);</span><br></pre></td></tr></tbody></table></figure><ul><li>定址新的 block</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">             (<span class="string">"split: block[0x%08x] nextm[0x%08x] prevm[0x%08x] to new[0x%08x]\n"</span>,</span><br><span class="line">              header_ptr,</span><br><span class="line">              header_ptr-&gt;next,</span><br><span class="line">              header_ptr-&gt;prev,</span><br><span class="line">              new_ptr));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* mark the new block as a memory block and freed. */</span></span><br><span class="line">new_ptr-&gt;magic = RT_MEMHEAP_MAGIC;</span><br><span class="line"><span class="comment">/* put the pool pointer into the new block. */</span></span><br><span class="line">new_ptr-&gt;pool_ptr = heap;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定 magic 碼</li><li>設定所屬 heap</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* break down the block list */</span></span><br><span class="line">new_ptr-&gt;prev          = header_ptr;</span><br><span class="line">new_ptr-&gt;next          = header_ptr-&gt;next;</span><br><span class="line">header_ptr-&gt;next-&gt;prev = new_ptr;</span><br><span class="line">header_ptr-&gt;next       = new_ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>插入至 block list</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* determine if the block can be merged with the next neighbor. */</span></span><br><span class="line"><span class="keyword">if</span> (!RT_MEMHEAP_IS_USED(new_ptr-&gt;next))</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">free_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* merge block with next neighbor. */</span></span><br><span class="line">    free_ptr = new_ptr-&gt;next;</span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size - MEMITEM_SIZE(free_ptr);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果新的 block 下一顆未使用，即可合併</li><li>先將可用大小減掉下一顆的大小，待會會加回來</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">             (<span class="string">"merge: right node 0x%08x, next_free 0x%08x, prev_free 0x%08x\n"</span>,</span><br><span class="line">              header_ptr, header_ptr-&gt;next_free, header_ptr-&gt;prev_free));</span><br><span class="line"></span><br><span class="line">free_ptr-&gt;next-&gt;prev = new_ptr;</span><br><span class="line">new_ptr-&gt;next   = free_ptr-&gt;next;</span><br></pre></td></tr></tbody></table></figure><ul><li>從 block list 移除下一顆</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* remove free ptr from free list */</span></span><br><span class="line">    free_ptr-&gt;next_free-&gt;prev_free = free_ptr-&gt;prev_free;</span><br><span class="line">    free_ptr-&gt;prev_free-&gt;next_free = free_ptr-&gt;next_free;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>從 free list 移除下一顆，完成合併</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* insert the split block to free list */</span></span><br><span class="line">new_ptr-&gt;next_free = heap-&gt;free_list-&gt;next_free;</span><br><span class="line">new_ptr-&gt;prev_free = heap-&gt;free_list;</span><br><span class="line">heap-&gt;free_list-&gt;next_free-&gt;prev_free = new_ptr;</span><br><span class="line">heap-&gt;free_list-&gt;next_free            = new_ptr;</span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"new free ptr: next_free 0x%08x, prev_free 0x%08x\n"</span>,</span><br><span class="line">                                new_ptr-&gt;next_free,</span><br><span class="line">                                new_ptr-&gt;prev_free));</span><br></pre></td></tr></tbody></table></figure><ul><li>無論下一顆是否可以合併，都把新的 block 插入 free list</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* increment the available byte count.  */</span></span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size + MEMITEM_SIZE(new_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* release lock */</span></span><br><span class="line">    rt_sem_release(&amp;(heap-&gt;lock));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* return the old memory block */</span></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_memheap_realloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>更新可用大小，並釋放 semaphore</li><li>回傳更新後的記憶體位址</li></ul><hr><h3 id="Code-rt-calloc"><a class="header-anchor" href="#Code-rt-calloc">#</a>Code: rt_calloc</h3><table><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>要求多個連續的記憶體</td><td>第一塊的位址</td></tr></tbody></table><table><thead><tr><th><code>count</code></th><th><code>size</code></th></tr></thead><tbody><tr><td>欲要求的數量</td><td>欲要求的大小</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_calloc</span><span class="params">(<span class="keyword">rt_size_t</span> count, <span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">rt_size_t</span> total_size;</span><br><span class="line"></span><br><span class="line">    total_size = count * size;</span><br><span class="line">    ptr = rt_malloc(total_size);</span><br><span class="line">    <span class="keyword">if</span> (ptr != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* clean memory */</span></span><br><span class="line">        rt_memset(ptr, <span class="number">0</span>, total_size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_calloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>即要求一塊 <code>count * size</code> 大的記憶體</li></ul><hr><h2 id="釋放記憶體"><a class="header-anchor" href="#釋放記憶體">#</a>釋放記憶體</h2><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*rmem</code></th></tr></thead><tbody><tr><td>釋放一塊記憶體</td><td>void</td><td>欲釋放的記憶體</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_free</span><span class="params">(<span class="keyword">void</span> *rmem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    rt_memheap_free(rmem);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_free);</span><br></pre></td></tr></tbody></table></figure><ul><li>透過 <code>rt_memheap_free</code> 完成</li></ul><hr><table><thead><tr><th>功能</th><th>回傳值</th><th><code>*ptr</code></th></tr></thead><tbody><tr><td>釋放一塊記憶體</td><td>void</td><td>欲釋放的記憶體</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_memheap_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_err_t</span> result;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap</span> *<span class="title">heap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">header_ptr</span>, *<span class="title">new_ptr</span>;</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> insert_header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* NULL check */</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == RT_NULL) <span class="keyword">return</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果傳入 NULL，什麼事都不用做</li><li><code>return</code> 退出副程式</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set initial status as OK */</span></span><br><span class="line">insert_header = <span class="number">1</span>;</span><br><span class="line">new_ptr       = RT_NULL;</span><br><span class="line">header_ptr    = (struct rt_memheap_item *)</span><br><span class="line">                ((<span class="keyword">rt_uint8_t</span> *)ptr - RT_MEMHEAP_SIZE);</span><br></pre></td></tr></tbody></table></figure><ul><li>初始化一些參數，並找到傳入的 block 所屬的 header</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"free memory: memory[0x%08x], block[0x%08x]\n"</span>,</span><br><span class="line">                                ptr, header_ptr));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* check magic */</span></span><br><span class="line">RT_ASSERT((header_ptr-&gt;magic &amp; RT_MEMHEAP_MASK) == RT_MEMHEAP_MAGIC);</span><br><span class="line">RT_ASSERT(header_ptr-&gt;magic &amp; RT_MEMHEAP_USED);</span><br><span class="line"><span class="comment">/* check whether this block of memory has been over-written. */</span></span><br><span class="line">RT_ASSERT((header_ptr-&gt;next-&gt;magic &amp; RT_MEMHEAP_MASK) == RT_MEMHEAP_MAGIC);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get pool ptr */</span></span><br><span class="line">heap = header_ptr-&gt;pool_ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>定址 heap</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br></pre></td><td class="code"><pre><span class="line">RT_ASSERT(heap);</span><br><span class="line">RT_ASSERT(rt_object_get_type(&amp;heap-&gt;parent) == RT_Object_Class_MemHeap);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* lock memheap */</span></span><br><span class="line">result = rt_sem_take(&amp;(heap-&gt;lock), RT_WAITING_FOREVER);</span><br><span class="line"><span class="keyword">if</span> (result != RT_EOK)</span><br><span class="line">{</span><br><span class="line">    rt_set_errno(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>先取得 semaphore</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Mark the memory as available. */</span></span><br><span class="line">header_ptr-&gt;magic &amp;= ~RT_MEMHEAP_USED;</span><br><span class="line"><span class="comment">/* Adjust the available number of bytes. */</span></span><br><span class="line">heap-&gt;available_size = heap-&gt;available_size + MEMITEM_SIZE(header_ptr);</span><br></pre></td></tr></tbody></table></figure><ul><li>將使用中的標記清除，更新可用大小</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Determine if the block can be merged with the previous neighbor. */</span></span><br><span class="line"><span class="keyword">if</span> (!RT_MEMHEAP_IS_USED(header_ptr-&gt;prev))</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"merge: left node 0x%08x\n"</span>,</span><br><span class="line">                                    header_ptr-&gt;prev));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* adjust the available number of bytes. */</span></span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size + RT_MEMHEAP_SIZE;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果可以往前合併，更新可用大小（加一個 header 的大小）</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* yes, merge block with previous neighbor. */</span></span><br><span class="line">(header_ptr-&gt;prev)-&gt;next = header_ptr-&gt;next;</span><br><span class="line">(header_ptr-&gt;next)-&gt;prev = header_ptr-&gt;prev;</span><br></pre></td></tr></tbody></table></figure><ul><li>從 block list 移除此 block</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* move header pointer to previous. */</span></span><br><span class="line">    header_ptr = header_ptr-&gt;prev;</span><br><span class="line">    <span class="comment">/* don't insert header to free list */</span></span><br><span class="line">    insert_header = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>重新定址 <code>header_ptr</code></li><li>設定 <code>insert_header</code> 為 0，表示待會不需要將此 block 插回 free list（現在此 block 是與前一塊合併的，已經在 free list 上了）</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* determine if the block can be merged with the next neighbor. */</span></span><br><span class="line"><span class="keyword">if</span> (!RT_MEMHEAP_IS_USED(header_ptr-&gt;next))</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* adjust the available number of bytes. */</span></span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size + RT_MEMHEAP_SIZE;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果可以往前合併，更新可用大小（加一個 header 的大小）</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* merge block with next neighbor. */</span></span><br><span class="line">new_ptr = header_ptr-&gt;next;</span><br><span class="line"></span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">             (<span class="string">"merge: right node 0x%08x, next_free 0x%08x, prev_free 0x%08x\n"</span>,</span><br><span class="line">              new_ptr, new_ptr-&gt;next_free, new_ptr-&gt;prev_free));</span><br><span class="line"></span><br><span class="line">new_ptr-&gt;next-&gt;prev = header_ptr;</span><br><span class="line">header_ptr-&gt;next    = new_ptr-&gt;next;</span><br></pre></td></tr></tbody></table></figure><ul><li>定址下一塊，並從 block list 移除下一塊</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* remove new ptr from free list */</span></span><br><span class="line">    new_ptr-&gt;next_free-&gt;prev_free = new_ptr-&gt;prev_free;</span><br><span class="line">    new_ptr-&gt;prev_free-&gt;next_free = new_ptr-&gt;next_free;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>一併從 free list 中移除</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (insert_header)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* no left merge, insert to free list */</span></span><br><span class="line">    header_ptr-&gt;next_free = heap-&gt;free_list-&gt;next_free;</span><br><span class="line">    header_ptr-&gt;prev_free = heap-&gt;free_list;</span><br><span class="line">    heap-&gt;free_list-&gt;next_free-&gt;prev_free = header_ptr;</span><br><span class="line">    heap-&gt;free_list-&gt;next_free            = header_ptr;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">                 (<span class="string">"insert to free list: next_free 0x%08x, prev_free 0x%08x\n"</span>,</span><br><span class="line">                  header_ptr-&gt;next_free, header_ptr-&gt;prev_free));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果需要，插回 free list 上</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* release lock */</span></span><br><span class="line">    rt_sem_release(&amp;(heap-&gt;lock));</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_memheap_free);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後釋放 semaphore</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;使用此管理方式： &lt;code&gt;#define RT
      
    
    </summary>
    
    
      <category term="RT-Thread" scheme="https://blog.lusw.dev/categories/RT-Thread/"/>
    
    
      <category term="kernel" scheme="https://blog.lusw.dev/tags/kernel/"/>
    
      <category term="RT-Thread" scheme="https://blog.lusw.dev/tags/RT-Thread/"/>
    
      <category term="記憶體管理" scheme="https://blog.lusw.dev/tags/MemMan/"/>
    
      <category term="Memory Heap" scheme="https://blog.lusw.dev/tags/Memory-Heap/"/>
    
  </entry>
  
</feed>
