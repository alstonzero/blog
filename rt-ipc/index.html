<!DOCTYPE html>
<html lang="zh-TW">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">

    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->

    

    
        <meta name="description" content="單晶片、即時作業系統與韌體相關之技術筆記">
    

    <!--Author-->
    
        <meta name="author" content="LuSkywalker">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="RT-Thread IPC 同步">
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="單晶片、即時作業系統與韌體相關之技術筆記">
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="技術筆記">

    <!--Type page-->
    
        <meta property="og:type" content="article">
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="http://blog.lusw.devhttp://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg">
    

        <meta name="twitter:card" content="summary_large_image">

    

    
        <meta name="twitter:image" content="http://blog.lusw.devhttp://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg">
    

    <!-- Title -->
    
    <title>RT-Thread IPC 同步 - 技術筆記</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">
    <link href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet">

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
    <link rel="icon" href="/img/favicon.png">
    

    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<link rel="alternate" href="/atom.xml" title="技術筆記" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>

    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">技術筆記</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/tags/Linux">
                            
                                Linux
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags/RT-Thread">
                            
                                RT-Thread
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags/XV6">
                            
                                XV6
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags/Clang">
                            
                                C Lang
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/luswdev">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>RT-Thread IPC 同步</h1>
                    
                    <span class="meta">
                        
                            category: 

<a href="/categories/RT-Thread/">RT-Thread</a>

                        
                    </span>
                    <span class="meta meta-right">
                        <!-- Date and Author -->
                        
                        
                            2018-11-26
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>兩個 thread 要溝通的方式，是透過共享的記憶體來完成；而如果此記憶體沒有排他性，這個記憶體有可能會不同步。</li>
<li>因此進入一塊共享的記憶體一次只允許一個 thread 來使用，這樣即可保證其資料的一致性</li>
<li>進入此共享記憶體則叫做 <strong>critical region</strong></li>
<li>RT-Thread 利用 7 種方式來完成同步：關閉中斷、scheduler lock、semaphore、互斥鎖、事件、mail box 及 message</li>
</ul>
<hr>
<h2 id="關閉中斷"><a href="#關閉中斷" class="headerlink" title="關閉中斷"></a>關閉中斷</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">level = rt_hw_interrupt_disable();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  critical region </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">rt_hw_interrupt_enable(level);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>此方式是最強大的一種，但此 critical region 不可以佔用太多時間</li>
</ul>
<hr>
<h2 id="Scheduler-lock"><a href="#Scheduler-lock" class="headerlink" title="Scheduler lock"></a>Scheduler lock</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">rt_enter_critical()</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  critical region </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">rt_exit_critical()</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>使用此方式可確保當前 thread 不會被 scheduler 踢出，但還是有可能會被中斷影響。</li>
</ul>
<hr>
<h3 id="進入-scheuler-鎖"><a href="#進入-scheuler-鎖" class="headerlink" title="進入 scheuler 鎖"></a>進入 scheuler 鎖</h3><p><i class="fa fa-code"></i> Code: <code>rt_enter_critical</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>進入 scheuler 鎖</td>
<td>void</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will lock the thread scheduler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_enter_critical</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * the maximal number of nest is RT_UINT16_MAX, which is big</span></span><br><span class="line"><span class="comment">     * enough and does not check here</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rt_scheduler_lock_nest ++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(level);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_enter_critical);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>即，將 <code>rt_scheduler_lock_nest</code> 加一</li>
</ul>
<hr>
<h3 id="離開-scheduler-鎖"><a href="#離開-scheduler-鎖" class="headerlink" title="離開 scheduler 鎖"></a>離開 scheduler 鎖</h3><p><i class="fa fa-code"></i> Code: <code>rt_exit_critical</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>離開 scheuler 鎖</td>
<td>void</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will unlock the thread scheduler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_exit_critical</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    rt_scheduler_lock_nest --;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>即，將 <code>rt_scheduler_lock_nest</code> 減一</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (rt_scheduler_lock_nest &lt;= <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_scheduler_lock_nest = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line">        rt_schedule();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(level);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果 <code>rt_scheduler_lock_nest</code> 被減至 0 或以下，進行一次調度</li>
</ul>
<hr>
<p><i class="fa fa-code"></i> Code: <code>rt_critical_level</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>回傳 scheuler 鎖的值</td>
<td>scheuler 鎖的值</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the scheduler lock level</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the level of the scheduler lock. 0 means unlocked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_uint16_t</span> rt_critical_level(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> rt_scheduler_lock_nest;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_critical_level);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>即，回傳 <code>rt_scheduler_lock_nest</code> 值</li>
</ul>
<hr>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><blockquote>
<p>File: ipc.c</p>
</blockquote>
<ul>
<li>為一個值，代表同時可用的個數</li>
<li>不等於 0 時可用，取用時將值減 1</li>
<li>當不可用時，將 thread 掛在等待的鏈上</li>
</ul>
<h3 id="結構"><a href="#結構" class="headerlink" title="結構"></a>結構</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_SEMAPHORE</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Semaphore structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_semaphore</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_ipc_object</span> <span class="title">parent</span>;</span>                        <span class="comment">/**&lt; inherit from ipc_object */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint16_t</span>          value;                         <span class="comment">/**&lt; value of semaphore. */</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_semaphore</span> *<span class="title">rt_sem_t</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="建立-semaphore"><a href="#建立-semaphore" class="headerlink" title="建立 semaphore"></a>建立 semaphore</h3><h4 id="動態記憶體管理"><a href="#動態記憶體管理" class="headerlink" title="動態記憶體管理"></a>動態記憶體管理</h4><p><i class="fa fa-code"></i> Code: <code>rt_sem_create</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>建立 semaphore</td>
<td>semaphore</td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th><code>*name</code></th>
<th><code>value</code></th>
<th><code>flag</code></th>
</tr>
</thead>
<tbody><tr>
<td>名字</td>
<td>semaphore 值，即最大可同時使用人數</td>
<td>FIFO / PRIO</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will create a semaphore from system resource</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name the name of semaphore</span></span><br><span class="line"><span class="comment"> * @param value the init value of semaphore</span></span><br><span class="line"><span class="comment"> * @param flag the flag of semaphore</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the created semaphore, RT_NULL on error happen</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see rt_sem_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_sem_t</span> rt_sem_create(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">rt_uint32_t</span> value, <span class="keyword">rt_uint8_t</span> flag)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_sem_t</span> sem;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate object */</span></span><br><span class="line">    sem = (<span class="keyword">rt_sem_t</span>)rt_object_allocate(RT_Object_Class_Semaphore, name);</span><br><span class="line">    <span class="keyword">if</span> (sem == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> sem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init ipc object */</span></span><br><span class="line">    rt_ipc_object_init(&amp;(sem-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set init value */</span></span><br><span class="line">    sem-&gt;value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set parent */</span></span><br><span class="line">    sem-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sem;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_sem_create);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>首先需要一塊 semaphore 的大小，初始化 ipc 物件，再依序寫入初始值及 flag</li>
</ul>
<hr>
<h4 id="靜態記憶體管理"><a href="#靜態記憶體管理" class="headerlink" title="靜態記憶體管理"></a>靜態記憶體管理</h4><p><i class="fa fa-code"></i> Code: <code>rt_sem_init</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>初始化 semaphore</td>
<td><code>RT_EOK</code></td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th><code>sem</code></th>
<th><code>*name</code></th>
<th><code>value</code></th>
<th><code>flag</code></th>
</tr>
</thead>
<tbody><tr>
<td>semaphore 本體</td>
<td>名字</td>
<td>semaphore 值，即最大可同時使用人數</td>
<td>FIFO / PRIO</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will initialize a semaphore and put it under control of</span></span><br><span class="line"><span class="comment"> * resource management.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sem the semaphore object</span></span><br><span class="line"><span class="comment"> * @param name the name of semaphore</span></span><br><span class="line"><span class="comment"> * @param value the init value of semaphore</span></span><br><span class="line"><span class="comment"> * @param flag the flag of semaphore</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_sem_init(<span class="keyword">rt_sem_t</span>    sem,</span><br><span class="line">                     <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">                     <span class="keyword">rt_uint32_t</span> value,</span><br><span class="line">                     <span class="keyword">rt_uint8_t</span>  flag)</span><br><span class="line">{</span><br><span class="line">    RT_ASSERT(sem != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init object */</span></span><br><span class="line">    rt_object_init(&amp;(sem-&gt;parent.parent), RT_Object_Class_Semaphore, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init ipc object */</span></span><br><span class="line">    rt_ipc_object_init(&amp;(sem-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set init value */</span></span><br><span class="line">    sem-&gt;value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set parent */</span></span><br><span class="line">    sem-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_sem_init);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>由於使用靜態記憶體，這裡就不需要再 allocate。</li>
</ul>
<hr>
<h3 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IPC flags and control command definitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_IPC_FLAG_FIFO                0x00            <span class="comment">/**&lt; FIFOed IPC. @ref IPC. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_IPC_FLAG_PRIO                0x01            <span class="comment">/**&lt; PRIOed IPC. @ref IPC. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_IPC_CMD_UNKNOWN              0x00            <span class="comment">/**&lt; unknown IPC command */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_IPC_CMD_RESET                0x01            <span class="comment">/**&lt; reset IPC object */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_WAITING_FOREVER              -1              <span class="comment">/**&lt; Block forever until get resource. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_WAITING_NO                   0               <span class="comment">/**&lt; Non-block. */</span></span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="刪除-semaphore"><a href="#刪除-semaphore" class="headerlink" title="刪除 semaphore"></a>刪除 semaphore</h3><h4 id="動態記憶體管理-1"><a href="#動態記憶體管理-1" class="headerlink" title="動態記憶體管理"></a>動態記憶體管理</h4><p><i class="fa fa-code"></i> Code: <code>rt_sem_delete</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>刪除 semaphore</td>
<td><code>RT_EOK</code></td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th><code>sem</code></th>
</tr>
</thead>
<tbody><tr>
<td>欲刪除的 semaphore</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will delete a semaphore object and release the memory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sem the semaphore object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see rt_sem_detach</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_sem_delete(<span class="keyword">rt_sem_t</span> sem)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(sem != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;sem-&gt;parent.parent) == RT_Object_Class_Semaphore);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;sem-&gt;parent.parent) == RT_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wakeup all suspend threads */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(sem-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* delete semaphore object */</span></span><br><span class="line">    rt_object_delete(&amp;(sem-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_sem_delete);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>首先需把所有正在等待此 semaphore 的 thread 叫醒</li>
<li>接著呼叫 <code>rt_object_delete</code> 清除此物件（semaphore）</li>
</ul>
<hr>
<h4 id="靜態記憶體管理-1"><a href="#靜態記憶體管理-1" class="headerlink" title="靜態記憶體管理"></a>靜態記憶體管理</h4><p><i class="fa fa-code"></i> Code: <code>rt_sem_detach</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>刪除 semaphore</td>
<td><code>RT_EOK</code></td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th><code>sem</code></th>
</tr>
</thead>
<tbody><tr>
<td>欲刪除的 semaphore</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will detach a semaphore from resource management</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sem the semaphore object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on successful</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see rt_sem_delete</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_sem_detach(<span class="keyword">rt_sem_t</span> sem)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(sem != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;sem-&gt;parent.parent) == RT_Object_Class_Semaphore);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;sem-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wakeup all suspend threads */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(sem-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* detach semaphore object */</span></span><br><span class="line">    rt_object_detach(&amp;(sem-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_sem_detach);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>這裡則透過 <code>rt_object_detach</code> 清除</li>
</ul>
<hr>
<h3 id="使用-semaphore"><a href="#使用-semaphore" class="headerlink" title="使用 semaphore"></a>使用 semaphore</h3><ul>
<li>呼叫 <code>rt_sem_take</code> 來取得 semaphore，傳入的 time 是等待時間</li>
</ul>
<p><i class="fa fa-code"></i> Code: <code>rt_sem_take</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>要求 semaphore</td>
<td><code>RT_EOK</code></td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th><code>sem</code></th>
<th><code>time</code></th>
</tr>
</thead>
<tbody><tr>
<td>欲要求的 semaphore</td>
<td>等待時間（如果需要）</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will take a semaphore, if the semaphore is unavailable, the</span></span><br><span class="line"><span class="comment"> * thread shall wait for a specified time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sem the semaphore object</span></span><br><span class="line"><span class="comment"> * @param time the waiting time</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_sem_take(<span class="keyword">rt_sem_t</span> sem, <span class="keyword">rt_int32_t</span> time)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(sem != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;sem-&gt;parent.parent) == RT_Object_Class_Semaphore);</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&amp;(sem-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>由於待會會修改 semaphore 的值，這裡先將中斷關閉</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_IPC, (<span class="string">"thread %s take sem:%s, which value is: %d\n"</span>,</span><br><span class="line">                            rt_thread_self()-&gt;name,</span><br><span class="line">                            ((struct rt_object *)sem)-&gt;name,</span><br><span class="line">                            sem-&gt;value));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sem-&gt;value &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* semaphore is available */</span></span><br><span class="line">    sem-&gt;value --;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如過 <code>sem-&gt;value</code> 值大於 0 代表可用，接著減一，並開啟中斷</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* no waiting, return with timeout */</span></span><br><span class="line">    <span class="keyword">if</span> (time == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -RT_ETIMEOUT;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果 semaphore 不可用時：</li>
<li>且 time 為 0，表示不等待，直接開啟中斷並 return</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* current context checking */</span></span><br><span class="line">    RT_DEBUG_IN_THREAD_CONTEXT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* semaphore is unavailable, push to suspend list */</span></span><br><span class="line">    <span class="comment">/* get current thread */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset thread error number */</span></span><br><span class="line">    thread-&gt;error = RT_EOK;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_IPC, (<span class="string">"sem take: suspend thread - %s\n"</span>,</span><br><span class="line">                                thread-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* suspend thread */</span></span><br><span class="line">    rt_ipc_list_suspend(&amp;(sem-&gt;parent.suspend_thread),</span><br><span class="line">                        thread,</span><br><span class="line">                        sem-&gt;parent.parent.flag);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果要等待，則將 thread 插入 suspend list</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* has waiting time, start thread timer */</span></span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_IPC, (<span class="string">"set thread:%s to timer list\n"</span>,</span><br><span class="line">                                thread-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset the timeout of thread timer and start it */</span></span><br><span class="line">    rt_timer_control(&amp;(thread-&gt;thread_timer),</span><br><span class="line">                     RT_TIMER_CTRL_SET_TIME,</span><br><span class="line">                     &amp;time);</span><br><span class="line">    rt_timer_start(&amp;(thread-&gt;thread_timer));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>且如果等待時間大於 0，則啟動一個 timeout 為 time 的 timer</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">            <span class="comment">/* enable interrupt */</span></span><br><span class="line">            rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* do schedule */</span></span><br><span class="line">            rt_schedule();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (thread-&gt;error != RT_EOK)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span> thread-&gt;error;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&amp;(sem-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_sem_take);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>最後開啟中斷，做一次調度</li>
</ul>
<hr>
<ul>
<li>若是不想等待，可以呼叫 <code>rt_sem_trytake</code></li>
<li>即呼叫 <code>rt_sem_take</code> 及傳入 <code>time</code> 為 0</li>
</ul>
<p><i class="fa fa-code"></i> Code: <code>rt_sem_trytake</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>要求 semaphore（不等待）</td>
<td><code>RT_EOK</code></td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th><code>sem</code></th>
</tr>
</thead>
<tbody><tr>
<td>欲要求的 semaphore</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will try to take a semaphore and immediately return</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sem the semaphore object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_sem_trytake(<span class="keyword">rt_sem_t</span> sem)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> rt_sem_take(sem, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_sem_trytake);</span><br></pre></td></tr></tbody></table></figure>

<hr>
<ul>
<li>還 semaphore 則使用 <code>rt_sem_release</code></li>
</ul>
<p><i class="fa fa-code"></i> Code: <code>rt_sem_release</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>釋放 semaphore</td>
<td><code>RT_EOK</code></td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th><code>sem</code></th>
</tr>
</thead>
<tbody><tr>
<td>欲要求的 semaphore</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will release a semaphore, if there are threads suspended on</span></span><br><span class="line"><span class="comment"> * semaphore, it will be waked up.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sem the semaphore object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_sem_release(<span class="keyword">rt_sem_t</span> sem)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_bool_t</span> need_schedule;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(sem != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;sem-&gt;parent.parent) == RT_Object_Class_Semaphore);</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&amp;(sem-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    need_schedule = RT_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>首先將待會會遇到的 flag（<code>need_schedule</code>）設為 false</li>
<li>因為待會也會修改 semaphore 的值，這裡需要關閉中斷</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_IPC, (<span class="string">"thread %s releases sem:%s, which value is: %d\n"</span>,</span><br><span class="line">                            rt_thread_self()-&gt;name,</span><br><span class="line">                            ((struct rt_object *)sem)-&gt;name,</span><br><span class="line">                            sem-&gt;value));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!rt_list_isempty(&amp;sem-&gt;parent.suspend_thread))</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* resume the suspended thread */</span></span><br><span class="line">    rt_ipc_list_resume(&amp;(sem-&gt;parent.suspend_thread));</span><br><span class="line">    need_schedule = RT_TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果有人在等此 semaphore，先恢復他，並修改 <code>need_schedule</code> 為 true</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">    sem-&gt;value ++; <span class="comment">/* increase value */</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果沒有人在等待，則加一</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resume a thread, re-schedule */</span></span><br><span class="line">    <span class="keyword">if</span> (need_schedule == RT_TRUE)</span><br><span class="line">        rt_schedule();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_sem_release);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>最後開啟中斷，並根據 <code>need_schedule</code> 來決定需不需要執行一次調度</li>
</ul>
<hr>
<h2 id="互斥鎖（mutex）"><a href="#互斥鎖（mutex）" class="headerlink" title="互斥鎖（mutex）"></a>互斥鎖（mutex）</h2><ul>
<li>即一種值為 1 的特殊 semaphore，特別的是具有防止優先級翻轉的特性</li>
</ul>
<h3 id="結構-1"><a href="#結構-1" class="headerlink" title="結構"></a>結構</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MUTEX</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mutual exclusion (mutex) structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_ipc_object</span> <span class="title">parent</span>;</span>                        <span class="comment">/**&lt; inherit from ipc_object */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint16_t</span>          value;                         <span class="comment">/**&lt; value of mutex */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint8_t</span>           original_priority;             <span class="comment">/**&lt; priority of last thread hold the mutex */</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span>           hold;                          <span class="comment">/**&lt; numbers of thread hold the mutex */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span>    *<span class="title">owner</span>;</span>                         <span class="comment">/**&lt; current owner of mutex */</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> *<span class="title">rt_mutex_t</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>為了防止優先權翻轉，在持有鎖的過程中可能會被提升優先權，在結構中就需要紀錄原本的優先級。</li>
</ul>
<hr>
<h3 id="建立-mutex"><a href="#建立-mutex" class="headerlink" title="建立 mutex"></a>建立 mutex</h3><h4 id="動態記憶體管理-2"><a href="#動態記憶體管理-2" class="headerlink" title="動態記憶體管理"></a>動態記憶體管理</h4><p><i class="fa fa-code"></i> Code: <code>rt_mutex_create</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>建立 mutex</td>
<td>mutex</td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th><code>*name</code></th>
<th><code>flag</code></th>
</tr>
</thead>
<tbody><tr>
<td>名字</td>
<td>FIFO / PRIO</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will create a mutex from system resource</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name the name of mutex</span></span><br><span class="line"><span class="comment"> * @param flag the flag of mutex</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the created mutex, RT_NULL on error happen</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see rt_mutex_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_mutex_t</span> rt_mutex_create(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">rt_uint8_t</span> flag)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> *<span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate object */</span></span><br><span class="line">    mutex = (<span class="keyword">rt_mutex_t</span>)rt_object_allocate(RT_Object_Class_Mutex, name);</span><br><span class="line">    <span class="keyword">if</span> (mutex == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> mutex;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>首先 allocate 一個物件，初始化</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* init ipc object */</span></span><br><span class="line">rt_ipc_object_init(&amp;(mutex-&gt;parent));</span><br><span class="line"></span><br><span class="line">mutex-&gt;value              = <span class="number">1</span>;</span><br><span class="line">mutex-&gt;owner              = RT_NULL;</span><br><span class="line">mutex-&gt;original_priority  = <span class="number">0xFF</span>;</span><br><span class="line">mutex-&gt;hold               = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>value 設為 1，擁有者為 NULL，原始權限最低（255），持有次數為 0</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="comment">/* set flag */</span></span><br><span class="line">    mutex-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutex;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mutex_create);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>同時填入 flag</li>
</ul>
<hr>
<h4 id="靜態記憶體管理-2"><a href="#靜態記憶體管理-2" class="headerlink" title="靜態記憶體管理"></a>靜態記憶體管理</h4><p><i class="fa fa-code"></i> Code: <code>rt_mutex_init</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>初始化 mutex</td>
<td><code>RT_EOK</code></td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th><code>mutex</code></th>
<th><code>*name</code></th>
<th><code>flag</code></th>
</tr>
</thead>
<tbody><tr>
<td>mutex 本體</td>
<td>名字</td>
<td>FIFO / PRIO</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will initialize a mutex and put it under control of resource</span></span><br><span class="line"><span class="comment"> * management.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mutex the mutex object</span></span><br><span class="line"><span class="comment"> * @param name the name of mutex</span></span><br><span class="line"><span class="comment"> * @param flag the flag of mutex</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mutex_init(<span class="keyword">rt_mutex_t</span> mutex, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">rt_uint8_t</span> flag)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mutex != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init object */</span></span><br><span class="line">    rt_object_init(&amp;(mutex-&gt;parent.parent), RT_Object_Class_Mutex, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init ipc object */</span></span><br><span class="line">    rt_ipc_object_init(&amp;(mutex-&gt;parent));</span><br><span class="line"></span><br><span class="line">    mutex-&gt;value = <span class="number">1</span>;</span><br><span class="line">    mutex-&gt;owner = RT_NULL;</span><br><span class="line">    mutex-&gt;original_priority = <span class="number">0xFF</span>;</span><br><span class="line">    mutex-&gt;hold  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set flag */</span></span><br><span class="line">    mutex-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mutex_init);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>這裡不需要 allocate，只需要初始化物件</li>
</ul>
<hr>
<h3 id="刪除-mutex"><a href="#刪除-mutex" class="headerlink" title="刪除 mutex"></a>刪除 mutex</h3><h4 id="動態記憶體管理-3"><a href="#動態記憶體管理-3" class="headerlink" title="動態記憶體管理"></a>動態記憶體管理</h4><p><i class="fa fa-code"></i> Code: <code>rt_mutex_delete</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>刪除 mutex</td>
<td><code>RT_EOK</code></td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th><code>mutex</code></th>
</tr>
</thead>
<tbody><tr>
<td>欲刪除的 mutex</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will delete a mutex object and release the memory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mutex the mutex object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see rt_mutex_detach</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mutex_delete(<span class="keyword">rt_mutex_t</span> mutex)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mutex != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mutex-&gt;parent.parent) == RT_Object_Class_Mutex);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;mutex-&gt;parent.parent) == RT_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wakeup all suspend threads */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(mutex-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* delete semaphore object */</span></span><br><span class="line">    rt_object_delete(&amp;(mutex-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mutex_delete);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>與 semaphore 類似，先將正在等待此鎖的所有 thread 叫醒，接著透過 <code>rt_object_delete</code> 刪除 mutex</li>
</ul>
<hr>
<h4 id="靜態記憶體管理-3"><a href="#靜態記憶體管理-3" class="headerlink" title="靜態記憶體管理"></a>靜態記憶體管理</h4><p><i class="fa fa-code"></i> Code: <code>rt_mutex_detach</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>刪除 mutex</td>
<td><code>RT_EOK</code></td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th><code>mutex</code></th>
</tr>
</thead>
<tbody><tr>
<td>欲刪除的 mutex</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will detach a mutex from resource management</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mutex the mutex object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on successful</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see rt_mutex_delete</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mutex_detach(<span class="keyword">rt_mutex_t</span> mutex)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mutex != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mutex-&gt;parent.parent) == RT_Object_Class_Mutex);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;mutex-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wakeup all suspend threads */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(mutex-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* detach semaphore object */</span></span><br><span class="line">    rt_object_detach(&amp;(mutex-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mutex_detach);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>這裡則運用 <code>rt_object_detach</code> 刪除</li>
</ul>
<hr>
<h3 id="使用-mutex"><a href="#使用-mutex" class="headerlink" title="使用 mutex"></a>使用 mutex</h3><ul>
<li>呼叫 <code>rt_mutex_take</code> 來取得鎖</li>
</ul>
<p><i class="fa fa-code"></i> Code: <code>rt_mutex_take</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>要求 mutex</td>
<td><code>RT_EOK</code></td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th><code>mutex</code></th>
<th><code>time</code></th>
</tr>
</thead>
<tbody><tr>
<td>欲要求的 mutex</td>
<td>等待時間（如果需要）</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will take a mutex, if the mutex is unavailable, the</span></span><br><span class="line"><span class="comment"> * thread shall wait for a specified time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mutex the mutex object</span></span><br><span class="line"><span class="comment"> * @param time the waiting time</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mutex_take(<span class="keyword">rt_mutex_t</span> mutex, <span class="keyword">rt_int32_t</span> time)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* this function must not be used in interrupt even if time = 0 */</span></span><br><span class="line">    RT_DEBUG_IN_THREAD_CONTEXT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mutex != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mutex-&gt;parent.parent) == RT_Object_Class_Mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get current thread */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>下面將會修改 mutex 的一些資料，這裡先將中斷關閉</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&amp;(mutex-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_IPC,</span><br><span class="line">             (<span class="string">"mutex_take: current thread %s, mutex value: %d, hold: %d\n"</span>,</span><br><span class="line">              thread-&gt;name, mutex-&gt;value, mutex-&gt;hold));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* reset thread error */</span></span><br><span class="line">thread-&gt;error = RT_EOK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mutex-&gt;owner == thread)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* it's the same thread */</span></span><br><span class="line">    mutex-&gt;hold ++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>若此 mutex 的擁有者與要求著相同，持有數加 1</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">__again:</span><br><span class="line">        <span class="comment">/* The value of mutex is 1 in initial status. Therefore, if the</span></span><br><span class="line"><span class="comment">         * value is great than 0, it indicates the mutex is avaible.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (mutex-&gt;value &gt; <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* mutex is available */</span></span><br><span class="line">            mutex-&gt;value --;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* set mutex owner and original priority */</span></span><br><span class="line">            mutex-&gt;owner             = thread;</span><br><span class="line">            mutex-&gt;original_priority = thread-&gt;current_priority;</span><br><span class="line">            mutex-&gt;hold ++;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果不同，且 mutex 可用，先將 value –</li>
<li>設定所有者，紀錄當前權限，持有數加 1</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* no waiting, return with timeout */</span></span><br><span class="line">    <span class="keyword">if</span> (time == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* set error as timeout */</span></span><br><span class="line">        thread-&gt;error = -RT_ETIMEOUT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -RT_ETIMEOUT;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果不可用，且不等待，則啟用中斷，<code>return -RT_ETIMEOUT</code></li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* mutex is unavailable, push to suspend list */</span></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_IPC, (<span class="string">"mutex_take: suspend thread: %s\n"</span>,</span><br><span class="line">                                thread-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* change the owner thread priority of mutex */</span></span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;current_priority &lt; mutex-&gt;owner-&gt;current_priority)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* change the owner thread priority */</span></span><br><span class="line">        rt_thread_control(mutex-&gt;owner,</span><br><span class="line">                          RT_THREAD_CTRL_CHANGE_PRIORITY,</span><br><span class="line">                          &amp;thread-&gt;current_priority);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>若需要等待：</li>
<li>為了避免優先權翻轉的情形發生，如需等待的 thread 的優先級大於持有 mutex 的優先級，提升持有者的</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* suspend current thread */</span></span><br><span class="line">rt_ipc_list_suspend(&amp;(mutex-&gt;parent.suspend_thread),</span><br><span class="line">                    thread,</span><br><span class="line">                    mutex-&gt;parent.parent.flag);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* has waiting time, start thread timer */</span></span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_IPC,</span><br><span class="line">                 (<span class="string">"mutex_take: start the timer of thread:%s\n"</span>,</span><br><span class="line">                  thread-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset the timeout of thread timer and start it */</span></span><br><span class="line">    rt_timer_control(&amp;(thread-&gt;thread_timer),</span><br><span class="line">                     RT_TIMER_CTRL_SET_TIME,</span><br><span class="line">                     &amp;time);</span><br><span class="line">    rt_timer_start(&amp;(thread-&gt;thread_timer));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>插入 suspend list，並啟動一個 timeout 為 time 的 timer</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* enable interrupt */</span></span><br><span class="line">rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* do schedule */</span></span><br><span class="line">rt_schedule();</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>開啟中斷，並做一次調度</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (thread-&gt;error != RT_EOK)</span><br><span class="line">{</span><br><span class="line">	<span class="comment">/* interrupt by signal, try it again */</span></span><br><span class="line">	<span class="keyword">if</span> (thread-&gt;error == -RT_EINTR) <span class="keyword">goto</span> __again;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* return error */</span></span><br><span class="line">    <span class="keyword">return</span> thread-&gt;error;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果因為中斷再次回到此 thread，重新要一次 mutex</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">/* the mutex is taken successfully. */</span></span><br><span class="line">                    <span class="comment">/* disable interrupt */</span></span><br><span class="line">                    temp = rt_hw_interrupt_disable();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&amp;(mutex-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mutex_take);</span><br></pre></td></tr></tbody></table></figure>

<hr>
<ul>
<li>還鎖則使用 <code>rt_mutex_release</code></li>
</ul>
<p><i class="fa fa-code"></i> Code: <code>rt_mutex_release</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>釋放 mutex</td>
<td><code>RT_EOK</code></td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th><code>mutex</code></th>
</tr>
</thead>
<tbody><tr>
<td>欲釋放的 mutex</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will release a mutex, if there are threads suspended on mutex,</span></span><br><span class="line"><span class="comment"> * it will be waked up.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mutex the mutex object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mutex_release(<span class="keyword">rt_mutex_t</span> mutex)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">rt_bool_t</span> need_schedule;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mutex != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mutex-&gt;parent.parent) == RT_Object_Class_Mutex);</span><br><span class="line"></span><br><span class="line">    need_schedule = RT_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* only thread could release mutex because we need test the ownership */</span></span><br><span class="line">    RT_DEBUG_IN_THREAD_CONTEXT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get current thread */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>下面將會修改 mutex 的一些資料，這裡先將中斷關閉</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_IPC,</span><br><span class="line">             (<span class="string">"mutex_release:current thread %s, mutex value: %d, hold: %d\n"</span>,</span><br><span class="line">              thread-&gt;name, mutex-&gt;value, mutex-&gt;hold));</span><br><span class="line"></span><br><span class="line">RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&amp;(mutex-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* mutex only can be released by owner */</span></span><br><span class="line"><span class="keyword">if</span> (thread != mutex-&gt;owner)</span><br><span class="line">{</span><br><span class="line">    thread-&gt;error = -RT_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -RT_ERROR;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>檢查歸還者是否為擁有者</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* decrease hold */</span></span><br><span class="line">mutex-&gt;hold --;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>持有數減 1</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* if no hold */</span></span><br><span class="line"><span class="keyword">if</span> (mutex-&gt;hold == 才會</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* change the owner thread to original priority */</span></span><br><span class="line">    <span class="keyword">if</span> (mutex-&gt;original_priority != mutex-&gt;owner-&gt;current_priority)</span><br><span class="line">    {</span><br><span class="line">        rt_thread_control(mutex-&gt;owner,</span><br><span class="line">                          RT_THREAD_CTRL_CHANGE_PRIORITY,</span><br><span class="line">                          &amp;(mutex-&gt;original_priority));</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>若已不再擁有此 mutex，且優先權有被更改過，調整回來</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* wakeup suspended thread */</span></span><br><span class="line"><span class="keyword">if</span> (!rt_list_isempty(&amp;mutex-&gt;parent.suspend_thread))</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* get suspended thread */</span></span><br><span class="line">    thread = rt_list_entry(mutex-&gt;parent.suspend_thread.next,</span><br><span class="line">                           struct rt_thread,</span><br><span class="line">                           tlist);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_IPC, (<span class="string">"mutex_release: resume thread: %s\n"</span>,</span><br><span class="line">                                thread-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set new owner and priority */</span></span><br><span class="line">    mutex-&gt;owner             = thread;</span><br><span class="line">    mutex-&gt;original_priority = thread-&gt;current_priority;</span><br><span class="line">    mutex-&gt;hold ++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resume thread */</span></span><br><span class="line">    rt_ipc_list_resume(&amp;(mutex-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">    need_schedule = RT_TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>若有人在等待此 mutex，將 mutex 傳遞給第一個正在等待的 thread</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* increase value */</span></span><br><span class="line">        mutex-&gt;value ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* clear owner */</span></span><br><span class="line">        mutex-&gt;owner             = RT_NULL;</span><br><span class="line">        mutex-&gt;original_priority = <span class="number">0xff</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果沒有人在等，value 加 1，將資料初始化</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* perform a schedule */</span></span><br><span class="line">    <span class="keyword">if</span> (need_schedule == RT_TRUE)</span><br><span class="line">        rt_schedule();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mutex_release);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>開啟中斷，並視情況做一次調度</li>
</ul>
<hr>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul>
<li>可實現一對多，多對多</li>
<li>僅用來同步，無傳輸的功能</li>
</ul>
<h3 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h3><ul>
<li>thread 的結構中有一個 32 位的事件標記，一個事件的資訊</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(RT_USING_EVENT)</span></span><br><span class="line">    <span class="comment">/* thread event */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> event_set;</span><br><span class="line">    <span class="keyword">rt_uint8_t</span>  event_info;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>標記的每一位代表一個事件，資訊包含 AND、OR 及 CLEAR</li>
<li>當事件標記的第 2、4 位為 1，其餘為 0，代表此 thread 設置第 2、4 個事件<ul>
<li>AND：即需同時接收到 2 號與 4 號事件才會被喚醒</li>
<li>OR：只需接收到一個</li>
<li>CLEAR：表示接收完事件喚醒後，是否須將標記清除</li>
</ul>
</li>
</ul>
<h3 id="結構-2"><a href="#結構-2" class="headerlink" title="結構"></a>結構</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_EVENT</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * flag defintions in event</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_EVENT_FLAG_AND               0x01            <span class="comment">/**&lt; logic and */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_EVENT_FLAG_OR                0x02            <span class="comment">/**&lt; logic or */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_EVENT_FLAG_CLEAR             0x04            <span class="comment">/**&lt; clear flag */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * event structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_event</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_ipc_object</span> <span class="title">parent</span>;</span>                        <span class="comment">/**&lt; inherit from ipc_object */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint32_t</span>          <span class="built_in">set</span>;                           <span class="comment">/**&lt; event set */</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_event</span> *<span class="title">rt_event_t</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="建立事件"><a href="#建立事件" class="headerlink" title="建立事件"></a>建立事件</h3><h4 id="動態記憶體管理-4"><a href="#動態記憶體管理-4" class="headerlink" title="動態記憶體管理"></a>動態記憶體管理</h4><p><i class="fa fa-code"></i> Code: <code>rt_event_create</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>建立事件</td>
<td>事件</td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th><code>*name</code></th>
<th><code>flag</code></th>
</tr>
</thead>
<tbody><tr>
<td>名字</td>
<td>FIFO / PRIO</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will create an event object from system resource</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name the name of event</span></span><br><span class="line"><span class="comment"> * @param flag the flag of event</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the created event, RT_NULL on error happen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_event_t</span> rt_event_create(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">rt_uint8_t</span> flag)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_event_t</span> event;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate object */</span></span><br><span class="line">    event = (<span class="keyword">rt_event_t</span>)rt_object_allocate(RT_Object_Class_Event, name);</span><br><span class="line">    <span class="keyword">if</span> (event == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> event;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set parent */</span></span><br><span class="line">    event-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init ipc object */</span></span><br><span class="line">    rt_ipc_object_init(&amp;(event-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init event */</span></span><br><span class="line">    event-&gt;<span class="built_in">set</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> event;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_event_create);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>一樣 allocate 記憶體，填入 flag，初始化，最後設定值為 0</li>
</ul>
<hr>
<h4 id="靜態記憶體管理-4"><a href="#靜態記憶體管理-4" class="headerlink" title="靜態記憶體管理"></a>靜態記憶體管理</h4><p><i class="fa fa-code"></i> Code: <code>rt_event_init</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>初始化事件</td>
<td><code>RT_EOK</code></td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th><code>event</code></th>
<th><code>*name</code></th>
<th><code>flag</code></th>
</tr>
</thead>
<tbody><tr>
<td>事件本體</td>
<td>名字</td>
<td>FIFO / PRIO</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will initialize an event and put it under control of resource</span></span><br><span class="line"><span class="comment"> * management.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param event the event object</span></span><br><span class="line"><span class="comment"> * @param name the name of event</span></span><br><span class="line"><span class="comment"> * @param flag the flag of event</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_event_init(<span class="keyword">rt_event_t</span> event, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">rt_uint8_t</span> flag)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(event != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init object */</span></span><br><span class="line">    rt_object_init(&amp;(event-&gt;parent.parent), RT_Object_Class_Event, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set parent flag */</span></span><br><span class="line">    event-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init ipc object */</span></span><br><span class="line">    rt_ipc_object_init(&amp;(event-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init event */</span></span><br><span class="line">    event-&gt;<span class="built_in">set</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_event_init);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>這裡則不需要 allocate</li>
</ul>
<hr>
<h3 id="刪除事件"><a href="#刪除事件" class="headerlink" title="刪除事件"></a>刪除事件</h3><h4 id="靜態記憶體管理-5"><a href="#靜態記憶體管理-5" class="headerlink" title="靜態記憶體管理"></a>靜態記憶體管理</h4><p><i class="fa fa-code"></i> Code: <code>rt_event_delete</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>刪除事件</td>
<td><code>RT_EOK</code></td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th><code>event</code></th>
</tr>
</thead>
<tbody><tr>
<td>欲刪除的事件</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will delete an event object and release the memory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param event the event object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_event_delete(<span class="keyword">rt_event_t</span> event)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(event != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;event-&gt;parent.parent) == RT_Object_Class_Event);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;event-&gt;parent.parent) == RT_FALSE);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resume all suspended thread */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(event-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* delete event object */</span></span><br><span class="line">    rt_object_delete(&amp;(event-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_event_delete);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>相同的，需要先將正在等待此事件的 thread 叫醒，再刪除</li>
</ul>
<hr>
<h4 id="靜態記憶體管理-6"><a href="#靜態記憶體管理-6" class="headerlink" title="靜態記憶體管理"></a>靜態記憶體管理</h4><p><i class="fa fa-code"></i> Code: <code>rt_event_detach</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>刪除事件</td>
<td><code>RT_EOK</code></td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th><code>event</code></th>
</tr>
</thead>
<tbody><tr>
<td>欲刪除的事件</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will detach an event object from resource management</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param event the event object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_event_detach(<span class="keyword">rt_event_t</span> event)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(event != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;event-&gt;parent.parent) == RT_Object_Class_Event);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;event-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resume all suspended thread */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(event-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* detach event object */</span></span><br><span class="line">    rt_object_detach(&amp;(event-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_event_detach);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>這裡則用 <code>rt_object_detach</code></li>
</ul>
<hr>
<h3 id="傳遞事件"><a href="#傳遞事件" class="headerlink" title="傳遞事件"></a>傳遞事件</h3><p><i class="fa fa-code"></i> Code: <code>rt_event_send</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>傳遞事件</td>
<td><code>RT_EOK</code></td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th><code>event</code></th>
<th><code>set</code></th>
</tr>
</thead>
<tbody><tr>
<td>欲傳遞的事件</td>
<td>事件編號</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will send an event to the event object, if there are threads</span></span><br><span class="line"><span class="comment"> * suspended on event object, it will be waked up.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param event the event object</span></span><br><span class="line"><span class="comment"> * @param set the event set</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_event_send(<span class="keyword">rt_event_t</span> event, <span class="keyword">rt_uint32_t</span> <span class="built_in">set</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_list_node</span> *<span class="title">n</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> level;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> status;</span><br><span class="line">    <span class="keyword">rt_bool_t</span> need_schedule;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(event != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;event-&gt;parent.parent) == RT_Object_Class_Event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -RT_ERROR;</span><br><span class="line"></span><br><span class="line">    need_schedule = RT_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>下面會修改事件的資料，這裡先將中斷關閉</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* set event */</span></span><br><span class="line">event-&gt;<span class="built_in">set</span> |= <span class="built_in">set</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>設定事件編號</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&amp;(event-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!rt_list_isempty(&amp;event-&gt;parent.suspend_thread))</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* search thread list to resume thread */</span></span><br><span class="line">    n = event-&gt;parent.suspend_thread.next;</span><br><span class="line">    <span class="keyword">while</span> (n != &amp;(event-&gt;parent.suspend_thread))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* get thread */</span></span><br><span class="line">        thread = rt_list_entry(n, struct rt_thread, tlist);</span><br><span class="line"></span><br><span class="line">        status = -RT_ERROR;</span><br><span class="line">        <span class="keyword">if</span> (thread-&gt;event_info &amp; RT_EVENT_FLAG_AND)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> ((thread-&gt;event_set &amp; event-&gt;<span class="built_in">set</span>) == thread-&gt;event_set)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">/* received an AND event */</span></span><br><span class="line">                status = RT_EOK;</span><br><span class="line">            }</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果有人在等待此事件，且滿足條件時，設定為 OK</li>
<li>這裡為 AND，即事件編號應與 thread 所設定的一致</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (thread-&gt;event_info &amp; RT_EVENT_FLAG_OR)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;event_set &amp; event-&gt;<span class="built_in">set</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* save recieved event set */</span></span><br><span class="line">        thread-&gt;event_set = thread-&gt;event_set &amp; event-&gt;<span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* received an OR event */</span></span><br><span class="line">        status = RT_EOK;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>若為 OR，則只需有一位相同即可</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* move node to the next */</span></span><br><span class="line">n = n-&gt;next;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>接著走向下一顆</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* condition is satisfied, resume thread */</span></span><br><span class="line"><span class="keyword">if</span> (status == RT_EOK)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* clear event */</span></span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;event_info &amp; RT_EVENT_FLAG_CLEAR)</span><br><span class="line">        event-&gt;<span class="built_in">set</span> &amp;= ~thread-&gt;event_set;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如有人滿足條件，且被設定 CLEAR，清除其標記位</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">            <span class="comment">/* resume thread, and thread list breaks out */</span></span><br><span class="line">            rt_thread_resume(thread);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* need do a scheduling */</span></span><br><span class="line">            need_schedule = RT_TRUE;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>並恢復此 thread，設定待會需要調度</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do a schedule */</span></span><br><span class="line">    <span class="keyword">if</span> (need_schedule == RT_TRUE)</span><br><span class="line">        rt_schedule();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_event_send);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>最後開啟中斷，視情況做一次調度</li>
</ul>
<hr>
<h3 id="接收事件"><a href="#接收事件" class="headerlink" title="接收事件"></a>接收事件</h3><p><i class="fa fa-code"></i> Code: <code>rt_event_recv</code></p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>接收事件</td>
<td><code>RT_EOK</code></td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th><code>event</code></th>
<th><code>set</code></th>
<th><code>option</code></th>
<th><code>timeout</code></th>
<th><code>*recved</code></th>
</tr>
</thead>
<tbody><tr>
<td>欲接收的事件</td>
<td>事件編號</td>
<td>AND /OR</td>
<td>等待時間（如果需要）</td>
<td>傳遞成功的事件號碼</td>
</tr>
</tbody></table>
</div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will receive an event from event object, if the event is</span></span><br><span class="line"><span class="comment"> * unavailable, the thread shall wait for a specified time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param event the fast event object</span></span><br><span class="line"><span class="comment"> * @param set the interested event set</span></span><br><span class="line"><span class="comment"> * @param option the receive option, either RT_EVENT_FLAG_AND or</span></span><br><span class="line"><span class="comment"> *        RT_EVENT_FLAG_OR should be set.</span></span><br><span class="line"><span class="comment"> * @param timeout the waiting time</span></span><br><span class="line"><span class="comment"> * @param recved the received event, if you don't care, RT_NULL can be set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_event_recv(<span class="keyword">rt_event_t</span>   event,</span><br><span class="line">                       <span class="keyword">rt_uint32_t</span>  <span class="built_in">set</span>,</span><br><span class="line">                       <span class="keyword">rt_uint8_t</span>   option,</span><br><span class="line">                       <span class="keyword">rt_int32_t</span>   timeout,</span><br><span class="line">                       <span class="keyword">rt_uint32_t</span> *recved)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> level;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> status;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_IN_THREAD_CONTEXT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(event != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;event-&gt;parent.parent) == RT_Object_Class_Event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -RT_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init status */</span></span><br><span class="line">    status = -RT_ERROR;</span><br><span class="line">    <span class="comment">/* get current thread */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line">    <span class="comment">/* reset thread error */</span></span><br><span class="line">    thread-&gt;error = RT_EOK;</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&amp;(event-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>下面會修改事件的資料，這裡先將中斷關閉</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* check event set */</span></span><br><span class="line"><span class="keyword">if</span> (option &amp; RT_EVENT_FLAG_AND)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> ((event-&gt;<span class="built_in">set</span> &amp; <span class="built_in">set</span>) == <span class="built_in">set</span>)</span><br><span class="line">        status = RT_EOK;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (option &amp; RT_EVENT_FLAG_OR)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">set</span> &amp; <span class="built_in">set</span>)</span><br><span class="line">        status = RT_EOK;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* either RT_EVENT_FLAG_AND or RT_EVENT_FLAG_OR should be set */</span></span><br><span class="line">    RT_ASSERT(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果滿足條件，表示已接收到事件，設定為 OK</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (status == RT_EOK)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* set received event */</span></span><br><span class="line">    <span class="keyword">if</span> (recved)</span><br><span class="line">        *recved = (event-&gt;<span class="built_in">set</span> &amp; <span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* received event */</span></span><br><span class="line">    <span class="keyword">if</span> (option &amp; RT_EVENT_FLAG_CLEAR)</span><br><span class="line">        event-&gt;<span class="built_in">set</span> &amp;= ~<span class="built_in">set</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果已接收到事件，設定 recved 參數</li>
<li>視情況看需不需要清除標記</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (timeout == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* no waiting */</span></span><br><span class="line">    thread-&gt;error = -RT_ETIMEOUT;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>若需等待事件，但 timeout 為 0</li>
<li>即不等待，將錯誤碼設為 TIMEOUT</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* fill thread event info */</span></span><br><span class="line">    thread-&gt;event_set  = <span class="built_in">set</span>;</span><br><span class="line">    thread-&gt;event_info = option;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如欲等待，將資訊掛在 thread 的結構上</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* put thread to suspended thread list */</span></span><br><span class="line">rt_ipc_list_suspend(&amp;(event-&gt;parent.suspend_thread),</span><br><span class="line">                    thread,</span><br><span class="line">                    event-&gt;parent.parent.flag);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>並插入等待的鏈上</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* if there is a waiting timeout, active thread timer */</span></span><br><span class="line"><span class="keyword">if</span> (timeout &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* reset the timeout of thread timer and start it */</span></span><br><span class="line">    rt_timer_control(&amp;(thread-&gt;thread_timer),</span><br><span class="line">                     RT_TIMER_CTRL_SET_TIME,</span><br><span class="line">                     &amp;timeout);</span><br><span class="line">    rt_timer_start(&amp;(thread-&gt;thread_timer));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>啟動一個 timer</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* enable interrupt */</span></span><br><span class="line">rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* do a schedule */</span></span><br><span class="line">rt_schedule();</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>最後開啟中斷，並做一次調度</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (thread-&gt;error != RT_EOK)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* return error */</span></span><br><span class="line">            <span class="keyword">return</span> thread-&gt;error;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* received an event, disable interrupt to protect */</span></span><br><span class="line">        level = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* set received event */</span></span><br><span class="line">        <span class="keyword">if</span> (recved)</span><br><span class="line">            *recved = thread-&gt;event_set;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&amp;(event-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> thread-&gt;error;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_event_recv);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>最終接收到事件，一樣設定 recved 參數，回傳錯誤碼</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>

                
            </div>
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-tags">
                    
                        tags: 


<a href="/tags/kernel/">#kernel</a> <a href="/tags/RT-Thread/">#RT-Thread</a> <a href="/tags/semaphore/">#semaphore</a>


                    
                </div>
            

            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="pager">
                        
                            <li class="previous"><a href="/rt-ipc-2/">&larr;  下一頁</a></li>
                        
                        
                            <li class="next"><a href="/rt-clock/">上一頁  &rarr;</a></li>
                        
                    </ul>
                </div>
            
            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article> 




    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/luswdev" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted footer-author">&copy; 2020 LuSkywalker</p>
                <ul class="copyright text-muted footer-menu">
                    
                        <li>
                            <a href="/">
                                
                                    Home
                                
                            </a>
                        </li>
                    
                        <li>
                            <a href="/archives">
                                
                                    Archives
                                
                            </a>
                        </li>
                    
                        <li>
                            <a href="/tags">
                                
                                    Tags
                                
                            </a>
                        </li>
                    
                        <li>
                            <a href="/categories">
                                
                                    Categories
                                
                            </a>
                        </li>
                    
                        <li>
                            <a href="/about">
                                
                                    About
                                
                            </a>
                        </li>
                    
                </ul>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments --><!-- hexo-inject:begin --><!-- hexo-inject:end -->



</body>

</html>