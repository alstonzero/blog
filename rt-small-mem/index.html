<!DOCTYPE html>
<html lang="zh-TW">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">

    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->

    

    
        <meta name="description" content="單晶片、即時作業系統與韌體相關之技術筆記">
    

    <!--Author-->
    
        <meta name="author" content="LuSkywalker">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="RT-Thread 小記憶體動態管理">
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="單晶片、即時作業系統與韌體相關之技術筆記">
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="技術筆記">

    <!--Type page-->
    
        <meta property="og:type" content="article">
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="http://blog.lusw.devhttp://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg">
    

        <meta name="twitter:card" content="summary_large_image">

    

    
        <meta name="twitter:image" content="http://blog.lusw.devhttp://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg">
    

    <!-- Title -->
    
    <title>RT-Thread 小記憶體動態管理 - 技術筆記</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">
    <link href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet">

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
    <link rel="icon" href="/img/favicon.png">
    

<link rel="alternate" href="/atom.xml" title="技術筆記" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>

    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">技術筆記</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/tags/Linux">
                            
                                Linux
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags/RT-Thread">
                            
                                RT-Thread
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags/XV6">
                            
                                XV6
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags/Clang">
                            
                                C Lang
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/luswdev">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>RT-Thread 小記憶體動態管理</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2018-12-05
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-categories">
                    
                        

<a href="/categories/RT-Thread/">RT-Thread</a>

                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>File: mem.c</p>
</blockquote>
<ul>
<li>與 memory heap 的做法類似，一開始是一塊大的記憶體，包含 header</li>
<li>分配記憶體時適當的切割</li>
<li>所有的記憶體塊透過 header 串起來，形成一個雙向鏈結</li>
</ul>
<p><img src="https://i.imgur.com/tbptSYO.png" alt="" title="small memory example"></p>
<blockquote>
<p>使用此管理方式： <code>#defined RT_USING_HEAP &amp;&amp; #defined RT_USING_SMALL_MEM</code></p>
</blockquote>
<h2 id="結構"><a href="#結構" class="headerlink" title="結構"></a>結構</h2><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* magic and used flag */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span> magic;</span><br><span class="line">    <span class="keyword">rt_uint16_t</span> used;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_size_t</span> next, prev;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span> thread[<span class="number">4</span>];   <span class="comment">/* thread name */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>此結構即為一個記憶體塊的 header</li>
<li>包含了<ul>
<li>magic 碼 <code>0x1ea0</code></li>
<li>使用中標記</li>
<li>前一顆與下一顆</li>
<li>使用此記憶體的 thread 名稱（選）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="初始化-heap"><a href="#初始化-heap" class="headerlink" title="初始化 heap"></a>初始化 heap</h2><p><i class="fa fa-code"></i> Code: <code>rt_system_heap_init</code></p>
<div class="table-responsive">
<table class="table">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>初始化 heap</td>
<td>void</td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table">
<thead>
<tr>
<th><code>*begin_addr</code></th>
<th><code>*end_addr</code></th>
</tr>
</thead>
<tbody><tr>
<td>記憶體起始位址</td>
<td>結束位址</td>
</tr>
</tbody></table>
</div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ingroup SystemInit</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function will initialize system heap memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param begin_addr the beginning address of system heap memory.</span></span><br><span class="line"><span class="comment"> * @param end_addr the end address of system heap memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_system_heap_init</span><span class="params">(<span class="keyword">void</span> *begin_addr, <span class="keyword">void</span> *end_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">mem</span>;</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> begin_align = RT_ALIGN((<span class="keyword">rt_uint32_t</span>)begin_addr, RT_ALIGN_SIZE);</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> end_align = RT_ALIGN_DOWN((<span class="keyword">rt_uint32_t</span>)end_addr, RT_ALIGN_SIZE);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>向上對齊起始位址與向下對齊結束位址</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* alignment addr */</span></span><br><span class="line"><span class="keyword">if</span> ((end_align &gt; (<span class="number">2</span> * SIZEOF_STRUCT_MEM)) &amp;&amp;</span><br><span class="line">    ((end_align - <span class="number">2</span> * SIZEOF_STRUCT_MEM) &gt;= begin_align))</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* calculate the aligned memory size */</span></span><br><span class="line">    mem_size_aligned = end_align - begin_align - <span class="number">2</span> * SIZEOF_STRUCT_MEM;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    rt_kprintf(<span class="string">"mem init, error begin address 0x%x, and end address 0x%x\n"</span>,</span><br><span class="line">               (<span class="keyword">rt_uint32_t</span>)begin_addr, (<span class="keyword">rt_uint32_t</span>)end_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>接著檢查起始與結束位址是否合法</li>
<li>如果合法，給定 <code>mem_size</code> 為結束位址 - 起始位址 - 2 倍的 <code>struct mem</code> 大小</li>
<li>也就是與 <code>mem_heap</code> 相同，一開始的記憶體設定為一大塊，頭與尾都要有一個 header</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* point to begin address of heap */</span></span><br><span class="line">heap_ptr = (<span class="keyword">rt_uint8_t</span> *)begin_align;</span><br><span class="line"></span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"mem init, heap begin address 0x%x, size %d\n"</span>,</span><br><span class="line">                            (<span class="keyword">rt_uint32_t</span>)heap_ptr, mem_size_aligned));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initialize the start of the heap */</span></span><br><span class="line">mem        = (struct heap_mem *)heap_ptr;</span><br><span class="line">mem-&gt;magic = HEAP_MAGIC;</span><br><span class="line">mem-&gt;next  = mem_size_aligned + SIZEOF_STRUCT_MEM;</span><br><span class="line">mem-&gt;prev  = <span class="number">0</span>;</span><br><span class="line">mem-&gt;used  = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>接著設定前面的 header：<ul>
<li>設定 magic 碼</li>
<li>下一塊為結尾的 header</li>
<li>上一塊為自己</li>
<li>以及沒有使用過</li>
</ul>
</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">    rt_mem_setname(mem, <span class="string">"INIT"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize the end of the heap */</span></span><br><span class="line">    heap_end        = (struct heap_mem *)&amp;heap_ptr[mem-&gt;next];</span><br><span class="line">    heap_end-&gt;magic = HEAP_MAGIC;</span><br><span class="line">    heap_end-&gt;used  = <span class="number">1</span>;</span><br><span class="line">    heap_end-&gt;next  = mem_size_aligned + SIZEOF_STRUCT_MEM;</span><br><span class="line">    heap_end-&gt;prev  = mem_size_aligned + SIZEOF_STRUCT_MEM;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">    rt_mem_setname(heap_end, <span class="string">"INIT"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>接著設定結尾的 header<ul>
<li>magic 碼</li>
<li>已被使用過</li>
<li>上一塊與下一塊指向自己</li>
</ul>
</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    rt_sem_init(&amp;heap_sem, <span class="string">"heap"</span>, <span class="number">1</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize the lowest-free pointer to the start of the heap */</span></span><br><span class="line">    lfree = (struct heap_mem *)heap_ptr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>最後初始化 semaphore</li>
<li>把這一塊掛上 <code>lfree</code></li>
</ul>
<hr>
<h2 id="分配記憶體"><a href="#分配記憶體" class="headerlink" title="分配記憶體"></a>分配記憶體</h2><h3 id="Code-rt-malloc"><a href="#Code-rt-malloc" class="headerlink" title="Code: rt_malloc"></a>Code: rt_malloc</h3><div class="table-responsive">
<table class="table">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>要求記憶體</td>
<td>記憶體位址</td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table">
<thead>
<tr>
<th><code>size</code></th>
</tr>
</thead>
<tbody><tr>
<td>欲要求的大小</td>
</tr>
</tbody></table>
</div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocate a block of memory with a minimum of 'size' bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param size is the minimum size of the requested block in bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return pointer to allocated memory or NULL if no free memory was found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_malloc</span><span class="params">(<span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_size_t</span> ptr, ptr2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">mem</span>, *<span class="title">mem2</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果 <code>size</code> 為 0，回傳 NULL</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size != RT_ALIGN(size, RT_ALIGN_SIZE))</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"malloc size %d, but align to %d\n"</span>,</span><br><span class="line">                                size, RT_ALIGN(size, RT_ALIGN_SIZE)));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"malloc size %d\n"</span>, size));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* alignment size */</span></span><br><span class="line">size = RT_ALIGN(size, RT_ALIGN_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &gt; mem_size_aligned)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"no memory\n"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>向上對齊 <code>size</code>，如果超過可用大小，回傳 NULL</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* every data block must be at least MIN_SIZE_ALIGNED long */</span></span><br><span class="line"><span class="keyword">if</span> (size &lt; MIN_SIZE_ALIGNED)</span><br><span class="line">    size = MIN_SIZE_ALIGNED;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果小於 min size，設為 min size</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* take memory semaphore */</span></span><br><span class="line">rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>取得 semaphore</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ptr = (<span class="keyword">rt_uint8_t</span> *)lfree - heap_ptr;</span><br><span class="line">     ptr &lt; mem_size_aligned - size;</span><br><span class="line">     ptr = ((struct heap_mem *)&amp;heap_ptr[ptr])-&gt;next)</span><br><span class="line">{</span><br><span class="line">    mem = (struct heap_mem *)&amp;heap_ptr[ptr];</span><br></pre></td></tr></tbody></table></figure>

<p>這裡特別的說明一下 for 迴圈：<br>首先起點是 <code>lfree</code> - <code>heap_ptr</code>，這裡代表最左邊的 free block 與 heap 起點的距離。 我們把 <code>heap_ptr</code> 看成是一個 <code>rt_uint8_t</code> 的陣列，也就是一格一個 byte 的陣列。 再來把 <code>lfree</code> - <code>heap_ptr</code> 看成是差量 (offset)，單位是 byte。 如此一來，<code>&amp;heap_ptr[ptr]</code> 就會是 <code>lfree</code> 的起始位置了。</p>
<p>再來我們看 <code>next</code>，在初始化的時候，<code>next</code> 是指向 0，這個意思是下一顆在陣列的第 0 個，也就是自己；所以 <code>next</code> 存放的是下一顆的 index，而不是起始位置。</p>
<p>最後來看上界，理論上我們需要從 lfree 找到最後一顆，實際上如果最後幾顆不夠大的話是不需要檢查的，所以這裡上界設在 <code>mem_size_aligned</code> - <code>size</code> 的意思就是說如果最後幾顆的大小總和不夠大，我們可以略過。</p>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((!mem-&gt;used) &amp;&amp; (mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM)) &gt;= size)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* mem is not used and at least perfect fit is possible:</span></span><br><span class="line"><span class="comment">     * mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>first fit，如果找到第一顆可用的就進去</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM) &gt;=</span><br><span class="line">    (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))</span><br><span class="line">{</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>又，如果這顆夠大到可以切割的話</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">                <span class="comment">/* (in addition to the above, we test if another struct heap_mem (SIZEOF_STRUCT_MEM) containing</span></span><br><span class="line"><span class="comment">                 * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')</span></span><br><span class="line"><span class="comment">                 * -&gt; split large block, create empty remainder,</span></span><br><span class="line"><span class="comment">                 * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if</span></span><br><span class="line"><span class="comment">                 * mem-&gt;next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,</span></span><br><span class="line"><span class="comment">                 * struct heap_mem would fit in but no data between mem2 and mem2-&gt;next</span></span><br><span class="line"><span class="comment">                 * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty</span></span><br><span class="line"><span class="comment">                 *       region that couldn't hold data, but when mem-&gt;next gets freed,</span></span><br><span class="line"><span class="comment">                 *       the 2 regions would be combined, resulting in more free memory</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                ptr2 = ptr + SIZEOF_STRUCT_MEM + size;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* create mem2 struct */</span></span><br><span class="line">                mem2       = (struct heap_mem *)&amp;heap_ptr[ptr2];</span><br><span class="line">                mem2-&gt;magic = HEAP_MAGIC;</span><br><span class="line">                mem2-&gt;used = <span class="number">0</span>;</span><br><span class="line">                mem2-&gt;next = mem-&gt;next;</span><br><span class="line">                mem2-&gt;prev = ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">                rt_mem_setname(mem2, <span class="string">"    "</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>設定下一顆的資料，同時把 <code>next</code> 與 <code>prev</code> 接到正確位置</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* and insert it between mem and mem-&gt;next */</span></span><br><span class="line">mem-&gt;next = ptr2;</span><br><span class="line">mem-&gt;used = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mem2-&gt;next != mem_size_aligned + SIZEOF_STRUCT_MEM)</span><br><span class="line">{</span><br><span class="line">    ((struct heap_mem *)&amp;heap_ptr[mem2-&gt;next])-&gt;prev = ptr2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>接著把原本那塊的 <code>next</code> 指向新的那塊，設為使用中</li>
<li>如果新的那塊 <code>next</code> 不是最後一塊，設定 <code>prev</code></li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">                used_mem += (size + SIZEOF_STRUCT_MEM);</span><br><span class="line">                <span class="keyword">if</span> (max_mem &lt; used_mem)</span><br><span class="line">                    max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            }</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>最後更新 <code>used_mem</code> 與 <code>max_mem</code></li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="comment">/* (a mem2 struct does no fit into the user data space of mem and mem-&gt;next will always</span></span><br><span class="line"><span class="comment">                 * be used at this point: if not we have 2 unused structs in a row, plug_holes should have</span></span><br><span class="line"><span class="comment">                 * take care of this).</span></span><br><span class="line"><span class="comment">                 * -&gt; near fit or excact fit: do not split, no mem2 creation</span></span><br><span class="line"><span class="comment">                 * also can't move mem-&gt;next directly behind mem, since mem-&gt;next</span></span><br><span class="line"><span class="comment">                 * will always be used at this point!</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                mem-&gt;used = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">                used_mem += mem-&gt;next - ((<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr);</span><br><span class="line">                <span class="keyword">if</span> (max_mem &lt; used_mem)</span><br><span class="line">                    max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            }</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果不可切割，只需設定使用中即可</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">/* set memory block magic */</span></span><br><span class="line">            mem-&gt;magic = HEAP_MAGIC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">            <span class="keyword">if</span> (rt_thread_self())</span><br><span class="line">                rt_mem_setname(mem, rt_thread_self()-&gt;name);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rt_mem_setname(mem, <span class="string">"NONE"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mem == lfree)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">/* Find next free block after mem and update lowest free pointer */</span></span><br><span class="line">                <span class="keyword">while</span> (lfree-&gt;used &amp;&amp; lfree != heap_end)</span><br><span class="line">                    lfree = (struct heap_mem *)&amp;heap_ptr[lfree-&gt;next];</span><br><span class="line"></span><br><span class="line">                RT_ASSERT(((lfree == heap_end) || (!lfree-&gt;used)));</span><br><span class="line">            }</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>視情況更新 <code>lfree</code></li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        rt_sem_release(&amp;heap_sem);</span><br><span class="line">        RT_ASSERT((<span class="keyword">rt_uint32_t</span>)mem + SIZEOF_STRUCT_MEM + size &lt;= (<span class="keyword">rt_uint32_t</span>)heap_end);</span><br><span class="line">        RT_ASSERT((<span class="keyword">rt_uint32_t</span>)((<span class="keyword">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM) % RT_ALIGN_SIZE == <span class="number">0</span>);</span><br><span class="line">        RT_ASSERT((((<span class="keyword">rt_uint32_t</span>)mem) &amp; (RT_ALIGN_SIZE - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_MEM,</span><br><span class="line">                     (<span class="string">"allocate memory at 0x%x, size: %d\n"</span>,</span><br><span class="line">                      (<span class="keyword">rt_uint32_t</span>)((<span class="keyword">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM),</span><br><span class="line">                      (<span class="keyword">rt_uint32_t</span>)(mem-&gt;next - ((<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr))));</span><br><span class="line"></span><br><span class="line">        RT_OBJECT_HOOK_CALL(rt_malloc_hook,</span><br><span class="line">                            (((<span class="keyword">void</span> *)((<span class="keyword">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM)), size));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* return the memory data except mem struct */</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>還鎖，並回傳找到的記憶體位址</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_malloc);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>沒找到一樣還鎖，並回傳 NULL</li>
</ul>
<hr>
<h3 id="Code-rt-realloc"><a href="#Code-rt-realloc" class="headerlink" title="Code: rt_realloc"></a>Code: rt_realloc</h3><div class="table-responsive">
<table class="table">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>增長/縮減記憶體</td>
<td>記憶體位址</td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table">
<thead>
<tr>
<th><code>*rmeme</code></th>
<th><code>newsize</code></th>
</tr>
</thead>
<tbody><tr>
<td>欲增長/縮減的記憶體位址</td>
<td>新的大小</td>
</tr>
</tbody></table>
</div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will change the previously allocated memory block.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rmem pointer to memory allocated by rt_malloc</span></span><br><span class="line"><span class="comment"> * @param newsize the required new size</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the changed memory block address</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_realloc</span><span class="params">(<span class="keyword">void</span> *rmem, <span class="keyword">rt_size_t</span> newsize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_size_t</span> size;</span><br><span class="line">    <span class="keyword">rt_size_t</span> ptr, ptr2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">mem</span>, *<span class="title">mem2</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *nmem;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* alignment size */</span></span><br><span class="line">    newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (newsize &gt; mem_size_aligned)</span><br><span class="line">    {</span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"realloc: out of memory\n"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (newsize == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_free(rmem);</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>向上對齊 size，如果：<ul>
<li>大於可用大小，回傳 NULL</li>
<li>等於 0，free 記憶體，回傳 NULL</li>
</ul>
</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* allocate a new memory block */</span></span><br><span class="line"><span class="keyword">if</span> (rmem == RT_NULL)</span><br><span class="line">    <span class="keyword">return</span> rt_malloc(newsize);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如原來的記憶體為空，直接 <code>malloc</code>，並回傳</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">rt_uint8_t</span> *)rmem &lt; (<span class="keyword">rt_uint8_t</span> *)heap_ptr ||</span><br><span class="line">    (<span class="keyword">rt_uint8_t</span> *)rmem &gt;= (<span class="keyword">rt_uint8_t</span> *)heap_end)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* illegal memory */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rmem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>接著取得鎖，檢查傳入的記憶體是否合法</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mem = (struct heap_mem *)((<span class="keyword">rt_uint8_t</span> *)rmem - SIZEOF_STRUCT_MEM);</span><br><span class="line"></span><br><span class="line">ptr = (<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr;</span><br><span class="line">size = mem-&gt;next - ptr - SIZEOF_STRUCT_MEM;</span><br><span class="line"><span class="keyword">if</span> (size == newsize)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* the size is the same as */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rmem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>找到記憶體塊的起始位址，算出 size，如果記憶體大小不需要變動，不做事，回傳原本的記憶體位址</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE &lt; size)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* split memory block */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem -= (size - newsize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;</span><br><span class="line">        mem2 = (struct heap_mem *)&amp;heap_ptr[ptr2];</span><br><span class="line">        mem2-&gt;magic = HEAP_MAGIC;</span><br><span class="line">        mem2-&gt;used = <span class="number">0</span>;</span><br><span class="line">        mem2-&gt;next = mem-&gt;next;</span><br><span class="line">        mem2-&gt;prev = ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">        rt_mem_setname(mem2, <span class="string">"    "</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        mem-&gt;next = ptr2;</span><br><span class="line">        <span class="keyword">if</span> (mem2-&gt;next != mem_size_aligned + SIZEOF_STRUCT_MEM)</span><br><span class="line">        {</span><br><span class="line">            ((struct heap_mem *)&amp;heap_ptr[mem2-&gt;next])-&gt;prev = ptr2;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果可以切割，與上面的動作相同</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    plug_holes(mem2);</span><br><span class="line"></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rmem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>-使用 <code>plug_holes</code> 來合併 free block</p>
<ul>
<li>還鎖，回傳更新後的記憶體位置</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* expand memory */</span></span><br><span class="line">    nmem = rt_malloc(newsize);</span><br><span class="line">    <span class="keyword">if</span> (nmem != RT_NULL) <span class="comment">/* check memory */</span></span><br><span class="line">    {</span><br><span class="line">        rt_memcpy(nmem, rmem, size &lt; newsize ? size : newsize);</span><br><span class="line">        rt_free(rmem);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nmem;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_realloc);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果不可切割，或是需要增長，直接要一塊 new size，釋放原本的記憶體</li>
<li>最後回傳新的記憶體位址</li>
</ul>
<hr>
<p><i class="fa fa-code"></i> Code: <code>plug_holes</code></p>
<div class="table-responsive">
<table class="table">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>合併 free block</td>
<td>void</td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table">
<thead>
<tr>
<th><code>*mem</code></th>
</tr>
</thead>
<tbody><tr>
<td>欲合併的記憶體位址</td>
</tr>
</tbody></table>
</div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">plug_holes</span><span class="params">(struct heap_mem *mem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">nmem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">pmem</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT((<span class="keyword">rt_uint8_t</span> *)mem &gt;= heap_ptr);</span><br><span class="line">    RT_ASSERT((<span class="keyword">rt_uint8_t</span> *)mem &lt; (<span class="keyword">rt_uint8_t</span> *)heap_end);</span><br><span class="line">    RT_ASSERT(mem-&gt;used == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* plug hole forward */</span></span><br><span class="line">    nmem = (struct heap_mem *)&amp;heap_ptr[mem-&gt;next];</span><br><span class="line">    <span class="keyword">if</span> (mem != nmem &amp;&amp;</span><br><span class="line">        nmem-&gt;used == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (<span class="keyword">rt_uint8_t</span> *)nmem != (<span class="keyword">rt_uint8_t</span> *)heap_end)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* if mem-&gt;next is unused and not end of heap_ptr,</span></span><br><span class="line"><span class="comment">         * combine mem and mem-&gt;next</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (lfree == nmem)</span><br><span class="line">        {</span><br><span class="line">            lfree = mem;</span><br><span class="line">        }</span><br><span class="line">        mem-&gt;next = nmem-&gt;next;</span><br><span class="line">        ((struct heap_mem *)&amp;heap_ptr[nmem-&gt;next])-&gt;prev = (<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果可以與下一顆合併</li>
<li>檢查是否需要更新 <code>lfree</code></li>
<li>重新接上 <code>next</code> 與 <code>prev</code> (<code>next</code> 的 <code>prev</code>)</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* plug hole backward */</span></span><br><span class="line">    pmem = (struct heap_mem *)&amp;heap_ptr[mem-&gt;prev];</span><br><span class="line">    <span class="keyword">if</span> (pmem != mem &amp;&amp; pmem-&gt;used == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* if mem-&gt;prev is unused, combine mem and mem-&gt;prev */</span></span><br><span class="line">        <span class="keyword">if</span> (lfree == mem)</span><br><span class="line">        {</span><br><span class="line">            lfree = pmem;</span><br><span class="line">        }</span><br><span class="line">        pmem-&gt;next = mem-&gt;next;</span><br><span class="line">        ((struct heap_mem *)&amp;heap_ptr[mem-&gt;next])-&gt;prev = (<span class="keyword">rt_uint8_t</span> *)pmem - heap_ptr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果可以與上一顆合併，動作一樣</li>
</ul>
<hr>
<h3 id="Code-rt-calloc"><a href="#Code-rt-calloc" class="headerlink" title="Code: rt_calloc"></a>Code: rt_calloc</h3><div class="table-responsive">
<table class="table">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>要求一段連續的記憶體</td>
<td>記憶體位址</td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table">
<thead>
<tr>
<th><code>count</code></th>
<th><code>size</code></th>
</tr>
</thead>
<tbody><tr>
<td>欲要求的數量</td>
<td>一塊的大小</td>
</tr>
</tbody></table>
</div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will contiguously allocate enough space for count objects</span></span><br><span class="line"><span class="comment"> * that are size bytes of memory each and returns a pointer to the allocated</span></span><br><span class="line"><span class="comment"> * memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The allocated memory is filled with bytes of value zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param count number of objects to allocate</span></span><br><span class="line"><span class="comment"> * @param size size of the objects to allocate</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return pointer to allocated memory / NULL pointer if there is an error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_calloc</span><span class="params">(<span class="keyword">rt_size_t</span> count, <span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate 'count' objects of size 'size' */</span></span><br><span class="line">    p = rt_malloc(count * size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zero the memory */</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        rt_memset(p, <span class="number">0</span>, count * size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_calloc);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>與 memheap 相同，一次要一塊 count 乘 size 的記憶體</li>
<li>清 0 並回傳起始位址</li>
</ul>
<hr>
<h2 id="釋放記憶體"><a href="#釋放記憶體" class="headerlink" title="釋放記憶體"></a>釋放記憶體</h2><p><i class="fa fa-code"></i> Code: <code>rt_free</code></p>
<div class="table-responsive">
<table class="table">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody><tr>
<td>釋放記憶體</td>
<td>void</td>
</tr>
</tbody></table>
</div><div class="table-responsive">
<table class="table">
<thead>
<tr>
<th><code>*rmem</code></th>
</tr>
</thead>
<tbody><tr>
<td>欲釋放的記憶體</td>
</tr>
</tbody></table>
</div><figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will release the previously allocated memory block by</span></span><br><span class="line"><span class="comment"> * rt_malloc. The released memory block is taken back to system heap.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rmem the address of memory which will be released</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_free</span><span class="params">(<span class="keyword">void</span> *rmem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">mem</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rmem == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果需要釋放得記憶體為空，不做事</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">RT_ASSERT((((<span class="keyword">rt_uint32_t</span>)rmem) &amp; (RT_ALIGN_SIZE - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">RT_ASSERT((<span class="keyword">rt_uint8_t</span> *)rmem &gt;= (<span class="keyword">rt_uint8_t</span> *)heap_ptr &amp;&amp;</span><br><span class="line">          (<span class="keyword">rt_uint8_t</span> *)rmem &lt; (<span class="keyword">rt_uint8_t</span> *)heap_end);</span><br><span class="line"></span><br><span class="line">RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">rt_uint8_t</span> *)rmem &lt; (<span class="keyword">rt_uint8_t</span> *)heap_ptr ||</span><br><span class="line">    (<span class="keyword">rt_uint8_t</span> *)rmem &gt;= (<span class="keyword">rt_uint8_t</span> *)heap_end)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"illegal memory\n"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the corresponding struct heap_mem ... */</span></span><br><span class="line">mem = (struct heap_mem *)((<span class="keyword">rt_uint8_t</span> *)rmem - SIZEOF_STRUCT_MEM);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>檢查記憶體位址是否合法，並找到真正的記憶體區塊位址</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEM,</span><br><span class="line">             (<span class="string">"release memory 0x%x, size: %d\n"</span>,</span><br><span class="line">              (<span class="keyword">rt_uint32_t</span>)rmem,</span><br><span class="line">              (<span class="keyword">rt_uint32_t</span>)(mem-&gt;next - ((<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr))));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* protect the heap from concurrent access */</span></span><br><span class="line">rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... which has to be in a used state ... */</span></span><br><span class="line"><span class="keyword">if</span> (!mem-&gt;used || mem-&gt;magic != HEAP_MAGIC)</span><br><span class="line">{</span><br><span class="line">    rt_kprintf(<span class="string">"to free a bad data block:\n"</span>);</span><br><span class="line">    rt_kprintf(<span class="string">"mem: 0x%08x, used flag: %d, magic code: 0x%04x\n"</span>, mem, mem-&gt;used, mem-&gt;magic);</span><br><span class="line">}</span><br><span class="line">RT_ASSERT(mem-&gt;used);</span><br><span class="line">RT_ASSERT(mem-&gt;magic == HEAP_MAGIC);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>要鎖，檢查是否是使用中的區塊，及是否屬於 heap</li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* ... and is now unused. */</span></span><br><span class="line">    mem-&gt;used  = <span class="number">0</span>;</span><br><span class="line">    mem-&gt;magic = HEAP_MAGIC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">    rt_mem_setname(mem, <span class="string">"    "</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem &lt; lfree)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* the newly freed struct is now the lowest */</span></span><br><span class="line">        lfree = mem;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>接著設為可使用，及更新 <code>lfree</code></li>
</ul>
<figure class="highlight c line_number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">    used_mem -= (mem-&gt;next - ((<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* finally, see if prev or next are free also */</span></span><br><span class="line">    plug_holes(mem);</span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_free);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>最後合併記憶體塊，並還鎖</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>

                
            </div>
            
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/kernel/">#kernel</a> <a href="/tags/RT-Thread/">#RT-Thread</a> <a href="/tags/記憶體管理/">#記憶體管理</a>


                    
                </div>
            

            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="pager">
                        
                            <li class="previous"><a href="/rt-slab/">&larr;  下一頁</a></li>
                        
                        
                            <li class="next"><a href="/rt-memheap/">上一頁  &rarr;</a></li>
                        
                    </ul>
                </div>
            
            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article> 




    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/luswdev" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted footer-author">&copy; 2020 LuSkywalker</p>
                <ul class="copyright text-muted footer-menu">
                    
                        <li>
                            <a href="/">
                                
                                    Home
                                
                            </a>
                        </li>
                    
                        <li>
                            <a href="/archives">
                                
                                    Archives
                                
                            </a>
                        </li>
                    
                        <li>
                            <a href="/tags">
                                
                                    Tags
                                
                            </a>
                        </li>
                    
                        <li>
                            <a href="/categories">
                                
                                    Categories
                                
                            </a>
                        </li>
                    
                        <li>
                            <a href="/about">
                                
                                    About
                                
                            </a>
                        </li>
                    
                </ul>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments --><!-- hexo-inject:begin --><!-- hexo-inject:end -->



</body>

</html>